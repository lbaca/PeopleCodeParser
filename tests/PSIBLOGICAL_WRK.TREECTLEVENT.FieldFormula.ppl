import PT_SCHEMA:*;
import PT_INTEGRATION:*;
import %metadata:MessageDefn:*;

Declare Function savecollection PeopleCode PSIBLOGICAL_WRK.TREECTLEVENT FieldChange;
Declare Function savexmlcollection PeopleCode PSIBLOGICAL_WRK.TREECTLEVENT FieldChange;
Declare Function savejsoncollection PeopleCode PSIBLOGICAL_WRK.TREECTLEVENT FieldChange;
Declare Function getrandomname PeopleCode PSSERVICESWRK.SAVE_PB FieldFormula;
Declare Function deletemessageandschema PeopleCode PSSERVICESWRK.DELETE_PB FieldChange;
Declare Function copyxmldata PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT FieldFormula;
Declare Function copyjsondata PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT4 FieldFormula;
Declare Function MessageDefinitionDelete PeopleCode PSSERVICESWRK.SAVE_PB FieldFormula;
Declare Function savecomplexcompound PeopleCode PSIBLOGICAL_WRK.TREECTLEVENT FieldChange;
Declare Function copyreldata PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT2 FieldFormula;
Declare Function saverelcollection PeopleCode PSIBLOGICAL_WRK.TREECTLEVENT FieldChange;
Declare Function hideallxmlfields PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT FieldFormula;
Declare Function hideallrelfields PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT2 FieldFormula;
Declare Function validatecomplexcompound PeopleCode PSIBLOGICAL_WRK.SAVE_PB FieldFormula;
Declare Function validatexmlschema PeopleCode PSIBLOGICAL_WRK.SAVE_PB FieldFormula;
Declare Function randomschemaname PeopleCode PSSERVICESWRK.SAVE_PB FieldFormula;
Declare Function isAllAttributes PeopleCode PSIBLOGICAL_WRK.SAVE_PB FieldFormula;
Declare Function checkservoperuse PeopleCode IB_MONITOR.IB_MSG_SAVE FieldFormula;
Declare Function checkpsoftservice PeopleCode PSSERVICESWRK.SAVE_PB FieldFormula;
Declare Function checkwsdluse PeopleCode PSSERVICESWRK.SAVE_PB FieldFormula;
Declare Function checkruntime PeopleCode PSSERVICESWRK.SAVE_PB FieldFormula;
Declare Function checkWSDLexportflagOK PeopleCode PSSERVICESWRK.SAVE_PB FieldFormula;
Declare Function setprimitiverelfields PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT2 FieldFormula;
Declare Function ispackagerelational PeopleCode PSIBLOGICAL_WRK.IB_DETAILS_LINK FieldChange;
Declare Function GetHTMLStrType PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT5 FieldFormula;
Declare Function copyhtmldata PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT5 FieldFormula;
Declare Function hidealljsonfields PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT4 FieldFormula;
Declare Function hideallhtmlfields PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT5 FieldFormula;
Declare Function GetHTMLNumType PeopleCode PSIBLOGICAL_WRK.IB_TREECTLEVENT5 FieldFormula;
Declare Function savehtmlcollection PeopleCode PSIBLOGICAL_WRK.TREECTLEVENT FieldChange;

Component Rowset &NODERS, &TREERS;
Component number &CROWNUM;

Component PT_SCHEMA:SchemaConstants &LS_CONSTANTS;
Component string &XMLNAME;
Component string &JSONNAME;
Component string &HTMLNAME;
Component string &INTBRKR_PREFIX;
Component string &RELATIONALNAME;
Component boolean &CMP_READONLY;

Constant &ENUMDELIMETER = "#!~!#";
Constant &PSCOLXMLTAG = "PSCOLXMLTAG";
Constant &PSCOLHTMLTAG = "PSCOLHTMLTAG";

Function CreateKey(&package As string, &document As string, &variant As string) Returns DocumentKey
   Local DocumentKey &key;
   
   &key = CreateDocumentKey(&package, &document, &variant);
   
   Return &key;
End-Function;

/* Used to remove the attribute choice from the xlat list of field IB_LSXMLNODETYPE. 
Pass a True in the second parameter to reset the dropdown translates to the original set. */
Function assigntranslates(&fld As Field, &bSetToDefault As boolean)
   Local Record &rec;
   
   &rec = CreateRecord(Record.PSXLATITEM);
   &rec.FIELDNAME.Value = "IB_LSXMLNODETYPE";
   &rec.EFFDT.Value = "1900-01-01";
   
   If &bSetToDefault Then
      &fld.ClearDropDownList();
      &rec.FIELDVALUE.Value = "1";
      If &rec.SelectByKey() Then
         &fld.AddDropDownItem("1", &rec.XLATLONGNAME.Value);
      End-If;
      &rec.FIELDVALUE.Value = "2";
      If &rec.SelectByKey() Then
         &fld.AddDropDownItem("2", &rec.XLATLONGNAME.Value);
      End-If;
      &rec.FIELDVALUE.Value = "3";
      If &rec.SelectByKey() Then
         &fld.AddDropDownItem("3", &rec.XLATLONGNAME.Value);
      End-If;
   Else
      &fld.ClearDropDownList();
      &rec.FIELDVALUE.Value = "2";
      If &rec.SelectByKey() Then
         &fld.AddDropDownItem("2", &rec.XLATLONGNAME.Value);
      End-If;
      &rec.FIELDVALUE.Value = "3";
      If &rec.SelectByKey() Then
         &fld.AddDropDownItem("3", &rec.XLATLONGNAME.Value);
      End-If;
   End-If;
End-Function;

Function setcomponentreadonly()
   PSLSDEFN_VW.DESCR.Enabled = False;
   PSLSDEFN_VW.OBJECTOWNERID.Enabled = False;
   PSLSDEFN_VW.DESCRLONG.Enabled = False;
   PSIBLOGICAL_WRK.IB_ISPRIVATE.Enabled = False;
   PSIBLOGICAL_WRK.SAVE_PB.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSRENAME.Enabled = False;
   rem PSIBLOGICAL_WRK.IB_LSIMPORT.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSEXPORT.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSDELSCHEMA.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSVALIDATE.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSCOPY.Enabled = False;
   
   PSIBLOGICAL_WRK.IB_LSADDPRIMCHILD.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDCOLLCHILD.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDCOMPCHILD.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDPRIMPEER.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDCOLLPEER.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDCOMPPEER.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSDELETE.Enabled = False;
   
   PSIBLOGICAL_WRK.IB_RELLABEL.Enabled = False;
   PSIBLOGICAL_WRK.IB_RELDESCR.Enabled = False;
   PSIBLOGICAL_WRK.IB_RELRECNAME.Enabled = False;
   
   PSIBLOGICAL_WRK.IB_DESCR2.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSXMLTYPE.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSXMLNODETYPE.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSTGTPREFIX.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSTGTURI.Enabled = False;
   PSIBLOGICAL_WRK.IB_DESCRLONG.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSINCNAMESPACE.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSINCDESCR.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSREPPARENT.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSTRIMWHITE.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSFILTERBLANKS.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSINCMETA.Enabled = False;
End-Function;

Function primitive_tonumber(&type As string) Returns number
   Evaluate &type
   When "BO"
      Return &LS_CONSTANTS.PRIMITIVE_BOOLEAN;
      Break;
   When "CH"
      Return &LS_CONSTANTS.PRIMITIVE_CHAR;
      Break;
   When "ST"
      Return &LS_CONSTANTS.PRIMITIVE_STRING;
      Break;
   When "IN"
      Return &LS_CONSTANTS.PRIMITIVE_INTEGER;
      Break;
   When "DE"
      Return &LS_CONSTANTS.PRIMITIVE_DECIMAL;
      Break;
   When "DA"
      Return &LS_CONSTANTS.PRIMITIVE_DATE;
      Break;
   When "TI"
      Return &LS_CONSTANTS.PRIMITIVE_TIME;
      Break;
   When "DT"
      Return &LS_CONSTANTS.PRIMITIVE_DATETIME;
      Break;
   When "TE"
      Return &LS_CONSTANTS.PRIMITIVE_TEXT;
      Break;
   When "BI"
      Return &LS_CONSTANTS.PRIMITIVE_BINARY;
      Break;
   When-Other
      Return 0;
      Break;
   End-Evaluate;
End-Function;

Function primitive_tochar(&type As number) Returns string
   Evaluate &type
   When &LS_CONSTANTS.PRIMITIVE_BOOLEAN
      Return "BO";
      Break;
   When &LS_CONSTANTS.PRIMITIVE_CHAR
      Return "CH";
      Break;
   When &LS_CONSTANTS.PRIMITIVE_STRING
      Return "ST";
      Break;
   When &LS_CONSTANTS.PRIMITIVE_INTEGER
      Return "IN";
      Break;
   When &LS_CONSTANTS.PRIMITIVE_DECIMAL
      Return "DE";
      Break;
   When &LS_CONSTANTS.PRIMITIVE_DATE
      Return "DA";
      Break;
   When &LS_CONSTANTS.PRIMITIVE_TIME
      Return "TI";
      Break;
   When &LS_CONSTANTS.PRIMITIVE_DATETIME
      Return "DT";
      Break;
   When &LS_CONSTANTS.PRIMITIVE_TEXT
      Return "TE";
      Break;
   When &LS_CONSTANTS.PRIMITIVE_BINARY
      Return "BI";
      Break;
   When-Other
      Return "";
      Break;
   End-Evaluate;
End-Function;

Function setprimitivefields(&r As Record)
   &r.IB_LSITEMNAME.Visible = True;
   &r.IB_ISREQUIRED.Visible = True;
   &r.IB_SCHEMAUNBOUND.Visible = True;
   &r.IB_LSLENGTH.Visible = True;
   &r.IB_LSDECLENGTH.Visible = True;
   &r.IB_LSMININC.Visible = True;
   &r.IB_LSMAXINC.Visible = True;
   &r.IB_LSITEMTYPE.Visible = True;
   &r.LSEQNO.Visible = True;
   PSIBLOGICAL_WRK.IB_LSCHILDNAV.Visible = False;
   If &r.IB_ENUM_VALUE.Value = "" Then
      PSIBLOGICAL_WRK.IB_LSENUMNAV.Visible = False;
      PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Visible = True;
   Else
      PSIBLOGICAL_WRK.IB_LSENUMNAV.Visible = True;
      PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Visible = False;
   End-If;
   &r.IB_LSPRIMLABEL.Visible = True;
   &r.IB_LSPRIMCONST.Visible = False;
   &r.IB_LSCONSTOVERRIDE.Visible = False;
   &r.IB_LSDTTMFORMAT.Visible = True;
   &r.IB_LSSTR_ST.Visible = True;
   &r.IB_LSINT_ST.Visible = True;
   &r.IB_LSDAT_ST.Visible = True;
   &r.IB_LSTXT_ST.Visible = True;
   
   &r.IB_SCHEMAUNBOUND.Enabled = True;
   &r.IB_LSLENGTH.Enabled = True;
   &r.IB_LSDECLENGTH.Enabled = True;
   &r.IB_LSMININC.Enabled = True;
   &r.IB_LSMAXINC.Enabled = True;
   &r.IB_LSITEMTYPE.Enabled = True;
   &r.IB_LSPRIMLABEL.Enabled = True;
   &r.IB_LSPRIMCONST.Enabled = False;
   &r.IB_LSCONSTOVERRIDE.Enabled = False;
   &r.IB_LSDTTMFORMAT.Enabled = True;
   &r.IB_SCHEMAMIN.SetDefault();
   &r.IB_SCHEMAMAX.SetDefault();
   &r.IB_LSSCHEMA.SetDefault();
   &r.IB_LSVARIANT.SetDefault();
   
   /*** Enable Element name for Complex primitives ***/
   /***
   If &r.IB_ISCMPPRIM.Value = "1" And
         (&r.IB_LSXMLNODETYPE.Value = "2" Or
            &r.IB_LSXMLNODETYPE.Value = "3") Then
      &r.IB_LSITEMNAME.Enabled = False;
   End-If;
   ***/
   
   Evaluate &r.IB_LSITEMTYPE.Value
   When "BO"
      &r.IB_SCHEMAUNBOUND.Visible = False;
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSMININC.Visible = False;
      &r.IB_LSMAXINC.Visible = False;
      &r.IB_LSLENGTH.Visible = False;
      &r.IB_LSPRIMCONST.Visible = False;
      &r.IB_LSCONSTOVERRIDE.Visible = False;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      PSIBLOGICAL_WRK.IB_LSENUMNAV.Visible = False;
      PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Visible = False;
      Break;
   When "CH"
      &r.IB_SCHEMAUNBOUND.Visible = False;
      &r.IB_LSLENGTH.Enabled = False;
      &r.IB_LSLENGTH.Value = 1;
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSMININC.Visible = False;
      &r.IB_LSMAXINC.Visible = False;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      Break;
   When "ST"
      &r.IB_SCHEMAUNBOUND.Visible = False;
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSMININC.Visible = False;
      &r.IB_LSMAXINC.Visible = False;
      If &r.IB_LSLENGTH.Value = - 1 Then
         &r.IB_LSLENGTH.Value = 0;
      End-If;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      Break;
   When "IN"
      &r.IB_SCHEMAUNBOUND.Visible = True;
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSPRIMCONST.Visible = False;
      &r.IB_LSCONSTOVERRIDE.Visible = False;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      If &r.IB_LSLENGTH.Value = - 1 Then
         &r.IB_LSLENGTH.Visible = False;
         &r.IB_SCHEMAUNBOUND.Value = "Y";
      Else
         &r.IB_SCHEMAUNBOUND.Value = "N";
      End-If;
      Break;
   When "DE"
      &r.IB_SCHEMAUNBOUND.Visible = True;
      &r.IB_LSPRIMCONST.Visible = False;
      If &r.IB_LSLENGTH.Value = - 1 Then
         &r.IB_LSLENGTH.Visible = False;
         &r.IB_LSDECLENGTH.Visible = False;
         &r.IB_SCHEMAUNBOUND.Value = "Y";
      Else
         &r.IB_SCHEMAUNBOUND.Value = "N";
         &r.IB_LSLENGTH.Visible = True;
         &r.IB_LSDECLENGTH.Visible = True;
         If &r.IB_LSDECLENGTH.Value = - 1 Then
            &r.IB_LSDECLENGTH.Value = 0;
         End-If;
      End-If;
      &r.IB_LSCONSTOVERRIDE.Visible = False;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      Break;
   When "DA"
      &r.IB_SCHEMAUNBOUND.Visible = False;
      &r.IB_LSLENGTH.Visible = False;
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSMININC.Visible = False;
      &r.IB_LSMAXINC.Visible = False;
      &r.IB_LSPRIMCONST.Visible = False;
      &r.IB_LSCONSTOVERRIDE.Visible = False;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      Break;
   When "TI"
      &r.IB_SCHEMAUNBOUND.Visible = False;
      &r.IB_LSLENGTH.Visible = False;
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSMININC.Visible = False;
      &r.IB_LSMAXINC.Visible = False;
      &r.IB_LSPRIMCONST.Visible = False;
      &r.IB_LSCONSTOVERRIDE.Visible = False;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      Break;
   When "DT"
      &r.IB_SCHEMAUNBOUND.Visible = False;
      &r.IB_LSLENGTH.Visible = False;
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSMININC.Visible = False;
      &r.IB_LSMAXINC.Visible = False;
      &r.IB_LSPRIMCONST.Visible = False;
      &r.IB_LSCONSTOVERRIDE.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      Break;
   When "TE"
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSMININC.Visible = False;
      &r.IB_LSMAXINC.Visible = False;
      /* Setting Text to always be unbound */
      &r.IB_LSLENGTH.Value = - 1;
      &r.IB_LSLENGTH.Visible = False;
      &r.IB_SCHEMAUNBOUND.Value = "Y";
      &r.IB_SCHEMAUNBOUND.Visible = False;
      /*
      If &r.IB_LSLENGTH.Value = - 1 Then
         &r.IB_LSLENGTH.Visible = False;
         &r.IB_SCHEMAUNBOUND.Value = "Y";
      Else
         &r.IB_SCHEMAUNBOUND.Value = "N";
      End-If;
      */
      &r.IB_LSPRIMCONST.Visible = False;
      &r.IB_LSCONSTOVERRIDE.Visible = False;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = True;
      PSIBLOGICAL_WRK.IB_LSENUMNAV.Visible = False;
      PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Visible = False;
      Break;
   When "BI"
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSMININC.Visible = False;
      &r.IB_LSMAXINC.Visible = False;
      If &r.IB_LSLENGTH.Value = - 1 Then
         &r.IB_LSLENGTH.Visible = False;
         &r.IB_SCHEMAUNBOUND.Value = "Y";
      Else
         &r.IB_SCHEMAUNBOUND.Value = "N";
      End-If;
      &r.IB_LSPRIMCONST.Visible = False;
      &r.IB_LSCONSTOVERRIDE.Visible = False;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      PSIBLOGICAL_WRK.IB_LSENUMNAV.Visible = False;
      PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Visible = False;
      Break;
   When-Other
      /* No type assigned yet. */
      &r.IB_LSLENGTH.Visible = False;
      &r.IB_SCHEMAUNBOUND.Visible = False;
      &r.IB_LSDECLENGTH.Visible = False;
      &r.IB_LSMININC.Visible = False;
      &r.IB_LSMAXINC.Visible = False;
      &r.IB_LSPRIMCONST.Visible = False;
      &r.IB_LSPRIMLABEL.Visible = False;
      &r.IB_LSLENGTH.Value = 0;
      &r.IB_LSDECLENGTH.Value = 0;
      &r.IB_SCHEMAUNBOUND.Value = "N";
      &r.IB_LSCONSTOVERRIDE.Visible = False;
      &r.IB_LSDTTMFORMAT.Visible = False;
      &r.IB_LSSTR_ST.Visible = False;
      &r.IB_LSINT_ST.Visible = False;
      &r.IB_LSDAT_ST.Visible = False;
      &r.IB_LSTXT_ST.Visible = False;
      PSIBLOGICAL_WRK.IB_LSENUMNAV.Visible = False;
      PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Visible = False;
      Break;
   End-Evaluate;
End-Function;

Function setunbound(&r As Record)
   If &r.IB_LSELEMENTTYPE.Value = "PR" Then
      If &r.IB_SCHEMAUNBOUND.Value = "Y" Then
         &r.IB_LSLENGTH.Value = - 1;
         &r.IB_LSLENGTH.Visible = False;
         If &r.IB_LSITEMTYPE.Value = "DE" Then
            &r.IB_LSDECLENGTH.Visible = False;
            &r.IB_LSDECLENGTH.Value = 0;
         End-If;
      Else
         &r.IB_LSLENGTH.Visible = True;
         &r.IB_LSLENGTH.Value = 0;
         If &r.IB_LSITEMTYPE.Value = "DE" Then
            &r.IB_LSDECLENGTH.Visible = True;
         End-If;
      End-If;
   End-If;
   If &r.IB_LSELEMENTTYPE.Value = "CL" Then
      If &r.IB_SCHEMAUNBOUND.Value = "Y" Then
         &r.IB_SCHEMAMAX.Value = - 1;
         &r.IB_SCHEMAMAX.Visible = False;
      Else
         &r.IB_SCHEMAMAX.Visible = True;
         &r.IB_SCHEMAMAX.Value = 0;
      End-If;
   End-If;
End-Function;

Function setcollectionfields(&r As Record)
   &r.IB_LSITEMNAME.Visible = True;
   &r.IB_ISREQUIRED.Visible = False;
   &r.IB_SCHEMAMIN.Visible = True;
   &r.IB_SCHEMAMAX.Visible = True;
   &r.IB_SCHEMAUNBOUND.Visible = True;
   &r.LSEQNO.Visible = True;
   PSIBLOGICAL_WRK.IB_LSCHILDNAV.Visible = False;
   PSIBLOGICAL_WRK.IB_LSENUMNAV.Visible = False;
   PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Visible = False;
   
   &r.IB_LSITEMTYPE.SetDefault();
   &r.IB_LSLENGTH.SetDefault();
   &r.IB_LSDECLENGTH.SetDefault();
   &r.IB_LSSCHEMA.SetDefault();
   &r.IB_LSVARIANT.SetDefault();
   
   If &r.IB_SCHEMAUNBOUND.Value = "Y" Then
      &r.IB_SCHEMAMAX.Visible = False;
   End-If;
End-Function;

Function setcompoundfields(&r As Record)
   &r.IB_LSITEMNAME.Visible = True;
   &r.IB_ISREQUIRED.Visible = True;
   &r.IB_LSSCHEMA.Visible = True;
   &r.IB_LSVARIANT.Visible = True;
   &r.IB_PACKAGEID.Visible = True;
   &r.LSEQNO.Visible = True;
   PSIBLOGICAL_WRK.IB_LSCHILDNAV.Visible = True;
   PSIBLOGICAL_WRK.IB_LSENUMNAV.Visible = False;
   PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Visible = False;
   &r.IB_LSITEMNAME.Enabled = False;
   &r.IB_LSSCHEMA.Enabled = False;
   &r.IB_LSVARIANT.Enabled = False;
   &r.IB_PACKAGEID.Enabled = False;
   If (&r.IB_ISCMPPRIM.Value = "1") Then
      &r.IB_LSSCHEMA.Visible = False;
      &r.IB_LSVARIANT.Visible = False;
      &r.IB_PACKAGEID.Visible = False;
      PSIBLOGICAL_WRK.IB_LSCHILDNAV.Visible = False;
      PSIBLOGICAL_WRK.IB_BUILDRESULTS2.Visible = True;
   Else
      PSIBLOGICAL_WRK.IB_BUILDRESULTS2.Visible = False;
   End-If;
   If (&r.IB_AUTOGENERATED.Value = 1) Then
      &r.IB_LSSCHEMA.Visible = False;
      &r.IB_LSVARIANT.Visible = False;
      &r.IB_PACKAGEID.Visible = False;
      PSIBLOGICAL_WRK.IB_LSCHILDNAV.Visible = False;
      PSIBLOGICAL_WRK.IB_BUILDRESULTS3.Visible = True;
   Else
      PSIBLOGICAL_WRK.IB_BUILDRESULTS3.Visible = False;
   End-If;
   
   &r.IB_LSITEMTYPE.SetDefault();
   &r.IB_LSLENGTH.SetDefault();
   &r.IB_LSDECLENGTH.SetDefault();
   &r.IB_SCHEMAMIN.SetDefault();
   &r.IB_SCHEMAMAX.SetDefault();
   &r.IB_SCHEMAUNBOUND.SetDefault();
End-Function;

Function hideallfields(&r As Record)
   Local Rowset &rs;
   &rs = GetLevel0().GetRow(1).GetRowset(Scroll.PSLSDEFREF);
   &r.IB_LSITEMNAME.Visible = False;
   &r.IB_ISREQUIRED.Visible = False;
   &r.IB_SCHEMAUNBOUND.Visible = False;
   &r.IB_LSLENGTH.Visible = False;
   &r.IB_LSDECLENGTH.Visible = False;
   &r.IB_LSMININC.Visible = False;
   &r.IB_LSMAXINC.Visible = False;
   &r.IB_LSITEMTYPE.Visible = False;
   &r.IB_SCHEMAMIN.Visible = False;
   &r.IB_SCHEMAMAX.Visible = False;
   &r.IB_LSSCHEMA.Visible = False;
   &r.IB_LSVARIANT.Visible = False;
   &r.IB_PACKAGEID.Visible = False;
   &r.IB_LSPRIMLABEL.Visible = False;
   &r.IB_LSPRIMCONST.Visible = False;
   &r.IB_LSCONSTOVERRIDE.Visible = False;
   &r.IB_LSDTTMFORMAT.Visible = False;
   &r.IB_LSSTR_ST.Visible = False;
   &r.IB_LSINT_ST.Visible = False;
   &r.IB_LSDAT_ST.Visible = False;
   &r.IB_LSTXT_ST.Visible = False;
   &r.LSEQNO.Visible = False;
   PSIBLOGICAL_WRK.IB_LSCHILDNAV.Visible = False;
   PSIBLOGICAL_WRK.IB_LSENUMNAV.Visible = False;
   PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Visible = False;
   PSIBLOGICAL_WRK.IB_BUILDRESULTS2.Visible = False;
   PSIBLOGICAL_WRK.IB_BUILDRESULTS3.Visible = False;
   &rs.HideAllRows();
End-Function;

Function disableallfields(&r As Record)
   &r.IB_LSITEMNAME.Enabled = False;
   &r.IB_ISREQUIRED.Enabled = False;
   &r.IB_SCHEMAUNBOUND.Enabled = False;
   &r.IB_LSLENGTH.Enabled = False;
   &r.IB_LSDECLENGTH.Enabled = False;
   &r.IB_LSMININC.Enabled = False;
   &r.IB_LSMAXINC.Enabled = False;
   &r.IB_LSITEMTYPE.Enabled = False;
   &r.IB_SCHEMAMIN.Enabled = False;
   &r.IB_SCHEMAMAX.Enabled = False;
   &r.IB_LSSCHEMA.Enabled = False;
   &r.IB_LSVARIANT.Enabled = False;
   &r.IB_PACKAGEID.Enabled = False;
   &r.IB_LSPRIMLABEL.Enabled = False;
   &r.IB_LSPRIMCONST.Enabled = False;
   &r.IB_LSCONSTOVERRIDE.Enabled = False;
   &r.IB_LSDTTMFORMAT.Enabled = False;
   &r.IB_LSSTR_ST.Enabled = False;
   &r.IB_LSINT_ST.Enabled = False;
   &r.IB_LSDAT_ST.Enabled = False;
   &r.IB_LSTXT_ST.Enabled = False;
   &r.LSEQNO.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSENUMNAV.Enabled = True;
   PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Enabled = False;
End-Function;

Function enableallfields(&r As Record)
   &r.IB_LSITEMNAME.Enabled = True;
   &r.IB_ISREQUIRED.Enabled = True;
   &r.IB_SCHEMAUNBOUND.Enabled = True;
   &r.IB_LSLENGTH.Enabled = True;
   &r.IB_LSDECLENGTH.Enabled = True;
   &r.IB_LSMININC.Enabled = True;
   &r.IB_LSMAXINC.Enabled = True;
   &r.IB_LSITEMTYPE.Enabled = True;
   &r.IB_SCHEMAMIN.Enabled = True;
   &r.IB_SCHEMAMAX.Enabled = True;
   &r.IB_LSSCHEMA.Enabled = True;
   &r.IB_LSVARIANT.Enabled = True;
   &r.IB_PACKAGEID.Enabled = True;
   &r.IB_LSPRIMLABEL.Enabled = True;
   &r.IB_LSPRIMCONST.Enabled = False;
   &r.IB_LSCONSTOVERRIDE.Enabled = False;
   &r.LSEQNO.Enabled = True;
   PSIBLOGICAL_WRK.IB_LSCHILDNAV.Enabled = True;
   PSIBLOGICAL_WRK.IB_LSENUMNAV.Enabled = True;
   PSIBLOGICAL_WRK.IB_LSADDENUMNAV.Enabled = True;
   &r.IB_LSDTTMFORMAT.Enabled = True;
   &r.IB_LSSTR_ST.Enabled = True;
   &r.IB_LSINT_ST.Enabled = True;
   &r.IB_LSDAT_ST.Enabled = True;
   &r.IB_LSTXT_ST.Enabled = True;
End-Function;

Function copydata(&target_r As Record, &source_r As Record)
   &target_r.IB_LSITEMNAME.Value = &source_r.IB_LSITEMNAME.Value;
   &target_r.IB_ISREQUIRED.Value = &source_r.IB_ISREQUIRED.Value;
   &target_r.IB_LSELEMENTTYPE.Value = &source_r.IB_LSELEMENTTYPE.Value;
   &target_r.TREE_NODE.Value = &source_r.IB_LSITEMNAME.Value;
   &target_r.IB_LSADDCOMPCHILD.Value = &source_r.IB_LSADDCOMPCHILD.Value;
   &target_r.IB_ISCMPPRIM.Value = &source_r.IB_ISCMPPRIM.Value;
   &target_r.IB_AUTOGENERATED.Value = &source_r.IB_AUTOGENERATED.Value;
   &target_r.IB_LSMAINCOMPLEX.Value = &source_r.IB_LSMAINCOMPLEX.Value;
   &target_r.IB_LSXMLPREFIX.Value = &source_r.IB_LSXMLPREFIX.Value;
   &target_r.LSEQNO.Value = &source_r.LSEQNO.Value;
   Evaluate &source_r.IB_LSELEMENTTYPE.Value
   When "PR"
      &target_r.IB_LSITEMTYPE.Value = &source_r.IB_LSITEMTYPE.Value;
      &target_r.IB_LSLENGTH.Value = &source_r.IB_LSLENGTH.Value;
      &target_r.IB_LSDECLENGTH.Value = &source_r.IB_LSDECLENGTH.Value;
      &target_r.IB_LSMININC.Value = &source_r.IB_LSMININC.Value;
      &target_r.IB_LSMAXINC.Value = &source_r.IB_LSMAXINC.Value;
      &target_r.IB_SCHEMAUNBOUND.Value = &source_r.IB_SCHEMAUNBOUND.Value;
      &target_r.IB_LSPRIMLABEL.Value = &source_r.IB_LSPRIMLABEL.Value;
      &target_r.IB_LSPRIMCONST.Value = &source_r.IB_LSPRIMCONST.Value;
      &target_r.IB_LSXMLNODETYPE.Value = &source_r.IB_LSXMLNODETYPE.Value;
      &target_r.IB_LSCONSTOVERRIDE.Value = &source_r.IB_LSCONSTOVERRIDE.Value;
      &target_r.IB_LSDTTMFORMAT.Value = &source_r.IB_LSDTTMFORMAT.Value;
      &target_r.IB_LSSTR_ST.Value = &source_r.IB_LSSTR_ST.Value;
      &target_r.IB_LSINT_ST.Value = &source_r.IB_LSINT_ST.Value;
      &target_r.IB_LSDAT_ST.Value = &source_r.IB_LSDAT_ST.Value;
      &target_r.IB_LSTXT_ST.Value = &source_r.IB_LSTXT_ST.Value;
      &target_r.IB_ENUM_VALUE.Value = &source_r.IB_ENUM_VALUE.Value;
      &target_r.IB_ENUM_DESCR.Value = &source_r.IB_ENUM_DESCR.Value;
      Break;
   When "CL"
      &target_r.IB_SCHEMAMIN.Value = &source_r.IB_SCHEMAMIN.Value;
      &target_r.IB_SCHEMAMAX.Value = &source_r.IB_SCHEMAMAX.Value;
      &target_r.IB_SCHEMAUNBOUND.Value = &source_r.IB_SCHEMAUNBOUND.Value;
      Break;
   When "CP"
      &target_r.IB_LSSCHEMA.Value = &source_r.IB_LSSCHEMA.Value;
      &target_r.IB_LSVARIANT.Value = &source_r.IB_LSVARIANT.Value;
      &target_r.IB_PACKAGEID.Value = &source_r.IB_PACKAGEID.Value;
      Break;
   When-Other
      MessageBox(0, "", 244, 83, "Error. copydata - %1.", &source_r.IB_LSELEMENTTYPE.Value);
   End-Evaluate;
End-Function;

Function copyEnumToField(&source_r As Record)
   Local string &sValues, &sDescr;
   Local number &idx;
   Local Record &rec;
   Local Rowset &rs;
   
   &rs = GetLevel0().GetRow(1).GetRowset(Scroll.IB_ENUM_VW);
   For &idx = 1 To &rs.ActiveRowCount
      &rec = &rs.GetRow(&idx).GetRecord(1);
      If All(&rec.IB_ENUM_VALUE.Value) Then
         If (&idx <> 1) Then
            &sValues = &sValues | &ENUMDELIMETER;
            &sDescr = &sDescr | &ENUMDELIMETER;
         End-If;
         If None(&rec.IB_ENUM_VALUE.Value) Then
            &sValues = &sValues | " ";
         Else
            &sValues = &sValues | &rec.IB_ENUM_VALUE.Value;
         End-If;
         If None(&rec.IB_ENUM_DESCR.Value) Then
            &sDescr = &sDescr | " ";
         Else
            &sDescr = &sDescr | &rec.IB_ENUM_DESCR.Value;
         End-If;
      End-If;
   End-For;
   &rs.Flush();
   
   &source_r.IB_ENUM_VALUE.Value = &sValues;
   &source_r.IB_ENUM_DESCR.Value = &sDescr;
End-Function;

Function copyFieldToEnum(&source_r As Record)
   Local Record &rec;
   Local Rowset &rs;
   Local array of string &eValues, &eDescr;
   Local number &idx;
   
   &eValues = Split(&source_r.IB_ENUM_VALUE.Value, &ENUMDELIMETER);
   &eDescr = Split(&source_r.IB_ENUM_DESCR.Value, &ENUMDELIMETER);
   
   &rs = GetLevel0().GetRow(1).GetRowset(Scroll.IB_ENUM_VW);
   If (&rs.ActiveRowCount > 0) Then
      &rs.Flush();
   End-If;
   
   If (&eValues.Len > 0) Then
      For &idx = 1 To &eValues.Len;
         &rec = &rs.GetRow(&idx).GetRecord(1);
         &rec.IB_ENUM_VALUE.Value = &eValues.Get(&idx);
         &rec.IB_ENUM_DESCR.Value = &eDescr.Get(&idx);
         If (&idx <> &eValues.Len) Then
            &rs.InsertRow(&idx);
         End-If;
      End-For;
   End-If;
End-Function;

/* Create Tree Header */
Function maketreeheader(&headertext As string)
   Local Record &HDRREC, &NODEREC;
   
   &NODERS = CreateRowset(Record.PSIBLOGSCHM_NDE);
   &TREERS = CreateRowset(Record.PSIBLOGSCHM_HDR, &NODERS);
   
   &TREERS.InsertRow(1);
   
   &HDRREC = &TREERS.GetRow(2).GetRecord(1);
   &HDRREC.PAGE_NAME.Value = "IB_LOGICALSCHEMA";
   &HDRREC.PAGE_FIELD_NAME.Value = "TREECTLEVENT";
   &HDRREC.DISPLAY_LEVELS.Value = 20;
   /* Set icons */
   &HDRREC.COLLAPSED_IMAGE.Value = "PT_ADD";
   &HDRREC.EXPANDED_IMAGE.Value = "PT_DELETE";
   &HDRREC.END_NODE_IMAGE.Value = "PTDOC_PRIM";
   &HDRREC.END_NODE_MSGSET.Value = 244;
   &HDRREC.END_NODE_MSGNUM.Value = 142;
   
   &NODERS = &TREERS.GetRow(2).GetRowset(1);
   &NODERS.InsertRow(1);
   &NODEREC = &NODERS.GetRow(2).GetRecord(1);
   /* Insert the Root */
   &NODEREC.LEAF_FLAG.Value = "N";
   &NODEREC.TREE_NODE.Value = "";
   &NODEREC.DESCR.Value = &headertext;
   &NODEREC.RANGE_FROM.Value = "";
   &NODEREC.RANGE_TO.Value = "";
   &NODEREC.DYNAMIC_FLAG.Value = "N";
   &NODEREC.ACTIVE_FLAG.Value = "Y";
   &NODEREC.DISPLAY_OPTION.Value = "D";
   &NODEREC.STYLECLASSNAME.Value = "PABOLDTEXT";
   &NODEREC.PARENT_FLAG.Value = "Y";
   &NODEREC.TREE_LEVEL_NUM.Value = 1;
   &NODEREC.LEVEL_OFFSET.Value = 0;
   &NODEREC.EXPANDED_FLAG.Value = "Y";
End-Function;

/* Inserts a single row into the current tree. Initially &level should be 2 and irow should be 2.*/
Function insertnode(&type As string, &irow As number, &level As number, &rec As Record)
   Local Record &INSREC;
   
   &NODERS.InsertRow(&irow);
   &INSREC = &NODERS.GetRow(&irow + 1).GetRecord(1);
   
   &INSREC.DYNAMIC_FLAG.Value = "N";
   &INSREC.DISPLAY_OPTION.Value = "B";
   &INSREC.LEAF_FLAG.Value = "N";
   &INSREC.TREE_LEVEL_NUM.Value = &level;
   &INSREC.LEVEL_OFFSET.Value = 0;
   &INSREC.STYLECLASSNAME.Value = "PSHYPERLINK";
   &INSREC.ACTIVE_FLAG.Value = "Y";
   &INSREC.IB_LSADDCOMPCHILD.Value = &rec.IB_LSADDCOMPCHILD.Value;
   &INSREC.IB_ISCMPPRIM.Value = &rec.IB_ISCMPPRIM.Value;
   &INSREC.IB_AUTOGENERATED.Value = &rec.IB_AUTOGENERATED.Value;
   &INSREC.IB_LSMAINCOMPLEX.Value = &rec.IB_LSMAINCOMPLEX.Value;
   
   /* Use TREE_NODE for node value.  DESCR can be used if you want an initial dash.  Or can use both
to get an effect such as ABC - DEF */
   &INSREC.TREE_NODE.Value = &rec.IB_LSITEMNAME.Value;
   rem &INSREC.DESCR_IMAGE.Value = "PT_EXPORT_DATA_ICN" Change Icon;
   rem &INSREC.STYLECLASSNAME.Value = "PSHYPERLINKYELLOWBKGRD" Change to Yellow Background;
   &INSREC.IB_LSITEMNAME.Value = &rec.IB_LSITEMNAME.Value;
   &INSREC.IB_LSXMLTAG.Value = &rec.IB_LSXMLTAG.Value;
   &INSREC.IB_ISREQUIRED.Value = &rec.IB_ISREQUIRED.Value;
   &INSREC.IB_LSELEMENTTYPE.Value = &rec.IB_LSELEMENTTYPE.Value;
   &INSREC.LSEQNO.Value = &rec.LSEQNO.Value;
   &INSREC.IB_LSXMLPREFIX.Value = &rec.IB_LSXMLPREFIX.Value;
   &INSREC.IB_LSJSONTAG.Value = &rec.IB_LSJSONTAG.Value;
   &INSREC.IB_LSJSONEXP.Value = &rec.IB_LSJSONEXP.Value;
   If %Component = "IB_LOGICALSCHEMA" And
         All(PSIBLOGICAL_WRK.IB_RELRECNAME) Then
      &INSREC.IB_RECNAME.Value = PSIBLOGICAL_WRK.IB_RELRECNAME;
   End-If;
   If &type = "PR" Then
      &INSREC.PARENT_FLAG.Value = "N";
      &INSREC.IB_SCHEMAUNBOUND.Value = &rec.IB_SCHEMAUNBOUND.Value;
      &INSREC.IB_LSLENGTH.Value = &rec.IB_LSLENGTH.Value;
      &INSREC.IB_LSDECLENGTH.Value = &rec.IB_LSDECLENGTH.Value;
      &INSREC.IB_LSMININC.Value = &rec.IB_LSMININC.Value;
      &INSREC.IB_LSMAXINC.Value = &rec.IB_LSMAXINC.Value;
      &INSREC.IB_LSITEMTYPE.Value = &rec.IB_LSITEMTYPE.Value;
      &INSREC.IB_SCHEMAMIN.SetDefault();
      &INSREC.IB_SCHEMAMAX.SetDefault();
      &INSREC.IB_LSSCHEMA.SetDefault();
      &INSREC.IB_LSVARIANT.SetDefault();
      &INSREC.IB_LSPRIMLABEL.Value = &rec.IB_LSPRIMLABEL.Value;
      &INSREC.IB_LSPRIMCONST.Value = &rec.IB_LSPRIMCONST.Value;
      &INSREC.IB_LSPRIMWHITESP.Value = &rec.IB_LSPRIMWHITESP.Value;
      If All(&rec.IB_LSXMLNODETYPE.Value) Then
         &INSREC.IB_LSXMLNODETYPE.Value = &rec.IB_LSXMLNODETYPE.Value;
      End-If;
      &INSREC.IB_LSCONSTOVERRIDE.Value = &rec.IB_LSCONSTOVERRIDE.Value;
      &INSREC.IB_LSDTTMFORMAT.Value = &rec.IB_LSDTTMFORMAT.Value;
      &INSREC.IB_LSSTR_ST.Value = &rec.IB_LSSTR_ST.Value;
      &INSREC.IB_LSINT_ST.Value = &rec.IB_LSINT_ST.Value;
      &INSREC.IB_LSDAT_ST.Value = &rec.IB_LSDAT_ST.Value;
      &INSREC.IB_LSTXT_ST.Value = &rec.IB_LSTXT_ST.Value;
      &INSREC.IB_ENUM_VALUE.Value = &rec.IB_ENUM_VALUE.Value;
      &INSREC.IB_ENUM_DESCR.Value = &rec.IB_ENUM_DESCR.Value;
   End-If;
   If &type = "CL" Then
      &INSREC.DESCR_IMAGE.Value = "PTDOC_COLL";
      &INSREC.DESCR_MSGSET.Value = 244;
      &INSREC.DESCR_MSGNUM.Value = 143;
      &INSREC.PARENT_FLAG.Value = "Y";
      &INSREC.IB_SCHEMAUNBOUND.Value = &rec.IB_SCHEMAUNBOUND.Value;
      &INSREC.IB_LSLENGTH.SetDefault();
      &INSREC.IB_LSDECLENGTH.SetDefault();
      &INSREC.IB_LSMININC.SetDefault();
      &INSREC.IB_LSMAXINC.SetDefault();
      &INSREC.IB_LSITEMTYPE.SetDefault();
      &INSREC.IB_SCHEMAMIN.Value = &rec.IB_SCHEMAMIN.Value;
      &INSREC.IB_SCHEMAMAX.Value = &rec.IB_SCHEMAMAX.Value;
      &INSREC.IB_LSSCHEMA.SetDefault();
      &INSREC.IB_LSVARIANT.SetDefault();
      &INSREC.EXPANDED_FLAG.Value = "Y";
      &INSREC.IB_LSPRIMLABEL.SetDefault();
      &INSREC.IB_LSPRIMCONST.SetDefault();
   End-If;
   If &type = "CP" Then
      &INSREC.DESCR_IMAGE.Value = "PTDOC_COMP";
      &INSREC.DESCR_MSGSET.Value = 244;
      &INSREC.DESCR_MSGNUM.Value = 144;
      &INSREC.PARENT_FLAG.Value = "Y";
      &INSREC.STYLECLASSNAME.Value = "PSHYPERLINKYELLOWBKGRD";
      &INSREC.IB_SCHEMAUNBOUND.SetDefault();
      &INSREC.IB_LSLENGTH.SetDefault();
      &INSREC.IB_LSDECLENGTH.SetDefault();
      &INSREC.IB_LSMININC.SetDefault();
      &INSREC.IB_LSMAXINC.SetDefault();
      &INSREC.IB_LSITEMTYPE.SetDefault();
      &INSREC.IB_SCHEMAMIN.SetDefault();
      &INSREC.IB_SCHEMAMAX.SetDefault();
      &INSREC.IB_LSSCHEMA.Value = &rec.IB_LSSCHEMA.Value;
      &INSREC.IB_LSVARIANT.Value = &rec.IB_LSVARIANT.Value;
      &INSREC.IB_PACKAGEID.Value = &rec.IB_PACKAGEID.Value;
      &INSREC.IB_LSXMLPREFIX.Value = &rec.IB_LSXMLPREFIX.Value;
      &INSREC.EXPANDED_FLAG.Value = "Y";
      &INSREC.IB_LSPRIMLABEL.SetDefault();
      &INSREC.IB_LSPRIMCONST.SetDefault();
   End-If;
End-Function;

Function getrowlevel(&crow As number) Returns number
   Local Row &rw;
   &rw = &NODERS.GetRow(&crow);
   Return &rw.GetRecord(1).TREE_LEVEL_NUM.Value;
End-Function;

Function getrowcomplextype(&crow As number) Returns boolean
   Local Row &rw;
   &rw = &NODERS.GetRow(&crow);
   If &rw.GetRecord(1).IB_ISCMPPRIM.Value = "1" Then
      Return True;
   Else
      Return False;
   End-If;
End-Function;

Function clearhighlight(&rs As Rowset)
   Local number &x;
   Local Record &prec;
   
   For &x = 1 To &rs.ActiveRowCount
      &prec = &rs.GetRow(&x).GetRecord(1);
      If &prec.IB_LSELEMENTTYPE.Value = "CP" Then
         &prec.STYLECLASSNAME.Value = "PSHYPERLINKYELLOWBKGRD";
      Else
         If &prec.TREE_LEVEL_NUM.Value = 1 Then
            &prec.STYLECLASSNAME.Value = "PABOLDTEXT";
         Else
            &prec.STYLECLASSNAME.Value = "";
         End-If;
      End-If;
   End-For;
End-Function;

Function setitemhighlight(&r As Record)
   &r.STYLECLASSNAME.Value = "PSTREENODESELECTED";
End-Function;

Function clearitemhighlight(&r As Record)
   If &r.TREE_LEVEL_NUM.Value = 1 Then
      &r.STYLECLASSNAME.Value = "PABOLDTEXT";
   Else
      If &r.IB_LSELEMENTTYPE.Value = "CP" Then
         &r.STYLECLASSNAME.Value = "PSHYPERLINKYELLOWBKGRD";
      Else
         &r.STYLECLASSNAME.Value = "";
      End-If;
   End-If;
End-Function;

Function YNToBool(&s As string) Returns boolean
   If &s = "Y" Then
      Return True;
   Else
      Return False;
   End-If;
End-Function;

Function NumToBool(&n As number) Returns boolean
   If &n = 0 Then
      Return False;
   Else
      Return True;
   End-If;
End-Function;

Function BoolToNum(&n As boolean) Returns number
   If &n Then
      Return 1;
   Else
      Return 0;
   End-If;
End-Function;

Function NumToChar(&n As string) Returns string
   If &n = "1" Then
      Return "Y";
   Else
      Return "N";
   End-If;
End-Function;

Function BooltoYN(&b As boolean) Returns string
   If &b Then
      Return "Y";
   Else
      Return "N";
   End-If;
End-Function;

Function ChartoBool(&b As string) Returns boolean
   If &b = "0" Or
         None(&b) Then
      Return False;
   Else
      Return True;
   End-If;
End-Function;

Function findlastrow(&nrs As Rowset, &st As number) Returns number
   Local number &y, &clevel, &level;
   &clevel = &nrs.GetRow(&st).GetRecord(1).TREE_LEVEL_NUM.Value;
   For &y = &st + 1 To &nrs.ActiveRowCount
      &level = &nrs.GetRow(&y).GetRecord(1).TREE_LEVEL_NUM.Value;
      If &level <= &clevel Then
         Return &y - 1;
      End-If;
   End-For;
   Return &nrs.ActiveRowCount;
End-Function;

Function findlastprimitiverow(&nrs As Rowset, &st As number, &ischild As boolean) Returns number
   Local number &y, &clevel, &level;
   Local Record &rec;
   Local boolean &prifound = False;
   &clevel = &nrs.GetRow(&st).GetRecord(1).TREE_LEVEL_NUM.Value;
   If (&clevel = 2) And
         (&ischild Or
            (&nrs.GetRow(&st).GetRecord(1).IB_LSELEMENTTYPE.Value = "PR") Or
            (&nrs.GetRow(&st).GetRecord(1).IB_ISCMPPRIM.Value = "1")) Then
      /* Is child of a level 2 element like a collection or add to primitive group */
      For &y = &st + 1 To &nrs.ActiveRowCount
         &level = &nrs.GetRow(&y).GetRecord(1).TREE_LEVEL_NUM.Value;
         If &level <= &clevel Then
            Return &y - 1;
         End-If;
      End-For;
   Else
      /* Look for the last occurence of a primitive */
      For &y = 1 To &nrs.ActiveRowCount
         &rec = &nrs.GetRow(&y).GetRecord(1);
         &level = &rec.TREE_LEVEL_NUM.Value;
         If (&rec.TREE_LEVEL_NUM.Value = 2) Then
            If (&rec.IB_LSELEMENTTYPE.Value = "PR") Then
               &prifound = True;
            Else
               If &prifound And
                     ((&rec.IB_LSELEMENTTYPE.Value <> "PR") And
                        (&rec.IB_ISCMPPRIM.Value <> "1")) Then
                  Return &y - 1;
               End-If;
            End-If;
         End-If;
      End-For;
   End-If;
   Return &nrs.ActiveRowCount;
End-Function;

Function saveprimitiverow(&lsdefn As any, &rec As Record, &seq As number)
   Local PT_SCHEMA:LogicalSchemaPrimitive &prim;
   Local number &nType, &nLength, &nFractionalDigits, &nFormatIndex, &idx;
   Local string &sName, &sMinInc, &sMaxInc;
   Local boolean &bRequired, &bConstantOverride;
   Local string &sLabel, &sConstant;
   Local array of string &eValues, &eDescr;
   
   &sName = &rec.IB_LSITEMNAME.Value;
   &bRequired = YNToBool(&rec.IB_ISREQUIRED.Value);
   
   &nType = primitive_tonumber(&rec.IB_LSITEMTYPE.Value);
   &nLength = &rec.IB_LSLENGTH.Value;
   &nFractionalDigits = &rec.IB_LSDECLENGTH.Value;
   &sMinInc = &rec.IB_LSMININC.Value;
   &sMaxInc = &rec.IB_LSMAXINC.Value;
   &sLabel = &rec.IB_LSPRIMLABEL.Value;
   &sConstant = &rec.IB_LSPRIMCONST.Value;
   &bConstantOverride = YNToBool(&rec.IB_LSCONSTOVERRIDE.Value);
   &nFormatIndex = Value(&rec.IB_LSDTTMFORMAT.Value);
   If &rec.IB_LSITEMTYPE.Value = "ST" Then
      &nFormatIndex = Value(&rec.IB_LSSTR_ST.Value);
   End-If;
   If &rec.IB_LSITEMTYPE.Value = "IN" Then
      &nFormatIndex = Value(&rec.IB_LSINT_ST.Value);
   End-If;
   If &rec.IB_LSITEMTYPE.Value = "DA" Then
      &nFormatIndex = Value(&rec.IB_LSDAT_ST.Value);
   End-If;
   If &rec.IB_LSITEMTYPE.Value = "TE" Then
      &nFormatIndex = Value(&rec.IB_LSTXT_ST.Value);
   End-If;
   
   &prim = &lsdefn.appendPrimitive(&sName, &bRequired, &seq, &sLabel, &nType, &nLength, &nFractionalDigits, &nFormatIndex, &sMaxInc, &sMinInc);
   
   /** Save the enums for the primitive **/
   &eValues = Split(&rec.IB_ENUM_VALUE.Value, &ENUMDELIMETER);
   &eDescr = Split(&rec.IB_ENUM_DESCR.Value, &ENUMDELIMETER);
   
   If (&eValues.Len > 0) Then
      For &idx = 1 To &eValues.Len;
         &prim.AppendEnum(&eValues.Get(&idx), &eDescr.Get(&idx));
      End-For;
   End-If;
End-Function;

Function savecollectionrow(&nrs As Rowset, &lsdefn As any, &rec As Record, &seq As number, &trow As number, &wrec As Record, &xml As string, &relname As string, &json As string, &html As string)
   Local string &name;
   Local boolean &isrequired;
   Local number &min, &max;
   Local PT_SCHEMA:LogicalSchemaCollection &coll;
   
   &name = &rec.IB_LSITEMNAME.Value;
   &isrequired = YNToBool(&rec.IB_ISREQUIRED.Value);
   &min = &rec.IB_SCHEMAMIN.Value;
   If &max = - 1 Then
      &max = %Document_OccursUnbounded;
   Else
      &max = &rec.IB_SCHEMAMAX.Value;
   End-If;
   rem   MessageBox(0, "", 0, 0, "Appending collection:" | &name | " seq:" | &seq | " to:" | &lsdefn.label | " max:" | &max);
   &coll = &lsdefn.AppendCollection(&name, &isrequired, &seq, &min, &max);
   savecollection(&nrs, &coll, &rec, 1, &trow, &wrec, &xml, &relname, &json, &html);
End-Function;

Function savecompoundrow(&lsdefn As any, &rec As Record, &seq As number, &trow As number)
   Local PT_SCHEMA:LogicalSchemaCompound &comp;
   Local string &schema, &variant, &package;
   Local string &name;
   Local boolean &isrequired;
   
   &name = &rec.IB_LSITEMNAME.Value;
   &isrequired = YNToBool(&rec.IB_ISREQUIRED.Value);
   &schema = &rec.IB_LSSCHEMA.Value;
   &variant = &rec.IB_LSVARIANT.Value;
   &package = &rec.IB_PACKAGEID.Value;
   rem   MessageBox(0, "", 0, 0, "Appending Compound:" | &name | " " | &schema | " " | &variant);
   &comp = &lsdefn.AppendCompound(&name, &isrequired, &seq, &package, &schema, &variant);
End-Function;

Function savemessageversion(&msgname As string, &apmsgver As string, &malias As string, &objowner As string, &package As string, &schema As string, &variant As string) Returns boolean
   Local number &vcount, &vernum, &j;
   Local PT_INTEGRATION:MessageDefinition &MsgDefn;
   Local PT_INTEGRATION:MessageVersion &MsgVers;
   
   /* temporary */
   rem   Return True;
   
   &MsgDefn = create PT_INTEGRATION:MessageDefinition(&msgname);
   &MsgDefn.LanguageCd = %Language;
   If All(&objowner) Then
      &MsgDefn.ObjectOwnerId = &objowner;
   Else
      &MsgDefn.ObjectOwnerId = "PPT";
   End-If;
   &MsgDefn.MessageAliasName = &malias;
   &MsgDefn.Descr = "Autogenerated Message";
   
   &vcount = &MsgDefn.GetVersionCount();
   &vernum = 0;
   For &j = 1 To &vcount
      &MsgVers = &MsgDefn.GetVersion(&j);
      If &MsgVers.VersionName = &apmsgver Then
         &vernum = &j;
      End-If;
   End-For;
   /* If it was an existing version, delete it. */
   If &vernum > 0 Then
      If Not (&MsgDefn.DeleteVersion(&vernum)) Then
         MessageBox(0, "", 158, 2192, "Error deleting previous version %1.  New version not saved.", &apmsgver);
         Return False;
      End-If;
   End-If;
   
   &MsgVers = &MsgDefn.AppendVersion(&apmsgver);
   &MsgVers.MessageSchema = False;
   &MsgVers.PartMessage = False;
   &MsgVers.PartDefaultIndicator = False;
   &MsgVers.ExcludeDescInSchema = False;
   &MsgVers.MessageUse = 0;
   &MsgVers.IncNamespace = 0;
   &MsgVers.MessageType = &MsgVers.MSGTYPE_DOCUMENT;
   &MsgVers.PackageName = &package;
   &MsgVers.DocumentName = &schema;
   &MsgVers.VariantName = &variant;
   
   REM  MessageBox(0, "", 0, 0, "Type:" | &MsgVers.MSGTYPE_LOGICAL_SCHEMA);
   
   Return &MsgDefn.Save();
End-Function;

/* Given a field name, query tools table and map to an equivalent schema format. Field name must be valid. 
Return internal type, field length, decimal length.  Appropriate adjustments have been made to length. */
Function converttoschematype(&fname As string, &internaltype As string, &dbfieldlength As number, &dbfielddecimals As number) Returns number
   Local string &dbfield;
   Local number &dbfieldtype;
   
   &internaltype = "";
   &dbfieldlength = 0;
   &dbfielddecimals = 0;
   
   If None(&fname) Then
      Return - 1;
   End-If;
   SQLExec("select fieldname, fieldtype, length, decimalpos from psdbfield where fieldname = :1", &fname, &dbfield, &dbfieldtype, &dbfieldlength, &dbfielddecimals);
   If None(&dbfield) Then
      Return - 2;
   End-If;
   Evaluate &dbfieldtype
   When 0
      &internaltype = "ST";
      Break;
   When 1
      &internaltype = "TE";
      Break;
   When 2
      If &dbfielddecimals = 0 Then
         &internaltype = "IN";
      Else
         &internaltype = "DE";
         &dbfieldlength = &dbfieldlength - 1;
      End-If;
      Break;
   When 3
      If &dbfielddecimals = 0 Then
         &internaltype = "IN";
         &dbfieldlength = &dbfieldlength - 1;
      Else
         &internaltype = "DE";
         &dbfieldlength = &dbfieldlength - 2;
      End-If;
      Break;
   When 4
      &internaltype = "DA";
      Break;
   When 5
      &internaltype = "TI";
      Break;
   When 6
      &internaltype = "DT";
      Break;
   When-Other
      /* Ignore */
      Return 99;
   End-Evaluate;
   Return 0;
End-Function;

Function validaterecordsandfieldswithdetails(&rs As Rowset, &bShowMessages As boolean, &sRecord As string, &sField As string) Returns number
   Local number &x;
   Local Record &rec, &nrec;
   Local string &recname = "";
   Local array of string &arrphyfldnames = CreateArrayRept("", 0);
   Local SQL &msql;
   Local string &fldname;
   
   For &x = 1 To &rs.ActiveRowCount
      &rec = &rs.GetRow(&x).GetRecord(1);
      If All(&rec.IB_RECNAME.Value) And
            All(&rec.IB_RECFLDNAME.Value) Then
         If &recname <> &rec.IB_RECNAME.Value Then
            /* Get the Field names associated with the record */
            &recname = &rec.IB_RECNAME.Value;
            &arrphyfldnames = CreateArrayRept("", 0);
            &msql = CreateSQL("select fieldname from psrecfielddb where recname=:1", &recname);
            While &msql.Fetch(&fldname)
               &arrphyfldnames.Push(&fldname);
            End-While;
         End-If;
         If &arrphyfldnames.Find(&rec.IB_RECFLDNAME.Value) = 0 Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 239, "Error. DB field %1 not found in record %2.", &rec.IB_RECFLDNAME.Value, &recname);
            End-If;
            &sRecord = &recname;
            &sField = &rec.IB_RECFLDNAME.Value;
            Return - 605;
         End-If;
      End-If;
   End-For;
   Return 0;
End-Function;

Function validaterecordsandfields(&rs As Rowset, &bShowMessages As boolean) Returns number
   Local string &sRecord, &sField;
   Return validaterecordsandfieldswithdetails(&rs, &bShowMessages, &sRecord, &sField);
End-Function;

Function validaterelationalschema(&rs As Rowset, &bShowMessages As boolean) Returns number
   Local number &x;
   Local Record &rec, &nrec;
   Local array of string &arrfldnames = CreateArrayRept("", 0);
   Local array of string &arrfldtypes = CreateArrayRept("", 0);
   Local array of string &arrelmnames = CreateArrayRept("", 0);
   Local string &recname, &internaltype;
   Local number &idx2, &dbfieldlength, &dbfielddecimals, &result;
   Local SQL &msql;
   Local string &fldname;
   
   For &x = 1 To &rs.ActiveRowCount
      &rec = &rs.GetRow(&x).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = 2 Then
         /* Check if field is already mapped to another document element */
         If All(&rec.IB_RECNAME.Value) And
               All(&rec.IB_RECFLDNAME.Value) Then
            If &arrfldnames.Find(&rec.IB_RECFLDNAME.Value) > 0 Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 223, "Error. Field name %1 is already used in another document element.", &rec.IB_RECFLDNAME.Value);
               End-If;
               Return - 601;
            Else
               /*** Add Fields that are used in the Document - No Duplicates ***/
               &arrelmnames.Push(&rec.IB_LSITEMNAME.Value);
               &arrfldnames.Push(&rec.IB_RECFLDNAME.Value);
               &arrfldtypes.Push(&rec.IB_LSITEMTYPE.Value);
               &recname = &rec.IB_RECNAME.Value;
            End-If;
         End-If;
         /* For relational, record and field must either be both blank (no relational) or both filled in. */
         Evaluate &rec.IB_LSELEMENTTYPE.Value
         When "PR"
            If (All(&rec.IB_RECNAME.Value) And
                  None(&rec.IB_RECFLDNAME.Value)) Or
                  (None(&rec.IB_RECNAME.Value) And
                     All(&rec.IB_RECFLDNAME.Value)) Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 84, "Warning. Missing record name or field name in element %1.", &rec.IB_LSITEMNAME.Value);
               End-If;
            End-If;
            Break;
         When "CL"
            If &x < &rs.ActiveRowCount Then
               &nrec = &rs.GetRow(&x + 1).GetRecord(1);
               If &nrec.IB_LSELEMENTTYPE.Value = "PR" Then
                  If (All(&nrec.IB_RECNAME.Value) And
                        None(&nrec.IB_RECFLDNAME.Value)) Or
                        (None(&nrec.IB_RECNAME.Value) And
                           All(&nrec.IB_RECFLDNAME.Value)) Then
                     If &bShowMessages Then
                        MessageBox(0, "", 244, 266, "Error.  Primitive in a Collection.");
                     End-If;
                     Return - 602;
                  End-If;
               End-If;
               If &nrec.IB_LSELEMENTTYPE.Value = "CP" Then
                  If (%Page = "IB_LOGICALSCHEMA") Then
                     If All(PSIBLOGICAL_WRK.IB_RELRECNAME) And
                           All(&nrec.IB_PACKAGEID.Value) And
                           All(&nrec.IB_LSSCHEMA.Value) And
                           All(&nrec.IB_LSVARIANT.Value) Then
                        If Not ispackagerelational(&nrec.IB_PACKAGEID.Value, &nrec.IB_LSSCHEMA.Value, &nrec.IB_LSVARIANT.Value) Then
                           If &bShowMessages Then
                              MessageBox(0, "", 244, 225, "Error. Document %1.%2.%3 does not have a relational definition.", &nrec.IB_PACKAGEID.Value, &nrec.IB_LSSCHEMA.Value, &nrec.IB_LSVARIANT.Value);
                           End-If;
                           Return - 602;
                        End-If;
                     End-If;
                  End-If;
               End-If;
            End-If;
            Break;
         When "CP"
            If (%Page = "IB_LOGICALSCHEMA") Then
               If All(PSIBLOGICAL_WRK.IB_RELRECNAME) And
                     All(&rec.IB_PACKAGEID.Value) And
                     All(&rec.IB_LSSCHEMA.Value) And
                     All(&rec.IB_LSVARIANT.Value) Then
                  If Not ispackagerelational(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value) Then
                     If &bShowMessages Then
                        MessageBox(0, "", 244, 225, "Error. Document %1.%2.%3 does not have a relational definition.", &rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value);
                     End-If;
                     Return - 602;
                  End-If;
               End-If;
            End-If;
            If &x < &rs.ActiveRowCount Then
               &nrec = &rs.GetRow(&x + 1).GetRecord(1);
               If &nrec.IB_LSELEMENTTYPE.Value = "PR" Then
                  If (All(&nrec.IB_RECNAME.Value) And
                        None(&nrec.IB_RECFLDNAME.Value)) Or
                        (None(&nrec.IB_RECNAME.Value) And
                           All(&nrec.IB_RECFLDNAME.Value)) Then
                     If &bShowMessages Then
                        MessageBox(0, "", 244, 84, "Warning. Missing record name or field name in element %1.", &nrec.IB_LSITEMNAME.Value);
                     End-If;
                  End-If;
               End-If;
            End-If;
            Break;
         End-Evaluate;
      End-If;
   End-For;
   
   /*** Only one record can be associated with a Document ***/
   If All(&recname) And
         (&arrfldnames.Len > 0) Then
      /* Check for document element type to field mappings */
      For &idx2 = 1 To &arrfldtypes.Len
         &internaltype = "";
         &dbfieldlength = 0;
         &dbfielddecimals = 0;
         &result = converttoschematype(&arrfldnames [&idx2], &internaltype, &dbfieldlength, &dbfielddecimals);
         If (&result = 0) And
               (&internaltype <> &arrfldtypes [&idx2]) Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 226, "Error. Invalid datatype mapping for element %1 with db field %2.", &arrelmnames [&idx2], &arrfldnames [&idx2]);
            End-If;
            Return - 603;
         End-If;
         If (&result > 0) Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 227, "Error. Undefined db field %1.", &arrfldnames [&idx2]);
            End-If;
            Return - 604;
         End-If;
      End-For;
      /* Also show warning if some key fields in the record is not mapped to the document */
      &msql = CreateSQL("select fieldname from pskeydefn where recname=:1", &recname);
      While &msql.Fetch(&fldname)
         If (&arrfldnames.Find(&fldname) = 0) Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 224, "Warning. Key field %1 in record %2 is not used in this document.", &fldname, &recname);
            End-If;
         End-If;
      End-While;
   End-If;
   
   Return 0;
End-Function;

Function validatelogicalschema(&rs As Rowset, &bShowMessages As boolean) Returns number;
   Local number &n, &gret;
   Local Record &nrec, &nextrec;
   Local number &primfound = 0;
   Local number &primcolfound = 0;
   
   If &rs.ActiveRowCount < 3 Then
      Return 0;
   End-If;
   For &n = 3 To &rs.ActiveRowCount
      &nrec = &rs.GetRow(&n).GetRecord(1);
      If None(&nrec.IB_LSADDCOMPCHILD.Value) Then
         Evaluate &nrec.IB_LSELEMENTTYPE.Value
         When "PR"
            If None(&nrec.IB_LSITEMNAME.Value) Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 85, "Error. Missing primitive element name.");
               End-If;
               Return - 401;
            End-If;
            If None(&nrec.IB_LSITEMTYPE.Value) Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 86, "Error. Missing type for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
               End-If;
               Return - 402;
            End-If;
            If &nrec.IB_LSITEMTYPE.Value = "IN" Then
               If &nrec.IB_LSLENGTH.Value = 0 Then
                  If &bShowMessages Then
                     MessageBox(0, "", 244, 158, "Error. Invalid length for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                  End-If;
                  Return - 411;
               End-If;
               /*** Maximum length for Integer is 31, cap it if its too big ***/
               If &nrec.IB_LSLENGTH.Value > 31 Then
                  &nrec.IB_LSLENGTH.Value = 31;
               End-If;
               If All(&nrec.IB_LSMININC.Value) Or
                     All(&nrec.IB_LSMAXINC.Value) Then
                  If All(&nrec.IB_LSMININC.Value) And
                        All(&nrec.IB_LSMAXINC.Value) Then
                     If Not IsNumber(&nrec.IB_LSMININC.Value) Or
                           Not IsNumber(&nrec.IB_LSMAXINC.Value) Then
                        If &bShowMessages Then
                           MessageBox(0, "", 244, 261, "Error. Invalid Min/Max Inclusive value for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                        End-If;
                        Return - 414;
                     End-If;
                     If Value(&nrec.IB_LSMININC.Value) > Value(&nrec.IB_LSMAXINC.Value) Then
                        If &bShowMessages Then
                           MessageBox(0, "", 244, 262, "Error. Min Inclusive should be less than Max Inclusive value for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                        End-If;
                        Return - 415;
                     End-If;
                  End-If;
                  If All(&nrec.IB_LSMININC.Value) And
                        Not IsNumber(&nrec.IB_LSMININC.Value) Then
                     If &bShowMessages Then
                        MessageBox(0, "", 244, 261, "Error. Invalid Min/Max Inclusive value for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                     End-If;
                     Return - 414;
                  End-If;
                  If All(&nrec.IB_LSMAXINC.Value) And
                        Not IsNumber(&nrec.IB_LSMAXINC.Value) Then
                     If &bShowMessages Then
                        MessageBox(0, "", 244, 261, "Error. Invalid Min/Max Inclusive value for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                     End-If;
                     Return - 414;
                  End-If;
               End-If;
            End-If;
            If &nrec.IB_LSITEMTYPE.Value = "DE" Then
               If &nrec.IB_LSLENGTH.Value = 0 Then
                  If &bShowMessages Then
                     MessageBox(0, "", 244, 158, "Error. Invalid length for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                  End-If;
                  Return - 411;
               End-If;
               /*** Maximum length for Decimal is 31, cap it if its too big ***/
               If &nrec.IB_LSDECLENGTH.Value > 30 Then
                  &nrec.IB_LSDECLENGTH.Value = 30;
               End-If;
               If &nrec.IB_LSLENGTH.Value > 31 Then
                  &nrec.IB_LSLENGTH.Value = 31;
               End-If;
               If &nrec.IB_LSDECLENGTH.Value > 0 Then
                  If &nrec.IB_LSLENGTH.Value < &nrec.IB_LSDECLENGTH.Value Then
                     If &bShowMessages Then
                        MessageBox(0, "", 244, 159, "Error. Length for primitive element %1 must be greater than the decimal length", &nrec.IB_LSITEMNAME.Value);
                     End-If;
                     Return - 412;
                  End-If;
               End-If;
               If All(&nrec.IB_LSMININC.Value) Or
                     All(&nrec.IB_LSMAXINC.Value) Then
                  If All(&nrec.IB_LSMININC.Value) And
                        All(&nrec.IB_LSMAXINC.Value) Then
                     If Not IsNumber(&nrec.IB_LSMININC.Value) Or
                           Not IsNumber(&nrec.IB_LSMAXINC.Value) Then
                        If &bShowMessages Then
                           MessageBox(0, "", 244, 261, "Error. Invalid Min/Max Inclusive value for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                        End-If;
                        Return - 414;
                     End-If;
                     If Value(&nrec.IB_LSMININC.Value) > Value(&nrec.IB_LSMAXINC.Value) Then
                        If &bShowMessages Then
                           MessageBox(0, "", 244, 262, "Error. Min Inclusive should be less than Max Inclusive value for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                        End-If;
                        Return - 415;
                     End-If;
                  End-If;
                  If All(&nrec.IB_LSMININC.Value) And
                        Not IsNumber(&nrec.IB_LSMININC.Value) Then
                     If &bShowMessages Then
                        MessageBox(0, "", 244, 261, "Error. Invalid Min/Max Inclusive value for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                     End-If;
                     Return - 414;
                  End-If;
                  If All(&nrec.IB_LSMAXINC.Value) And
                        Not IsNumber(&nrec.IB_LSMAXINC.Value) Then
                     If &bShowMessages Then
                        MessageBox(0, "", 244, 261, "Error. Invalid Min/Max Inclusive value for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                     End-If;
                     Return - 414;
                  End-If;
               End-If;
            End-If;
            If &nrec.IB_LSITEMTYPE.Value = "TE" Then
               If &nrec.IB_LSLENGTH.Value = 0 Then
                  If &bShowMessages Then
                     MessageBox(0, "", 244, 158, "Error. Invalid length for primitive element %1.", &nrec.IB_LSITEMNAME.Value);
                  End-If;
                  Return - 411;
               End-If;
            End-If;
            /* Check to ensure primitives are grouped */
            If (&nrec.TREE_LEVEL_NUM.Value = 2) Then
               If (&primfound > 1) Then
                  If &bShowMessages Then
                     MessageBox(0, "", 244, 228, "Error. Primitives on the main documment need to be grouped together.");
                  End-If;
                  Return - 413;
               Else
                  &primfound = 1;
               End-If;
               /*** If a primitive collection is found then return error ***/
               If (&primcolfound = 1) Then
                  If &bShowMessages Then
                     MessageBox(0, "", 244, 230, "Error. Cannot define primitive after collection with a primitive.");
                  End-If;
                  Return - 414;
               End-If;
            End-If;
            Break;
         When "CL"
            If None(&nrec.IB_LSITEMNAME.Value) Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 87, "Error. Missing collection element name.");
               End-If;
               Return - 403;
            End-If;
            /* Collections must have a child. */
            If &n = &rs.ActiveRowCount Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 88, "Error. Found a collection with no child.");
               End-If;
               Return - 404;
            End-If;
            &nextrec = &rs.GetRow(&n + 1).GetRecord(1);
            If &nrec.TREE_LEVEL_NUM.Value >= &nextrec.TREE_LEVEL_NUM.Value Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 88, "Error. Found a collection with no child.");
               End-If;
               Return - 405;
            End-If;
            /*** Check if Collection has a primitive child - if it has set flag ***/
            If (&nrec.TREE_LEVEL_NUM.Value = 2) And
                  (&nextrec.IB_LSELEMENTTYPE.Value = "PR") Then
               &primcolfound = 1;
            End-If;
            If &nrec.IB_SCHEMAMIN.Value < 0 Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 156, "Error. Collection %1 has a minimum occurs value of less than 0.", &nrec.IB_LSITEMNAME.Value);
               End-If;
               Return - 409;
            End-If;
            If &nrec.IB_SCHEMAMAX.Value <> - 1 Then
               If &nrec.IB_SCHEMAMIN.Value > &nrec.IB_SCHEMAMAX.Value Then
                  If &bShowMessages Then
                     MessageBox(0, "", 244, 157, "Error. Collection %1 has a minimum occurs value greater than the maximum occurs value.", &nrec.IB_LSITEMNAME.Value);
                  End-If;
                  Return - 410;
               End-If;
            End-If;
            /* Check to ensure primitives are grouped */
            If (&nrec.TREE_LEVEL_NUM.Value = 2) And
                  (&primfound > 0) Then
               &primfound = &primfound + 1;
            End-If;
            Break;
         When "CP"
            If None(&nrec.IB_LSITEMNAME.Value) Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 89, "Error. Missing compound element name.");
               End-If;
               Return - 406;
            End-If;
            If None(&nrec.IB_LSSCHEMA.Value) Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 90, "Error. Missing referenced schema name for compound element %1.", &nrec.IB_LSITEMNAME.Value);
               End-If;
               Return - 407;
            End-If;
            If None(&nrec.IB_LSVARIANT.Value) Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 91, "Error. Missing referenced schema version for compound element %1.", &nrec.IB_LSITEMNAME.Value);
               End-If;
               Return - 408;
            End-If;
            /* Check complex primitives. */
            If &nrec.IB_ISCMPPRIM.Value = "1" Then
               &gret = validatecomplexcompound(&rs, &n, &bShowMessages);
               If &gret < 0 Then
                  If &bShowMessages Then
                     MessageBox(0, "", 244, 92, "Error. Invalid complex primitive %1.  Error %2.", &nrec.IB_LSITEMNAME.Value, &gret);
                  End-If;
                  Return &gret;
               End-If;
               /*** Complex Primitives are considered ordinary primitives ***/
               /***
               If (&nrec.TREE_LEVEL_NUM.Value = 2) Then
                  If (&primfound > 1) Then
                     If &bShowMessages Then
                        MessageBox(0, "", 244, 228, "Error. Primitives on the main documment need to be grouped together.");
                     End-If;
                     Return - 413;
                  Else
                     &primfound = 1;
                  End-If;
               End-If;
               ***/
            Else
               /* Check to ensure primitives are grouped */
               If (&nrec.TREE_LEVEL_NUM.Value = 2) And
                     (&primfound > 0) Then
                  &primfound = &primfound + 1;
               End-If;
            End-If;
            /* Clear the Primitive Collection flag if compound is found before a primitive */
            If (&nrec.TREE_LEVEL_NUM.Value = 2) And
                  (&primcolfound > 0) Then
               &primcolfound = 0;
            End-If;
            Break;
         When-Other
            Error MsgGetText(244, 93, "Error. Function validatelogicalschema invalid element type %1.", &nrec.IB_LSELEMENTTYPE.Value);
            Exit;
         End-Evaluate;
      End-If;
   End-For;
   Return 0;
End-Function;

Function duplicatedependency(&dep As PT_SCHEMA:DependencyDefn, &package As string, &schema As string, &variant As string) Returns boolean
   Local number &d;
   Local PT_SCHEMA:DependencyDocument &depdoc;
   
   For &d = 1 To &dep.GetExtDocumentCount();
      &depdoc = &dep.GetExtDocument(&d);
      If &depdoc.ExtPackage = &package And
            &depdoc.ExtLogicalSchema = &schema And
            &depdoc.ExtVariant = &variant Then
         Return True;
      End-If;
   End-For;
   Return False;
End-Function;

Function savedependencies(&nrs As Rowset, &package As string, &schema As string, &variant As string) Returns boolean
   Local number &r, &s, &t, &depcount;
   Local Record &rec;
   Local boolean &bret;
   Local PT_SCHEMA:DependencyDefn &lsdep;
   Local PT_SCHEMA:DependencyDocument &lsdepdoc;
   
   /* Create Dependency.  Delete old values. */
   
   &lsdep = create PT_SCHEMA:DependencyDefn(&package, &schema, &variant);
   REM   &depcount = &lsdep.GetExtDocumentCount();
   
   /*   For &t = 1 To &depcount
      &bret = &lsdep.DeleteExtDocument(&t);
   End-For;
*/
   If Not &lsdep.IsNew Then
      &bret = &lsdep.Delete();
      &lsdep = create PT_SCHEMA:DependencyDefn(&package, &schema, &variant);
      &lsdep.LanguageCd = %Language;
   End-If;
   
   &depcount = 0;
   For &r = 1 To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&r).GetRecord(1);
      Evaluate &rec.IB_LSELEMENTTYPE.Value
      When "CP"
         If None(&rec.IB_PACKAGEID.Value) Or
               None(&rec.IB_LSSCHEMA.Value) Or
               None(&rec.IB_LSVARIANT.Value) Then
            MessageBox(0, "", 244, 94, "Error in document structure.  Missing component key.");
            Return False;
         End-If;
         If Not duplicatedependency(&lsdep, &rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value) Then
            &lsdepdoc = &lsdep.AppendExtDocument(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value);
            &depcount = &depcount + 1;
            &lsdepdoc.Dataseqno = &depcount;
         End-If;
         Break;
      End-Evaluate;
   End-For;
   If &depcount > 0 Then
      &bret = &lsdep.Save();
   End-If;
   Return True;
End-Function;

/* Deletes complex primitives that have been removed from the structure during document editing. */
Function deletecomplex()
   Local Rowset &rs;
   Local number &x;
   Local Record &rec;
   Local boolean &bret;
   
   Local PT_SCHEMA:LogicalSchemaDefinition &lsdefinition3;
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition3;
   
   If %Component <> "IB_LOGICALSCHEMA" Then
      Return;
   End-If;
   &rs = GetLevel0().GetRow(1).GetRowset(Scroll.PSIBDOCLIST_VW);
   For &x = 1 To &rs.ActiveRowCount
      &rec = &rs.GetRow(&x).GetRecord(1);
      If All(&rec.IB_EXTSCHEMANAME.Value) Then
         &xmldefinition3 = create PT_SCHEMA:XmlSchemaDefinition(&rec.IB_EXTPACKAGEID.Value, &rec.IB_EXTSCHEMANAME.Value, &rec.IB_EXTVARIANTNAME.Value, &XMLNAME);
         If Not &xmldefinition3.IsNew Then
            &bret = &xmldefinition3.Delete();
         End-If;
         &lsdefinition3 = create PT_SCHEMA:LogicalSchemaDefinition(&rec.IB_EXTPACKAGEID.Value, &rec.IB_EXTSCHEMANAME.Value, &rec.IB_EXTVARIANTNAME.Value);
         If Not &lsdefinition3.IsNew Then
            &bret = &lsdefinition3.Delete();
         End-If;
      End-If;
   End-For;
   &rs.Flush();
End-Function;

/* Returns the namespace for a particular XML document */
Function getdocxmlnamespace(&package As string, &schema As string, &variant As string, &xmlname As string) Returns string
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition;
   Local PT_SCHEMA:XmlSchemaNamespace &targetnamespace;
   Local string &retval = "";
   
   &xmldefinition = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &xmlname);
   
   &targetnamespace = &xmldefinition.GetTargetNamespace();
   If &targetnamespace <> Null Then
      &retval = &targetnamespace.Uri;
   End-If;
   
   Return &retval;
End-Function;

Function savelogicalschema(&schema As string, &variant As string, &package As string, &nrs As Rowset, &wrec As Record, &xml As string, &relname As string, &json As string, &html As string, &bShowMessages As boolean) Returns number
   Local number &r, &idx, &i;
   Local Record &rec, &trec1, &trec2;
   Local number &seqno;
   Local boolean &ret;
   Local PT_SCHEMA:LogicalSchemaDefinition &lsdefinition;
   Local PT_SCHEMA:LogicalSchemaRelatedLang &lsrellang;
   Local array of string &arrdlang;
   Local array of string &arrdvalue;
   Local Record &trec;
   
   &seqno = 1;
   &lsdefinition = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
   
   If Not &lsdefinition.IsNew Then
      rem &lsdefinition.IsUpdate = True;
      &ret = &lsdefinition.Delete();
      &lsdefinition = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
      rem &lsdefinition.IsUpdate = True;
   End-If;
   
   &lsdefinition.Label = &wrec.DESCR.Value;
   &lsdefinition.ObjectOwnerId = &wrec.OBJECTOWNERID.Value;
   &lsdefinition.IsPrivate = YNToBool(&wrec.IB_ISPRIVATE.Value);
   &lsdefinition.IsImported = YNToBool(&wrec.IB_ISIMPORTED.Value);
   &lsdefinition.ComplexPrimitive = ChartoBool(&wrec.IB_ISCMPPRIM.Value);
   &lsdefinition.AutoGenerated = &wrec.IB_AUTOGENERATED.Value;
   &lsdefinition.IsLastSeqCollPrim = False;
   
   /*** Set the Description with the Base Language ***/
   &lsdefinition.Description = &wrec.DESCRLONG.Value;
   &lsdefinition.LanguageCode = %Language_Base;
   
   &lsdefinition.CIIndex = &wrec.IB_CI_INDEX.Value;
   rem MessageBox(0, "", 0, 0, "CI index: %1.%2.%3.%4", &package, &schema, &variant, &lsdefinition.CIIndex);
   
   <**   
   /*** Manually Implement the Related Languages for Documents ****/
   &arrdlang = Split(&wrec.IB_DESCLANG_LIST.Value, &ENUMDELIMETER);
   &arrdvalu = Split(&wrec.IB_DESCVALU_LIST.Value, &ENUMDELIMETER);
   
   If None(&wrec.DESCRLONG.Value) Then
      &wrec.DESCRLONG.Value = " ";
   End-If;
   
   /*** Logic to handle manual related language support ***/
   If %Language_Base = %Language_User Then
      &lsdefinition.Description = &wrec.DESCRLONG.Value;
      &lsdefinition.LanguageCode = %Language_Base;
   Else
      &idx = &arrdlang.Find(%Language_User);
      If (&idx > 0) Then
         &arrdvalu [&idx] = &wrec.DESCRLONG.Value;
      Else
         &arrdlang.Push(%Language_User);
         &arrdvalu.Push(&wrec.DESCRLONG.Value);
      End-If;
      &idx = &arrdlang.Find(%Language_Base);
      If (&idx > 0) Then
         &lsdefinition.Description = &arrdvalu [&idx];
         &lsdefinition.LanguageCode = %Language_Base;
      Else
         &lsdefinition.Description = &wrec.DESCRLONG.Value;
         &lsdefinition.LanguageCode = %Language_Base;
      End-If;
   End-If;
   
   For &i = 1 To &arrdlang.Len
      If &arrdlang [&i] <> %Language_Base And
            All(&arrdlang [&i]) Then
         &lsrellang = &lsdefinition.AppendRelatedLang(&arrdlang [&i], &arrdvalu [&i]);
      End-If;
   End-For;
**>
   If &wrec.IB_ISCONTAINER.Value = "1" Then
      &lsdefinition.IsContainer = True;
   Else
      &lsdefinition.IsContainer = False;
   End-If;
   
   rem MessageBox(0, "", 0, 0, "Ls Definition: IsContainer=%1", &lsdefinition.IsContainer);
   
   If isAllAttributes(&nrs) Then
      &lsdefinition.IsAllAttributes = True;
   Else
      &lsdefinition.IsAllAttributes = False;
   End-If;
   
   For &r = 1 To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&r).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = 2 Then
         Evaluate &rec.IB_LSELEMENTTYPE.Value
         When "PR"
            saveprimitiverow(&lsdefinition, &rec, &seqno);
            &seqno = &seqno + 1;
            Break;
         When "CL"
            savecollectionrow(&nrs, &lsdefinition, &rec, &seqno, &r, &wrec, &xml, &relname, &json, &html);
            &seqno = &seqno + 1;
            Break;
         When "CP"
            savecompoundrow(&lsdefinition, &rec, &seqno, &r);
            If &rec.IB_ISCMPPRIM.Value = "1" Then
               If Not savecomplexcompound(&nrs, &r, &wrec, &xml, &relname, &json, &html) Then
                  If &bShowMessages Then
                     MessageBox(0, "", 244, 80, "Error saving complex compound %1.", &rec.IB_LSITEMNAME.Value);
                  End-If;
                  Return - 304;
               End-If;
            End-If;
            &seqno = &seqno + 1;
            Break;
         When-Other
            If &bShowMessages Then
               MessageBox(0, "", 244, 95, "Error. Function savelogicalschema processing invalid element type %1.", &rec.IB_LSELEMENTTYPE.Value);
            End-If;
            Return - 301;
         End-Evaluate;
      End-If;
   End-For;
   
   /*** Add check if we have a collection primitive at the end of the tree ***/
   If (&nrs.ActiveRowCount >= 2) Then
      &trec1 = &nrs.GetRow(&nrs.ActiveRowCount - 1).GetRecord(1);
      &trec2 = &nrs.GetRow(&nrs.ActiveRowCount).GetRecord(1);
      If (&trec1.TREE_LEVEL_NUM.Value = 2) And
            (&trec2.TREE_LEVEL_NUM.Value = 3) And
            (&trec1.IB_LSELEMENTTYPE.Value = "CL") And
            (&trec2.IB_LSELEMENTTYPE.Value = "PR") Then
         &lsdefinition.IsLastSeqCollPrim = True;
      End-If;
   End-If;
   
   /*** Add check if we have a collection with complex primitive at the end of the tree ***/
   &r = &nrs.ActiveRowCount;
   &trec = &nrs.GetRow(&r).GetRecord(1);
   While (&trec.IB_ISCMPPRIM.Value = "1") And
         (&trec.IB_LSELEMENTTYPE.Value = "PR") And
         (&r > 1)
      &r = &r - 1;
      &trec = &nrs.GetRow(&r).GetRecord(1);
   End-While;
   If (&r > 1) And
         (&trec.IB_LSELEMENTTYPE.Value = "CP") And
         (&trec.IB_ISCMPPRIM.Value = "1") Then
      &r = &r - 1;
      &trec = &nrs.GetRow(&r).GetRecord(1);
      If (&r > 1) And
            (&trec.IB_LSELEMENTTYPE.Value = "CL") Then
         &lsdefinition.IsLastSeqCollPrim = True;
      End-If;
   End-If;
   
   /* Writes to C:\temp file LogicalSchemaDefn[name]-[vers].log*/
   REM &lsdefinition.Debug();
   
   If &lsdefinition.Save() Then
      &ret = savedependencies(&nrs, &package, &schema, &variant);
      If &lsdefinition.IsContainer Then
         If All(&wrec.MSGNAME.Value) And
               All(&wrec.APMSGVER.Value) Then
            /*** Check for target namespace when its null ***/
            If None(PSIBLOGICAL_WRK.IB_LSTGTURI) Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 247, "Cannot save message when document doesn't have a defined namespace.");
               End-If;
               Return - 302;
            End-If;
            /* Write out the document keys into the appropriate message object. */
            If savemessageversion(&wrec.MSGNAME.Value, &wrec.APMSGVER.Value, &wrec.XMLALIAS.Value, &wrec.OBJECTOWNERID.Value, &package, &schema, &variant) Then
               Return 0;
            Else
               If &bShowMessages Then
                  MessageBox(0, "", 244, 128, "Error saving message %1 version %2.", &wrec.MSGNAME.Value, &wrec.APMSGVER.Value);
               End-If;
               Return - 302;
            End-If;
         End-If;
      Else
         deletecomplex();
         Return 0;
      End-If;
   Else
      If &bShowMessages Then
         MessageBox(0, "", 244, 14, "Error saving document.");
      End-If;
      Return - 303;
   End-If;
End-Function;

Function decodetrim(&tr As string) Returns number
   Evaluate &tr
   When "0"
      Return &LS_CONSTANTS.TRIMWHITESPACE_FALSE;
      Break;
   When "1"
      Return &LS_CONSTANTS.TRIMWHITESPACE_TRUE;
      Break;
   When-Other
      Return &LS_CONSTANTS.TRIMWHITESPACE_FALSE;
      Exit;
   End-Evaluate;
End-Function;

Function encodetrim(&tr As number) Returns string
   Evaluate &tr
   When &LS_CONSTANTS.TRIMWHITESPACE_FALSE
      Return "0";
      Break;
   When &LS_CONSTANTS.TRIMWHITESPACE_TRUE
      Return "1";
      Break;
   When-Other
      Error MsgGetText(244, 96, "Error. Function %1 invalid type %2.", "encodetrim", &tr);
      Exit;
   End-Evaluate;
End-Function;

Function decodexmlnodetype(&tr As string) Returns number
   Evaluate &tr
   When "0"
      Return &LS_CONSTANTS.XMLNODETYPE_NONE;
      Break;
   When "1"
      Return &LS_CONSTANTS.XMLNODETYPE_ATTRIBUTE;
      Break;
   When "2"
      Return &LS_CONSTANTS.XMLNODETYPE_ELEMENT;
      Break;
   When "3"
      Return &LS_CONSTANTS.XMLNODETYPE_ELEMENT_WITH_CDATA;
      Break;
   When-Other
      Error MsgGetText(244, 96, "Error. Function %1 invalid type %2.", "decodexmlnodetype", &tr);
      Exit;
   End-Evaluate;
End-Function;

Function encodexmlnodetype(&tr As number) Returns string
   Evaluate &tr
   When &LS_CONSTANTS.XMLNODETYPE_NONE
      Return "0";
      Break;
   When &LS_CONSTANTS.XMLNODETYPE_ATTRIBUTE
      Return "1";
      Break;
   When &LS_CONSTANTS.XMLNODETYPE_ELEMENT
      Return "2";
      Break;
   When &LS_CONSTANTS.XMLNODETYPE_ELEMENT_WITH_CDATA
      Return "3";
      Break;
   When-Other
      Error MsgGetText(244, 96, "Error. Function %1 invalid type %2.", "encodexmlnodetype", &tr);
      Exit;
   End-Evaluate;
End-Function;

Function decodexmltype(&tr As string) Returns number
   Evaluate &tr
   When "0"
      Return &LS_CONSTANTS.XMLTYPE_STANDARD;
      Break;
   When "1"
      Return &LS_CONSTANTS.XMLTYPE_SOAPRPC;
      Break;
   When-Other
      Error MsgGetText(244, 96, "Error. Function %1 invalid type %2.", "decodexmltype", &tr);
      Exit;
   End-Evaluate;
End-Function;

Function encodexmltype(&tr As number) Returns string
   Evaluate &tr
   When &LS_CONSTANTS.XMLTYPE_STANDARD
      Return "0";
      Break;
   When &LS_CONSTANTS.XMLTYPE_SOAPRPC
      Return "1";
      Break;
   When-Other
      Error MsgGetText(244, 96, "Error. Function %1 invalid type %2.", "encodexmltype", &tr);
      Exit;
   End-Evaluate;
End-Function;

Function setxmlprimitive(&xml As any, &rec As Record)
   Local string &tag, &prefix;
   Local number &nodetype, &trimspace;
   
   &tag = &rec.IB_LSXMLTAG.Value;
   If None(&tag) Then
      &tag = &rec.IB_LSITEMNAME.Value;
   End-If;
   &prefix = &rec.IB_LSXMLPREFIX.Value;
   &nodetype = decodexmlnodetype(&rec.IB_LSXMLNODETYPE.Value);
   &trimspace = decodetrim(&rec.IB_LSPRIMWHITESP.Value);
   rem   MessageBox(0, "", 0, 0, "Saving Primitive %1.  Prefix %2. Type %3. Input value %4", &tag, &prefix, &nodetype, &rec.IB_LSXMLNODETYPE.Value);
   &xml.AppendPrimitive(&prefix, &tag, &trimspace, &nodetype);
End-Function;

Function setxmlcompound(&xml As any, &rec As Record, &xmlname As string)
   Local string &tag, &prefix;
   Local string &childschema, &childvariant, &childpackage;
   
   &tag = &rec.IB_LSXMLTAG.Value;
   If None(&tag) Then
      &tag = &rec.IB_LSITEMNAME.Value;
   End-If;
   &prefix = &rec.IB_LSXMLPREFIX.Value;
   &childschema = &rec.IB_LSSCHEMA.Value;
   &childvariant = &rec.IB_LSVARIANT.Value;
   &childpackage = &rec.IB_PACKAGEID.Value;
   &xml.AppendCompound(&prefix, &tag, &childpackage, &childschema, &childvariant, &xmlname);
End-Function;

Function setxmlcollection(&nrs As Rowset, &xml As any, &rec As Record, &crow As number, &xmlname As string)
   Local string &tag, &prefix;
   Local PT_SCHEMA:XmlSchemaCollection &coll;
   
   &tag = &rec.IB_LSXMLTAG.Value;
   If None(&tag) Then
      &tag = &PSCOLXMLTAG;
   End-If;
   &prefix = &rec.IB_LSXMLPREFIX.Value;
   
   &coll = &xml.AppendCollection(&prefix, &tag);
   savexmlcollection(&nrs, &coll, &rec, &crow, &xmlname);
End-Function;

Function savexmlschema(&schema As string, &variant As string, &xmlname As string, &package As string, &nrs As Rowset, &nmrs As Rowset, &wrec As Record, &bShowMessages As boolean) Returns number
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition;
   Local number &t;
   Local Rowset &rs;
   Local Record &rec;
   Local boolean &ret;
   Local string &tschema;
   
   &xmldefinition = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &xmlname);
   If Not &xmldefinition.IsNew Then
      rem &xmldefinition.IsUpdate = True;
      &ret = &xmldefinition.Delete();
      &xmldefinition = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &xmlname);
      rem &xmldefinition.IsUpdate = True;
   End-If;
   
   /*** Show Informational Message Box when Document Name is > 30 ***/
   /*** and IB_DESCR2.Value is equal to first 30 chars of the document ***/
   If Len(&schema) > 30 Then
      &tschema = Substring(&schema, 1, 30);
      If &tschema = &wrec.IB_DESCR2.Value Then
         MessageBox(0, "", 158, 5000, "Document Name is longer than 30 characters.  Using Document Name as the XML Root tag.");
      End-If;
   End-If;
   
   /* Save header fields. */
   &xmldefinition.Label = &wrec.IB_DESCR2.Value;
   &xmldefinition.Description = &wrec.IB_DESCRLONG.Value;
   &xmldefinition.DefaultPrimitiveNodeType = decodexmlnodetype(&wrec.IB_LSXMLNODETYPE.Value);
   &xmldefinition.XmlType = decodexmltype(&wrec.IB_LSXMLTYPE.Value);
   If All(&wrec.IB_LSTGTPREFIX.Value) Or
         All(&wrec.IB_LSTGTURI.Value) Then
      &xmldefinition.AppendTargetNamespace(&wrec.IB_LSTGTPREFIX.Value, &wrec.IB_LSTGTURI.Value);
   End-If;
   &xmldefinition.NoTargetNamespace = YNToBool(&wrec.IB_NONAMESPACE.Value);
   &xmldefinition.FilterBlankElements = YNToBool(&wrec.IB_LSFILTERBLANKS.Value);
   &xmldefinition.IncludeCollectionTags = YNToBool(&wrec.IB_LSREPPARENT.Value);
   &xmldefinition.IncludeDescriptionsAsComments = YNToBool(&wrec.IB_LSINCDESCR.Value);
   &xmldefinition.IncludeMetadata = YNToBool(&wrec.IB_LSINCMETA.Value);
   &xmldefinition.IncludeNamespaceImports = YNToBool(&wrec.IB_LSINCNAMESPACE.Value);
   &xmldefinition.TrimWhitespace = YNToBool(&wrec.IB_LSTRIMWHITE.Value);
   &xmldefinition.AttributeCount = &wrec.IB_LSATTRIBCOUNT.Value;
   
   For &t = 1 To &nmrs.ActiveRowCount
      &rec = &nmrs.GetRow(&t).GetRecord(Record.PSLSIMPNMSPC_VW);
      If All(&rec.IB_LSIMPURI.Value) Then
         &xmldefinition.AppendImportedNamespaces(&rec.IB_LSIMPPREFIX.Value, &rec.IB_LSIMPURI.Value);
      End-If;
   End-For;
   
   /* Save tree data. */
   For &t = 1 To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&t).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = 2 Then
         Evaluate &rec.IB_LSELEMENTTYPE.Value
         When "PR"
            setxmlprimitive(&xmldefinition, &rec);
            Break;
         When "CL"
            setxmlcollection(&nrs, &xmldefinition, &rec, &t, &xmlname);
            Break;
         When "CP"
            setxmlcompound(&xmldefinition, &rec, &xmlname);
            Break;
         When-Other
            If &bShowMessages Then
               MessageBox(0, "", 244, 96, "Error. Function %1 invalid type %2.", "savexmlschema", &rec.IB_LSELEMENTTYPE.Value);
            End-If;
            Return - 602;
         End-Evaluate;
      End-If;
   End-For;
   If &xmldefinition.Save() Then
      /* Save schema upon successful xml document change. */
      &ret = %IntBroker.InsertDocSchema(CreateKey(&package, &schema, &variant));
      
      Return 0;
   Else
      If &bShowMessages Then
         MessageBox(0, "", 244, 11, "Error saving xml document.  Package %1 schema %2 version %3", &package, &schema, &variant);
      End-If;
      Return - 601;
   End-If;
End-Function;

Function setbuttons(&r As number)
   Local Record &rec, &nrowrec;
   
   PSIBLOGICAL_WRK.IB_LSADDPRIMCHILD.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDCOLLCHILD.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDCOMPCHILD.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDPRIMPEER.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDCOLLPEER.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSADDCOMPPEER.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSMOVEITEM.Enabled = False;
   PSIBLOGICAL_WRK.IB_LSDELETE.Enabled = False;
   
   If &CMP_READONLY Then
      Return;
   End-If;
   
   If &r < 2 Then
      Return;
   End-If;
   If &r = 2 Then
      PSIBLOGICAL_WRK.IB_LSADDPRIMCHILD.Enabled = True;
      /*** Check for the platform -- disable compound and collection creation for AIX ***/
      rem If Not (%IntBroker.IsAIX()) Then;
      PSIBLOGICAL_WRK.IB_LSADDCOLLCHILD.Enabled = True;
      PSIBLOGICAL_WRK.IB_LSADDCOMPCHILD.Enabled = True;
      rem End-If;
      PSIBLOGICAL_WRK.IB_LSADDPRIMPEER.Enabled = False;
      PSIBLOGICAL_WRK.IB_LSADDCOLLPEER.Enabled = False;
      PSIBLOGICAL_WRK.IB_LSADDCOMPPEER.Enabled = False;
      PSIBLOGICAL_WRK.IB_LSMOVEITEM.Enabled = False;
      Return;
   End-If;
   &rec = &NODERS.GetRow(&r).GetRecord(1);
   
   Evaluate &rec.IB_LSELEMENTTYPE.Value
   When "PR"
      If &rec.TREE_LEVEL_NUM.Value < 3 Then
         PSIBLOGICAL_WRK.IB_LSADDPRIMPEER.Enabled = True;
         /*** Check for the platform -- disable compound and collection creation for AIX ***/
         rem If Not (%IntBroker.IsAIX()) Then;
         PSIBLOGICAL_WRK.IB_LSADDCOLLPEER.Enabled = True;
         PSIBLOGICAL_WRK.IB_LSADDCOMPPEER.Enabled = True;
         rem End-If;
      End-If;
      /* Inside a reference.  Could be a real reference or a complex primitive reference. */
      If All(&rec.IB_LSADDCOMPCHILD.Value) Then
         If &rec.IB_ISCMPPRIM.Value = "1" And
               &rec.IB_LSXMLNODETYPE.Value = "1" Then
            PSIBLOGICAL_WRK.IB_LSDELETE.Enabled = True;
         End-If;
      Else
         PSIBLOGICAL_WRK.IB_LSDELETE.Enabled = True;
         PSIBLOGICAL_WRK.IB_LSMOVEITEM.Enabled = True;
      End-If;
      Return;
      Break;
   When "CL"
      PSIBLOGICAL_WRK.IB_LSDELETE.Enabled = True;
      PSIBLOGICAL_WRK.IB_LSMOVEITEM.Enabled = True;
      If &rec.TREE_LEVEL_NUM.Value < 3 Then
         PSIBLOGICAL_WRK.IB_LSADDPRIMPEER.Enabled = True;
         /*** Check for the platform -- disable compound and collection creation for AIX ***/
         rem If Not (%IntBroker.IsAIX()) Then;
         PSIBLOGICAL_WRK.IB_LSADDCOLLPEER.Enabled = True;
         PSIBLOGICAL_WRK.IB_LSADDCOMPPEER.Enabled = True;
         rem End-If;
      End-If;
      
      /* If the collection aready has a child, disable all buttons. Also, we do not allow collections within collections. */
      If &r < &NODERS.ActiveRowCount Then
         &nrowrec = &NODERS.GetRow(&r + 1).GetRecord(1);
         If &nrowrec.TREE_LEVEL_NUM.Value = &rec.TREE_LEVEL_NUM.Value + 1 Then
            PSIBLOGICAL_WRK.IB_LSADDPRIMCHILD.Enabled = False;
            PSIBLOGICAL_WRK.IB_LSADDCOLLCHILD.Enabled = False;
            PSIBLOGICAL_WRK.IB_LSADDCOMPCHILD.Enabled = False;
         Else
            /* No child.  Check Level. */
            If &rec.TREE_LEVEL_NUM.Value > 2 Then
               PSIBLOGICAL_WRK.IB_LSADDPRIMCHILD.Enabled = True;
               PSIBLOGICAL_WRK.IB_LSADDCOMPCHILD.Enabled = True;
            Else
               PSIBLOGICAL_WRK.IB_LSADDPRIMCHILD.Enabled = True;
               PSIBLOGICAL_WRK.IB_LSADDCOMPCHILD.Enabled = True;
            End-If;
         End-If;
      Else
         /* Clicked on the Last Row */
         PSIBLOGICAL_WRK.IB_LSADDPRIMCHILD.Enabled = True;
         PSIBLOGICAL_WRK.IB_LSADDCOMPCHILD.Enabled = True;
      End-If;
      Return;
      Break;
   When "CP"
      PSIBLOGICAL_WRK.IB_LSDELETE.Enabled = True;
      PSIBLOGICAL_WRK.IB_LSMOVEITEM.Enabled = True;
      If &rec.TREE_LEVEL_NUM.Value < 3 Then
         PSIBLOGICAL_WRK.IB_LSADDPRIMPEER.Enabled = True;
         /*** Check for the platform -- disable compound and collection creation for AIX ***/
         rem If Not (%IntBroker.IsAIX()) Then;
         PSIBLOGICAL_WRK.IB_LSADDCOLLPEER.Enabled = True;
         PSIBLOGICAL_WRK.IB_LSADDCOMPPEER.Enabled = True;
         rem End-If;
      End-If;
      If &rec.TREE_LEVEL_NUM.Value = 2 And
            &rec.IB_ISCMPPRIM.Value = "1" Then
         PSIBLOGICAL_WRK.IB_LSADDPRIMCHILD.Enabled = True;
      End-If;
      If &rec.TREE_LEVEL_NUM.Value = 3 And
            &rec.IB_ISCMPPRIM.Value = "1" Then
         PSIBLOGICAL_WRK.IB_LSADDPRIMCHILD.Enabled = True;
      End-If;
      /*** Added check for DELETE and MOVE buttons for Compound elements ***/
      If All(&rec.IB_LSADDCOMPCHILD.Value) And
            &rec.TREE_LEVEL_NUM.Value <= 3 Then
         If &rec.IB_ISCMPPRIM.Value <> "1" Then
            PSIBLOGICAL_WRK.IB_LSDELETE.Enabled = False;
            PSIBLOGICAL_WRK.IB_LSMOVEITEM.Enabled = False;
         End-If;
      End-If;
      Return;
      Break;
   When-Other
      Error MsgGetText(244, 96, "Error. Function %1 invalid type %2.", "setbuttons", &rec.IB_LSELEMENTTYPE.Value);
      Exit;
   End-Evaluate;
End-Function;

/* For a logical schema to exist there must be a row in PSLSDEFN. */
Function logicalexists(&package As string, &schema As string, &variant As string) Returns boolean
   Local string &exists;
   
   SQLExec("select 'x' from pslsdefn where ib_packageid = :1 and ib_schemaname = :2 and ib_variantname = :3", &package, &schema, &variant, &exists);
   If None(&exists) Then
      Return False;
   End-If;
   Return True;
End-Function;

/* For a relational schema to exist there must be a row in PSLSDEFN. */
Function relationalexists(&package As string, &schema As string, &variant As string, &relname As string) Returns boolean
   Local string &exists;
   
   SQLExec("select 'x' from psphysschdefn where ib_packageid = :1 and ib_schemaname = :2 and ib_variantname = :3 and ib_physschemaname = :4", &package, &schema, &variant, &relname, &exists);
   If None(&exists) Then
      Return False;
   End-If;
   Return True;
End-Function;

Function GetDocumentRowset(&package As string, &schema As string, &variant As string, &relname As string) Returns Rowset
   Local Document &DOC;
   Local Rowset &drs;
   
   &DOC = CreateDocument(&package, &schema, &variant);
   &drs = &DOC.GetRowset();
   Return &drs;
End-Function;

Function insrefrow(&nrs As Rowset, &package As string, &schema As string, &variant As string)
   Local Record &nrec;
   Local string &refpackage, &refschema, &refvariant;
   
   If All(&nrs.GetRow(1).GetRecord(1).IB_PACKAGEID3.Value) Then
      &nrs.InsertRow(&nrs.ActiveRowCount);
   End-If;
   &nrec = &nrs.GetRow(&nrs.ActiveRowCount).GetRecord(1);
   &nrec.IB_PACKAGEID3.Value = &package;
   &nrec.IB_SCHEMANAME.Value = &schema;
   &nrec.IB_VARIANTNAME.Value = &variant;
End-Function;

Function getdependencies(&package As string, &schema As string, &variant As string, &nrs As Rowset) Returns boolean
   Local SQL &MYSQL;
   Local string &refpackage, &refschema, &refvariant;
   Local number &cnt;
   
   &nrs.Flush();
   &MYSQL = CreateSQL("select ib_packageid, ib_schemaname, ib_variantname from pslsdepchlddfn where ib_extpackageid = :1 and ib_extschemaname = :2 and ib_extvariantname = :3", &package, &schema, &variant);
   While &MYSQL.Fetch(&refpackage, &refschema, &refvariant)
      &cnt = &cnt + 1;
      insrefrow(&nrs, &refpackage, &refschema, &refvariant);
   End-While;
   
   If &cnt > 0 Then
      Return True;
   Else
      Return False;
   End-If;
End-Function;

Function isschemaused(&package As string, &schema As string, &variant As string, &message As string) Returns boolean
   Local SQL &MYSQL;
   Local string &msgname, &msgver;
   Local Record &PSOPRVERDFNM;
   Local SQL &SQLSelect;
   
   &message = "";
   
   &MYSQL = CreateSQL("select msgname, apmsgver from psmsgver where ib_packageid = :1 and ib_schemaname = :2 and ib_variantname = :3", &package, &schema, &variant);
   While &MYSQL.Fetch(&msgname, &msgver)
      /* If the current message is used in a service operation with validation on, we don't allow updates. display message. */
      If checkservoperuse(&msgname, &msgver) Then
         &message = MsgGetText(244, 219, "Document read-only.  Document belongs to a message in a restrictive service.");
         Return True;
      End-If;
      
      /* If the message belongs to a restricted service, no changes are allowed. */
      If checkpsoftservice("MESSAGE", &msgname, &msgver) Then
         &message = MsgGetText(244, 219, "Document read-only.  Document belongs to a message in a restrictive service.");
         Return True;
      End-If;
      
      If &msgname = "IB_GENERIC" Then
         &message = MsgGetText(244, 219, "Document read-only.  Document belongs to a message in a restrictive service.");
         Return True;
      End-If;
      
      /* If message is part of a service operation that belongs to a service that has been exported to WSDL, we are in read-only mode. */
      /* Also checks if WSDL does exist */
      If checkwsdluse("MESSAGE", &msgname, &msgver) And
            checkWSDLexportflagOK("MESSAGE", &msgname, &msgver) Then
         &message = MsgGetText(244, 220, "Document read-only.  Document belongs to a message in exported WSDL.");
         Return True;
      End-If;
      
      /* See if the message is used in any service operations. Plus check runtime table references. */
      &PSOPRVERDFNM = CreateRecord(Record.PSOPRVERDFNM_VW);
      &SQLSelect = CreateSQL("%SelectAll(:1) WHERE MSGNAME = :2 AND APMSGVER = :3", &PSOPRVERDFNM, &msgname, &msgver);
      While &SQLSelect.Fetch(&PSOPRVERDFNM)
         If checkruntime(&PSOPRVERDFNM.IB_OPERATIONNAME.Value, &PSOPRVERDFNM.VERSIONNAME.Value) Then
            &message = MsgGetText(244, 221, "Document read-only.  Document belongs to a message in IB runtime tables.");
            Return True;
         End-If;
      End-While;
      &SQLSelect.Close();
   End-While;
   Return False;
End-Function;

Function isdependencyreadonly(&package As string, &schema As string, &variant As string, &message As string) Returns boolean
   Local SQL &MYSQL;
   Local string &refpackage, &refschema, &refvariant, &refcontainer, &refimported;
   Local number &retval = 0;
   
   &message = "";
   
   &MYSQL = CreateSQL("select l.ib_packageid, l.ib_schemaname, l.ib_variantname, l.ib_iscontainer, l.ib_isimported from pslsdefn_vw l, pslsdepchlddfn d where l.ib_packageid = d.ib_packageid and l.ib_schemaname = d.ib_schemaname and l.ib_variantname = d.ib_variantname and d.ib_extpackageid = :1 and d.ib_extschemaname = :2 and d.ib_extvariantname = :3", &package, &schema, &variant);
   While &MYSQL.Fetch(&refpackage, &refschema, &refvariant, &refcontainer, &refimported)
      If (&refimported = "1") Then
         &message = MsgGetText(244, 222, "Document read-only.  Document is identified to be restricited.");
         Return True;
      End-If;
      If (&refcontainer = "1") And
            isschemaused(&refpackage, &refschema, &refvariant, &message) Then
         Return True;
      End-If;
   End-While;
   Return False;
End-Function;

Function isspecialcompound(&package As string, &schema As string, &variant As string) Returns boolean
   Local string &cmp;
   SQLExec("select ib_iscmpprim from pslsdefn where ib_packageid = :1 and ib_schemaname = :2 and ib_variantname = :3", &package, &schema, &variant, &cmp);
   If &cmp = "1" Then
      Return True;
   Else
      Return False;
   End-If;
End-Function;

Function isautogeneratedcompound(&package As string, &schema As string, &variant As string) Returns number
   Local number &cmp;
   SQLExec("select ib_autogenerated from pslsdefn where ib_packageid = :1 and ib_schemaname = :2 and ib_variantname = :3", &package, &schema, &variant, &cmp);
   Return &cmp;
End-Function;

/* Retrieve Logical Schema Data from DB via API calls and fill tree structure. 
&isref reflects if this is a compound reference.  
&special compound indicates if this is a complex primitive compound reference
&maincomplex indicates if the complex primtive is in the main structure or inside a compound reference.
*/
Function getlogicalschemareference(&schema As string, &variant As string, &seq As number, &level As number, &isref As boolean, &package As string, &specialcompound As boolean, &maincomplex As boolean) Returns boolean
   Local number &y, &idx;
   Local string &etype, &mlabel, &childvalue;
   Local string &enumvals, &enumdesc, &tvalu, &tdesc;
   Local Record &rec, &rec2, &rec3;
   Local PT_SCHEMA:LogicalSchemaDefinition &lsdefinition;
   Local PT_SCHEMA:LogicalSchemaPrimitive &prim;
   Local PT_SCHEMA:LogicalSchemaCollection &coll, &coll2;
   Local PT_SCHEMA:LogicalSchemaCompound &comp;
   Local boolean &newspecialcompound, &newmaincomplex;
   
   &lsdefinition = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
   rem   &lsdefinition.Debug();
   If &lsdefinition.IsNew Then
      Return False;
   End-If;
   
   If &isref Then
      &childvalue = "Y";
   Else
      &childvalue = "";
   End-If;
   
   &rec = CreateRecord(Record.PSIBLOGSCHM_NDE);
   
   For &y = 1 To &lsdefinition.GetElementCount()
      &etype = &lsdefinition.GetElementType(&y);
      
      Evaluate &etype
      When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
         &prim = &lsdefinition.GetPrimitive(&y);
         &rec.IB_LSITEMNAME.Value = &prim.Name;
         &rec.IB_ISREQUIRED.Value = BooltoYN(&prim.Required);
         &rec.IB_LSITEMTYPE.Value = primitive_tochar(&prim.Type);
         &rec.IB_LSLENGTH.Value = &prim.Length;
         &rec.IB_LSDECLENGTH.Value = &prim.FractionalDigits;
         &rec.IB_LSMININC.Value = &prim.MinInclusive;
         &rec.IB_LSMAXINC.Value = &prim.MaxInclusive;
         &rec.IB_LSELEMENTTYPE.Value = "PR";
         &rec.IB_LSADDCOMPCHILD.Value = &childvalue;
         &rec.IB_LSPRIMLABEL.Value = &prim.Label;
         &rec.LSEQNO.Value = &prim.SequenceNumber;
         rem &rec.IB_LSPRIMCONST.Value = &prim.FixedConstant;
         rem &rec.IB_LSCONSTOVERRIDE.Value = BooltoYN(&prim.IsConstantOverride);
         &rec.IB_LSDTTMFORMAT.Value = &prim.FormatIndex;
         
         /* Set the Subtype for the primitive */
         &rec.IB_LSSTR_ST.Value = &prim.FormatIndex;
         &rec.IB_LSINT_ST.Value = &prim.FormatIndex;
         &rec.IB_LSDAT_ST.Value = &prim.FormatIndex;
         &rec.IB_LSTXT_ST.Value = &prim.FormatIndex;
         
         If &specialcompound Then
            &rec.IB_ISCMPPRIM.Value = "1";
         End-If;
         If &maincomplex Then
            &rec.IB_LSMAINCOMPLEX.Value = "1";
         End-If;
         
         /* Load the Enum values and descriptions into one LongChar field */
         &enumvals = "";
         &enumdesc = "";
         For &idx = 1 To &prim.GetEnumCount()
            If (&idx <> 1) Then
               &enumvals = &enumvals | &ENUMDELIMETER;
               &enumdesc = &enumdesc | &ENUMDELIMETER;
            End-If;
            &tvalu = &prim.GetEnumName(&idx);
            &tdesc = &prim.GetEnumDescription(&idx);
            If None(&tvalu) Then
               &enumvals = &enumvals | " ";
            Else
               &enumvals = &enumvals | &tvalu;
            End-If;
            If None(&tdesc) Then
               &enumdesc = &enumdesc | " ";
            Else
               &enumdesc = &enumdesc | &tdesc;
            End-If;
         End-For;
         &rec.IB_ENUM_VALUE.Value = &enumvals;
         &rec.IB_ENUM_DESCR.Value = &enumdesc;
         
         insertnode("PR", &seq, &level, &rec);
         &seq = &seq + 1;
         Break;
      When &LS_CONSTANTS.ELEMENT_TYPE_COLLECTION
         &coll = &lsdefinition.GetCollection(&y);
         &rec.IB_LSITEMNAME.Value = &coll.Name;
         &rec.IB_ISREQUIRED.Value = BooltoYN(&coll.Required);
         &rec.IB_SCHEMAMIN.Value = &coll.MinOccurs;
         &rec.LSEQNO.Value = &coll.SequenceNumber;
         
         If &coll.MaxOccurs = %Document_OccursUnbounded Then
            &rec.IB_SCHEMAMAX.Value = - 1;
            &rec.IB_SCHEMAUNBOUND.Value = "Y";
         Else
            &rec.IB_SCHEMAMAX.Value = &coll.MaxOccurs;
            &rec.IB_SCHEMAUNBOUND.Value = "N";
         End-If;
         &rec.IB_LSELEMENTTYPE.Value = "CL";
         &rec.IB_LSADDCOMPCHILD.Value = &childvalue;
         insertnode("CL", &seq, &level, &rec);
         &seq = &seq + 1;
         
         /* Collection Has a Single Child - Primitive or Compound only. */
         Evaluate &coll.GetElementType()
         When = &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
            &prim = &coll.GetPrimitive();
            &rec.IB_LSITEMNAME.Value = &prim.Name;
            &rec.IB_ISREQUIRED.Value = BooltoYN(&prim.Required);
            &rec.IB_LSITEMTYPE.Value = primitive_tochar(&prim.Type);
            &rec.IB_LSLENGTH.Value = &prim.Length;
            &rec.IB_LSDECLENGTH.Value = &prim.FractionalDigits;
            &rec.IB_LSMININC.Value = &prim.MinInclusive;
            &rec.IB_LSMAXINC.Value = &prim.MaxInclusive;
            &rec.IB_LSELEMENTTYPE.Value = "PR";
            &rec.IB_LSADDCOMPCHILD.Value = &childvalue;
            &rec.IB_LSPRIMLABEL.Value = &prim.Label;
            &rec.LSEQNO.Value = &prim.SequenceNumber;
            rem &rec.IB_LSPRIMCONST.Value = &prim.FixedConstant;
            &rec.IB_ISCMPPRIM.Value = "0";
            
            &rec.IB_LSDTTMFORMAT.Value = &prim.FormatIndex;
            
            /* Set the Subtype for the primitive */
            &rec.IB_LSSTR_ST.Value = &prim.FormatIndex;
            &rec.IB_LSINT_ST.Value = &prim.FormatIndex;
            &rec.IB_LSDAT_ST.Value = &prim.FormatIndex;
            &rec.IB_LSTXT_ST.Value = &prim.FormatIndex;
            
            /* Load the Enum values and descriptions into one LongChar field */
            &enumvals = "";
            &enumdesc = "";
            For &idx = 1 To &prim.GetEnumCount()
               If (&idx <> 1) Then
                  &enumvals = &enumvals | &ENUMDELIMETER;
                  &enumdesc = &enumdesc | &ENUMDELIMETER;
               End-If;
               &tvalu = &prim.GetEnumName(&idx);
               &tdesc = &prim.GetEnumDescription(&idx);
               If None(&tvalu) Then
                  &enumvals = &enumvals | " ";
               Else
                  &enumvals = &enumvals | &tvalu;
               End-If;
               If None(&tdesc) Then
                  &enumdesc = &enumdesc | " ";
               Else
                  &enumdesc = &enumdesc | &tdesc;
               End-If;
            End-For;
            &rec.IB_ENUM_VALUE.Value = &enumvals;
            &rec.IB_ENUM_DESCR.Value = &enumdesc;
            
            insertnode("PR", &seq, &level + 1, &rec);
            &seq = &seq + 1;
            Break;
         When = &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
            &comp = &coll.GetCompound();
            &rec.IB_LSITEMNAME.Value = &comp.Name;
            &rec.IB_ISREQUIRED.Value = BooltoYN(&comp.Required);
            &rec.IB_LSSCHEMA.Value = &comp.LogicalSchema;
            &rec.IB_LSVARIANT.Value = &comp.Variant;
            &rec.LSEQNO.Value = &comp.SequenceNumber;
            &rec.IB_LSELEMENTTYPE.Value = "CP";
            &rec.IB_LSADDCOMPCHILD.Value = &childvalue;
            &rec.IB_PACKAGEID.Value = &comp.Package;
            If Not logicalexists(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value) Then
               MessageBox(0, "", 244, 97, "Error.  Package %1 schema %2 version %3 does not exist.", &rec.IB_PACKAGEID, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value);
               Exit;
            End-If;
            If isspecialcompound(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value) Then
               &rec.IB_ISCMPPRIM.Value = "1";
               &newspecialcompound = True;
            Else
               &rec.IB_ISCMPPRIM.Value = "0";
               &newspecialcompound = False;
            End-If;
            &rec.IB_AUTOGENERATED.Value = isautogeneratedcompound(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value);
            If Not &isref And
                  &newspecialcompound Then
               &newmaincomplex = True;
               &rec.IB_LSMAINCOMPLEX.Value = "1";
            Else
               &newmaincomplex = False;
            End-If;
            insertnode("CP", &seq, &level + 1, &rec);
            &seq = &seq + 1;
            
            If Not getlogicalschemareference(&rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value, &seq, &level + 2, True, &rec.IB_PACKAGEID.Value, &newspecialcompound, &newmaincomplex) Then
               MessageBox(0, "", 244, 98, "Error.  Function getlogicalschemareference failed for package %1 schema %2 version %3.", &rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value);
               Exit;
            End-If;
            Break;
         End-Evaluate;
         Break;
      When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
         &comp = &lsdefinition.GetCompound(&y);
         &rec.IB_LSITEMNAME.Value = &comp.Name;
         &rec.IB_ISREQUIRED.Value = BooltoYN(&comp.Required);
         &rec.IB_LSSCHEMA.Value = &comp.LogicalSchema;
         &rec.IB_LSVARIANT.Value = &comp.Variant;
         &rec.LSEQNO.Value = &comp.SequenceNumber;
         &rec.IB_LSELEMENTTYPE.Value = "CP";
         &rec.IB_LSADDCOMPCHILD.Value = &childvalue;
         &rec.IB_PACKAGEID.Value = &comp.Package;
         If Not logicalexists(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value) Then
            MessageBox(0, "", 244, 97, "Error.  Package %1 schema %2 version %3 does not exist.", &rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value);
            Exit;
         End-If;
         If isspecialcompound(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value) Then
            &rec.IB_ISCMPPRIM.Value = "1";
            &newspecialcompound = True;
         Else
            &rec.IB_ISCMPPRIM.Value = "0";
            &newspecialcompound = False;
         End-If;
         &rec.IB_AUTOGENERATED.Value = isautogeneratedcompound(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value);
         If Not &isref And
               &newspecialcompound Then
            &newmaincomplex = True;
            &rec.IB_LSMAINCOMPLEX.Value = "1";
         Else
            &newmaincomplex = False;
         End-If;
         insertnode("CP", &seq, &level, &rec);
         &seq = &seq + 1;
         
         If Not getlogicalschemareference(&rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value, &seq, &level + 1, True, &rec.IB_PACKAGEID.Value, &newspecialcompound, &newmaincomplex) Then
            MessageBox(0, "", 244, 98, "Error.  Function getlogicalschemareference failed for package %1 schema %2 version %3.", &rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value);
            Exit;
         End-If;
         Break;
      When-Other
         MessageBox(0, "", 244, 82, "Error.  Invalid element type %1.", &etype);
         Exit;
      End-Evaluate;
   End-For;
   Return True;
End-Function;

Function insnamespacerow(&r As Rowset, &prefix As string, &uri As string)
   Local Row &row;
   If All(&r.GetRow(&r.ActiveRowCount).GetRecord(Record.PSLSIMPNMSPC_VW).IB_LSIMPPREFIX.Value) Or
         All(&r.GetRow(&r.ActiveRowCount).GetRecord(Record.PSLSIMPNMSPC_VW).IB_LSIMPURI.Value) Then
      &r.InsertRow(&r.ActiveRowCount);
   End-If;
   &row = &r.GetRow(&r.ActiveRowCount);
   &row.GetRecord(Record.PSLSIMPNMSPC_VW).IB_LSIMPPREFIX.Value = &prefix;
   &row.GetRecord(Record.PSLSIMPNMSPC_VW).IB_LSIMPURI.Value = &uri;
End-Function;

Function namespaceisduplicate(&r As Rowset, &prefix As string, &uri As string) Returns boolean
   Local number &c;
   Local Row &row;
   
   For &c = 1 To &r.ActiveRowCount
      &row = &r.GetRow(&c);
      If &row.GetRecord(Record.PSLSIMPNMSPC_VW).IB_LSIMPPREFIX.Value = &prefix And
            &row.GetRecord(Record.PSLSIMPNMSPC_VW).IB_LSIMPURI.Value = &uri Then
         Return True;
      End-If;
   End-For;
   Return False;
End-Function;

/* Populate xml schema fields in current tree. */
Function getdocxmlschemareference(&schema As string, &variant As string, &xmlname As string, &seq As number, &level As number, &isref As boolean, &package As string, &lrow As number, &lsrec As Record, &lsrs As Rowset) Returns boolean
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition;
   Local PT_SCHEMA:XmlSchemaNamespace &targetnamespace;
   Local PT_SCHEMA:XmlSchemaPrimitive &prim;
   Local PT_SCHEMA:XmlSchemaCollection &coll, &coll2;
   Local PT_SCHEMA:XmlSchemaCompound &comp;
   
   Local string &childvalue, &etype, &prefix, &uri;
   Local string &telementtype, &telementtype2, &telementtype3;
   Local number &y, &lastrow, &ecount;
   Local Rowset &rs;
   Local Record &rec, &rec2, &rec3;
   
   &xmldefinition = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &xmlname);
   If &xmldefinition.IsNew Then
      Return False;
   End-If;
   
   /* Populate header fields for top-level only.  The top level is not a reference.  All others are. */
   If &isref = False Then
      &lsrec.IB_DESCR2.Value = &xmldefinition.Label;
      &lsrec.IB_DESCRLONG.Value = &xmldefinition.Description;
      &lsrec.IB_LSXMLNODETYPE.Value = encodexmlnodetype(&xmldefinition.DefaultPrimitiveNodeType);
      &lsrec.IB_LSXMLTYPE.Value = encodexmltype(&xmldefinition.XmlType);
      &targetnamespace = &xmldefinition.GetTargetNamespace();
      
      If &targetnamespace <> Null Then
         &lsrec.IB_LSTGTPREFIX.Value = &targetnamespace.Prefix;
         &lsrec.IB_LSTGTPREFIXTMP.Value = &targetnamespace.Prefix;
         &lsrec.IB_LSTGTURI.Value = &targetnamespace.Uri;
      Else
      End-If;
      &lsrec.IB_NONAMESPACE.Value = BooltoYN(&xmldefinition.NoTargetNamespace);
      &lsrec.IB_LSFILTERBLANKS.Value = BooltoYN(&xmldefinition.FilterBlankElements);
      &lsrec.IB_LSREPPARENT.Value = BooltoYN(&xmldefinition.IncludeCollectionTags);
      &lsrec.IB_LSINCDESCR.Value = BooltoYN(&xmldefinition.IncludeDescriptionsAsComments);
      &lsrec.IB_LSINCMETA.Value = BooltoYN(&xmldefinition.IncludeMetadata);
      &lsrec.IB_LSINCNAMESPACE.Value = BooltoYN(&xmldefinition.IncludeNamespaceImports);
      &lsrec.IB_LSTRIMWHITE.Value = BooltoYN(&xmldefinition.TrimWhitespace);
      
      /* Populate header imported namespaces. */
      &rs = &lsrs;
      For &y = 1 To &xmldefinition.GetImportedNamespacesCount()
         &targetnamespace = &xmldefinition.GetImportedNamespaces(&y);
         &prefix = "";
         &uri = "";
         If &targetnamespace <> Null Then
            &prefix = &targetnamespace.Prefix;
            &uri = &targetnamespace.Uri;
         End-If;
         If All(&prefix) Or
               All(&uri) Then
            insnamespacerow(&rs, &prefix, &uri);
         End-If;
      End-For;
   End-If;
   
   /* Populate xml schema fields on the tree. */
   If &lrow = 0 Then
      &lastrow = findlastrow(&NODERS, &seq);
   Else
      &lastrow = &lrow;
   End-If;
   &ecount = 1;
   
   For &y = &seq To &lastrow
      &rec = &NODERS.GetRow(&y).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = &level Then
         &telementtype = &NODERS.GetRow(&y).GetRecord(1).IB_LSELEMENTTYPE.Value;
         If &ecount > &xmldefinition.GetElementCount() Then
            MessageBox(0, "", 244, 99, "Error. XML schema element count mismatch.  Tree element count %1.  XML element count %2.  Level %3.", &ecount, &xmldefinition.GetElementCount(), &level);
            Return False;
         End-If;
         &etype = &xmldefinition.GetElementType(&ecount);
         Evaluate &etype
         When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
            If &telementtype <> "PR" Then
               MessageBox(0, "", 244, 100, "Error. XML schema element mismatch.  Tree element %1.  XML Schema element %2. Level %3.  Row %4.", &telementtype, "PR", &level, &y);
               Return False;
            End-If;
            &prim = &xmldefinition.GetPrimitive(&ecount);
            &rec.IB_LSXMLTAG.Value = &prim.TagName;
            &rec.IB_LSXMLPREFIX.Value = &prim.NamespacePrefix;
            &rec.IB_LSXMLNODETYPE.Value = encodexmlnodetype(&prim.XmlNodeType);
            &rec.IB_LSPRIMWHITESP.Value = encodetrim(&prim.TrimWhitespace);
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COLLECTION
            If &telementtype <> "CL" Then
               MessageBox(0, "", 244, 100, "Error. XML schema element mismatch.  Tree element %1.  XML Schema element %2. Level %3.  Row %4.", &telementtype, "CL", &level, &y);
               Return False;
            End-If;
            &coll = &xmldefinition.GetCollection(&ecount);
            &rec.IB_LSXMLTAG.Value = &coll.TagName;
            &rec.IB_LSXMLPREFIX.Value = &coll.NamespacePrefix;
            &rec2 = &NODERS.GetRow(&y + 1).GetRecord(1);
            &telementtype2 = &NODERS.GetRow(&y + 1).GetRecord(1).IB_LSELEMENTTYPE.Value;
            Evaluate &coll.GetElementType()
            When = &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
               If &telementtype2 <> "PR" Then
                  MessageBox(0, "", 244, 100, "Error. XML schema element mismatch.  Tree element %1.  XML Schema element %2. Level %3.  Row %4.", &telementtype2, "PR", &level + 1, &y);
                  Return False;
               End-If;
               &prim = &coll.GetPrimitive();
               &rec2.IB_LSXMLTAG.Value = &prim.TagName;
               &rec2.IB_LSXMLPREFIX.Value = &prim.NamespacePrefix;
               &rec2.IB_LSXMLNODETYPE.Value = encodexmlnodetype(&prim.XmlNodeType);
               &rec2.IB_LSPRIMWHITESP.Value = encodetrim(&prim.TrimWhitespace);
               Break;
            When = &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
               If &telementtype2 <> "CP" Then
                  MessageBox(0, "", 244, 100, "Error. XML schema element mismatch.  Tree element %1.  XML Schema element %2. Level %3.  Row %4.", &telementtype, "CP", &level + 1, &y);
                  Return False;
               End-If;
               &comp = &coll.GetCompound();
               &rec2.IB_LSXMLTAG.Value = &comp.TagName;
               &rec2.IB_LSXMLPREFIX.Value = &comp.NamespacePrefix;
               
               If Not (getdocxmlschemareference(&rec2.IB_LSSCHEMA.Value, &rec2.IB_LSVARIANT.Value, &comp.XmlSchema, &y, &level + 2, True, &rec2.IB_PACKAGEID.Value, 0, &lsrec, &lsrs)) Then
                  MessageBox(0, "", 244, 101, "Error.  Unable to retrieve XML Schema %1 %2 %3.", &rec2.IB_LSSCHEMA.Value, &rec2.IB_LSVARIANT.Value, &comp.XmlSchema);
                  Return False;
               End-If;
               Break;
            When-Other
            End-Evaluate;
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
            If &telementtype <> "CP" Then
               MessageBox(0, "", 244, 100, "Error. XML schema element mismatch.  Tree element %1.  XML Schema element %2. Level %3.  Row %4.", &telementtype, "CP", &level, &y);
               Return False;
            End-If;
            &comp = &xmldefinition.GetCompound(&ecount);
            &rec.IB_LSXMLTAG.Value = &comp.TagName;
            &rec.IB_LSXMLPREFIX.Value = &comp.NamespacePrefix;
            
            If Not (getdocxmlschemareference(&rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value, &comp.XmlSchema, &y, &level + 1, True, &rec.IB_PACKAGEID.Value, 0, &lsrec, &lsrs)) Then
               rem               MessageBox(0, "", 0, 0, "Error.  Unable to retrieve XML Schema %1 %2 %3", &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value, &comp.XmlSchema);
               Return False;
            End-If;
            Break;
         When-Other
            MessageBox(0, "", 244, 102, "Error.  Invalid XML schema type %1.  Level %2.", &etype, &level);
            Return False;
         End-Evaluate;
         &ecount = &ecount + 1;
      End-If;
   End-For;
   Return True;
End-Function;

/* Populate xml schema fields in current tree. */
Function getxmlschemareference(&schema As string, &variant As string, &xmlname As string, &seq As number, &level As number, &isref As boolean, &package As string, &lrow As number) Returns boolean
   Local Record &lsrec;
   Local Rowset &lsrs;
   
   &lsrec = GetLevel0().GetRow(1).GetRecord(Record.PSIBLOGICAL_WRK);
   &lsrs = GetLevel0().GetRow(1).GetRowset(Scroll.PSLSIMPNMSPC_VW);
   
   Return getdocxmlschemareference(&schema, &variant, &xmlname, &seq, &level, &isref, &package, &lrow, &lsrec, &lsrs);
End-Function;

Function check_sync(&type As string, &treetype As string, &objtype As string, &level As number, &crow As number) Returns boolean
   If &treetype <> &objtype Then
      MessageBox(0, "", 244, 103, "Error.  Element mismatch.  Tree element type %1.  Relational element type %2.  Level %3.  Row %4.", &treetype, &objtype, &level, &crow);
      Return False;
   End-If;
   Return True;
End-Function;

Function getdocrelschemareference(&package As string, &schema As string, &variant As string, &seq As number, &level As number, &isref As boolean, &relname As string, &lrow As number, &lsrec As Record) Returns boolean
   Local PT_SCHEMA:RelationalSchemaDefinition &reldefinition;
   Local PT_SCHEMA:RelationalSchemaPrimitive &prim;
   Local PT_SCHEMA:RelationalSchemaCollection &coll;
   Local PT_SCHEMA:RelationalSchemaCompound &comp;
   
   Local number &lastrow, &ecount, &y;
   Local Record &rec, &rec2;
   Local string &telementtype, &etype, &telementtype2;
   Local boolean &bRet;
   
   &reldefinition = create PT_SCHEMA:RelationalSchemaDefinition(&package, &schema, &variant, &relname);
   
   /* Populate fields on the tree. */
   If &lrow = 0 Then
      &lastrow = findlastrow(&NODERS, &seq);
   Else
      &lastrow = &lrow;
   End-If;
   
   If &reldefinition.IsNew Then
      /* Even if parent has no relational schema, the children could.  So we iterate to check. */
      For &y = &seq To &lastrow
         &rec = &NODERS.GetRow(&y).GetRecord(1);
         If &rec.TREE_LEVEL_NUM.Value = &level Then
            &telementtype = &rec.IB_LSELEMENTTYPE.Value;
            Evaluate &telementtype
            When "CL"
               If &y = &NODERS.ActiveRowCount Then
                  MessageBox(0, "", 244, 104, "Error.  Found invalid compound at row %1.", &y);
                  Return False;
               End-If;
               &rec2 = &NODERS.GetRow(&y + 1).GetRecord(1);
               If &rec2.IB_LSELEMENTTYPE.Value = "CP" Then
                  &bRet = getdocrelschemareference(&rec2.IB_PACKAGEID.Value, &rec2.IB_LSSCHEMA.Value, &rec2.IB_LSVARIANT.Value, &y, &level + 2, True, &relname, 0, &lsrec);
               End-If;
               Break;
            When "CP"
               &bRet = getdocrelschemareference(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value, &y, &level + 1, True, &relname, 0, &lsrec);
               Break;
            End-Evaluate;
         End-If;
      End-For;
      Return True;
   End-If;
   
   /* For non references, get header info. */
   If &isref = False Then
      &lsrec.IB_RELLABEL.Value = &reldefinition.Label;
      &lsrec.IB_RELDESCR.Value = &reldefinition.Description;
      &lsrec.IB_RELRECNAME.Value = &reldefinition.RecordName;
   End-If;
   
   &ecount = 1;
   For &y = &seq To &lastrow
      &rec = &NODERS.GetRow(&y).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = &level Then
         &telementtype = &rec.IB_LSELEMENTTYPE.Value;
         If &ecount > &reldefinition.GetElementCount() Then
            MessageBox(0, "", 244, 105, "Error. Relational Schema element count mismatch.  Tree count %1.  Relational count %2. Level %3.", &ecount, &reldefinition.GetElementCount(), &level);
            Return False;
         End-If;
         &etype = &reldefinition.GetElementType(&ecount);
         
         Evaluate &etype
         When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
            If Not check_sync("Relational", &telementtype, "PR", &level, &y) Then
               Return False;
            End-If;
            &prim = &reldefinition.GetPrimitive(&ecount);
            &rec.IB_RECNAME.Value = &prim.RecordName;
            &rec.IB_RECFLDNAME.Value = &prim.FieldName;
            &rec.IB_RECISKEY.Value = BooltoYN(&prim.isKey);
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COLLECTION
            If Not check_sync("Relational", &telementtype, "CL", &level, &y) Then
               Return False;
            End-If;
            &coll = &reldefinition.GetCollection(&ecount);
            &rec2 = &NODERS.GetRow(&y + 1).GetRecord(1);
            &telementtype2 = &NODERS.GetRow(&y + 1).GetRecord(1).IB_LSELEMENTTYPE.Value;
            Evaluate &coll.GetElementType()
            When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
               If Not check_sync("Relational", &telementtype2, "PR", &level + 1, &y) Then
                  Return False;
               End-If;
               &prim = &coll.GetPrimitive();
               &rec2.IB_RECNAME.Value = &prim.RecordName;
               &rec2.IB_RECFLDNAME.Value = &prim.FieldName;
               &rec2.IB_RECISKEY.Value = &prim.isKey;
               Break;
            When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
               If Not check_sync("Relational", &telementtype2, "CP", &level + 1, &y) Then
                  Return False;
               End-If;
               &comp = &coll.GetCompound();
               If Not (getdocrelschemareference(&rec2.IB_PACKAGEID.Value, &rec2.IB_LSSCHEMA.Value, &rec2.IB_LSVARIANT.Value, &y, &level + 2, True, &relname, 0, &lsrec)) Then
                  MessageBox(0, "", 244, 106, "Error.  Unable to retrieve Relational Schema %1 %2 %3.", &rec2.IB_PACKAGEID.Value, &rec2.IB_LSSCHEMA.Value, &rec2.IB_LSVARIANT.Value);
                  Return False;
               End-If;
               Break;
            End-Evaluate;
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
            If Not check_sync("Relational", &telementtype, "CP", &level, &y) Then
               Return False;
            End-If;
            &comp = &reldefinition.GetCompound(&ecount);
            If Not (getdocrelschemareference(&rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value, &y, &level + 1, True, &relname, 0, &lsrec)) Then
               MessageBox(0, "", 244, 106, "Error.  Unable to retrieve Relational Schema %1 %2 %3.", &rec.IB_PACKAGEID.Value, &rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value);
               Return False;
            End-If;
            Break;
         When-Other
            MessageBox(0, "", 244, 107, "Error.  Invalid Relational schema type %1. Level %2.", &etype, &level);
            Return False;
         End-Evaluate;
         &ecount = &ecount + 1;
      End-If;
   End-For;
   Return True;
End-Function;

Function getrelschemareference(&package As string, &schema As string, &variant As string, &seq As number, &level As number, &isref As boolean, &relname As string, &lrow As number) Returns boolean
   Local Record &lsrec;
   &lsrec = GetLevel0().GetRow(1).GetRecord(Record.PSIBLOGICAL_WRK);
   Return getdocrelschemareference(&package, &schema, &variant, &seq, &level, &isref, &relname, &lrow, &lsrec);
End-Function;

/* Populate json fields in current tree. */
Function getdocjsonschemareference(&schema As string, &variant As string, &jsonname As string, &seq As number, &level As number, &isref As boolean, &package As string, &lrow As number, &lsrec As Record) Returns boolean
   Local PT_SCHEMA:JsonSchemaDefinition &jsondefinition;
   Local PT_SCHEMA:JsonSchemaPrimitive &prim;
   Local PT_SCHEMA:JsonSchemaCollection &coll, &coll2;
   Local PT_SCHEMA:JsonSchemaCompound &comp;
   
   Local string &childvalue, &etype, &prefix, &uri;
   Local string &telementtype, &telementtype2, &telementtype3;
   Local number &y, &lastrow, &ecount;
   Local Rowset &rs;
   Local Record &rec, &rec2, &rec3;
   
   &jsondefinition = create PT_SCHEMA:JsonSchemaDefinition(&package, &schema, &variant, &jsonname);
   If &jsondefinition.IsNew Then
      Return False;
   End-If;
   
   /* Populate header fields for top-level only.  The top level is not a reference.  All others are. */
   If &isref = False Then
      &lsrec.IB_LSJSONNAME.Value = &jsondefinition.JsonName;
      &lsrec.IB_LSJSONLABEL.Value = &jsondefinition.Label;
      &lsrec.IB_DESCRLONG.Value = &jsondefinition.Description;
      &lsrec.IB_LSJSONHIDELBL.Value = "N";
      If &jsondefinition.HideParentObject Then
         &lsrec.IB_LSJSONHIDELBL.Value = "Y";
      End-If;
   End-If;
   
   /* Populate xml schema fields on the tree. */
   If &lrow = 0 Then
      &lastrow = findlastrow(&NODERS, &seq);
   Else
      &lastrow = &lrow;
   End-If;
   &ecount = 1;
   
   For &y = &seq To &lastrow
      &rec = &NODERS.GetRow(&y).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = &level Then
         &telementtype = &NODERS.GetRow(&y).GetRecord(1).IB_LSELEMENTTYPE.Value;
         If &ecount > &jsondefinition.GetElementCount() Then
            MessageBox(0, "", 244, 252, "Error. JSON schema element count mismatch.  Tree element count %1.  JSON element count %2.  Level %3.", &ecount, &jsondefinition.GetElementCount(), &level);
            Return False;
         End-If;
         &etype = &jsondefinition.GetElementType(&ecount);
         Evaluate &etype
         When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
            If &telementtype <> "PR" Then
               MessageBox(0, "", 244, 253, "Error. JSON schema element mismatch.  Tree element %1.  JSON Schema element %2. Level %3.  Row %4.", &telementtype, "PR", &level, &y);
               Return False;
            End-If;
            &prim = &jsondefinition.GetPrimitive(&ecount);
            &rec.IB_LSJSONTAG.Value = &prim.TagName;
            &rec.IB_LSJSONEXP.Value = "N";
            If &prim.Exponent Then
               &rec.IB_LSJSONEXP.Value = "Y";
            End-If;
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COLLECTION
            If &telementtype <> "CL" Then
               MessageBox(0, "", 244, 253, "Error. JSON schema element mismatch.  Tree element %1.  JSON Schema element %2. Level %3.  Row %4.", &telementtype, "CL", &level, &y);
               Return False;
            End-If;
            &coll = &jsondefinition.GetCollection(&ecount);
            &rec.IB_LSJSONTAG.Value = &coll.TagName;
            &rec2 = &NODERS.GetRow(&y + 1).GetRecord(1);
            &telementtype2 = &NODERS.GetRow(&y + 1).GetRecord(1).IB_LSELEMENTTYPE.Value;
            Evaluate &coll.GetElementType()
            When = &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
               If &telementtype2 <> "PR" Then
                  MessageBox(0, "", 244, 253, "Error. JSON schema element mismatch.  Tree element %1.  JSON Schema element %2. Level %3.  Row %4.", &telementtype2, "PR", &level + 1, &y);
                  Return False;
               End-If;
               &prim = &coll.GetPrimitive();
               &rec2.IB_LSJSONTAG.Value = &prim.TagName;
               &rec2.IB_LSJSONEXP.Value = "N";
               If &prim.Exponent Then
                  &rec2.IB_LSJSONEXP.Value = "Y";
               End-If;
               Break;
            When = &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
               If &telementtype2 <> "CP" Then
                  MessageBox(0, "", 244, 253, "Error. JSON schema element mismatch.  Tree element %1.  JSON Schema element %2. Level %3.  Row %4.", &telementtype, "CP", &level + 1, &y);
                  Return False;
               End-If;
               &comp = &coll.GetCompound();
               &rec2.IB_LSJSONTAG.Value = &comp.TagName;
               
               If Not (getdocjsonschemareference(&rec2.IB_LSSCHEMA.Value, &rec2.IB_LSVARIANT.Value, &comp.JsonSchema, &y, &level + 2, True, &rec2.IB_PACKAGEID.Value, 0, &lsrec)) Then
                  MessageBox(0, "", 244, 254, "Error.  Unable to retrieve JSON Schema %1 %2 %3.", &rec2.IB_LSSCHEMA.Value, &rec2.IB_LSVARIANT.Value, &comp.JsonSchema);
                  Return False;
               End-If;
               Break;
            When-Other
            End-Evaluate;
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
            If &telementtype <> "CP" Then
               MessageBox(0, "", 244, 253, "Error. JSON schema element mismatch.  Tree element %1.  JSON Schema element %2. Level %3.  Row %4.", &telementtype, "CP", &level, &y);
               Return False;
            End-If;
            &comp = &jsondefinition.GetCompound(&ecount);
            &rec.IB_LSJSONTAG.Value = &comp.TagName;
            
            If Not (getdocjsonschemareference(&rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value, &comp.JsonSchema, &y, &level + 1, True, &rec.IB_PACKAGEID.Value, 0, &lsrec)) Then
               Return False;
            End-If;
            Break;
         When-Other
            MessageBox(0, "", 244, 255, "Error.  Invalid JSON schema type %1.  Level %2.", &etype, &level);
            Return False;
         End-Evaluate;
         &ecount = &ecount + 1;
      End-If;
   End-For;
   Return True;
End-Function;

/* Populate html fields in current tree. */
Function getdochtmlschemareference(&schema As string, &variant As string, &htmlname As string, &seq As number, &level As number, &isref As boolean, &package As string, &lrow As number, &lsrec As Record) Returns boolean
   Local PT_SCHEMA:HtmlSchemaDefinition &htmldefinition;
   Local PT_SCHEMA:HtmlSchemaPrimitive &prim;
   Local PT_SCHEMA:HtmlSchemaCollection &coll, &coll2;
   Local PT_SCHEMA:HtmlSchemaCompound &comp;
   
   Local string &childvalue, &etype, &prefix, &uri;
   Local string &telementtype, &telementtype2, &telementtype3;
   Local number &y, &lastrow, &ecount;
   Local Rowset &rs;
   Local Record &rec, &rec2, &rec3;
   
   &htmldefinition = create PT_SCHEMA:HtmlSchemaDefinition(&package, &schema, &variant, &htmlname);
   If &htmldefinition.IsNew Then
      Return False;
   End-If;
   
   /* Populate header fields for top-level only.  The top level is not a reference.  All others are. */
   If &isref = False Then
      &lsrec.IB_LSHTMLNAME.Value = &htmldefinition.HtmlName;
      &lsrec.IB_LSHTMLLABEL.Value = &htmldefinition.Label;
      rem      &lsrec.IB_DESCRLONG.Value = &htmldefinition.Description;
   End-If;
   
   /* Populate html schema fields on the tree. */
   If &lrow = 0 Then
      &lastrow = findlastrow(&NODERS, &seq);
   Else
      &lastrow = &lrow;
   End-If;
   &ecount = 1;
   
   For &y = &seq To &lastrow
      &rec = &NODERS.GetRow(&y).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = &level Then
         &telementtype = &NODERS.GetRow(&y).GetRecord(1).IB_LSELEMENTTYPE.Value;
         If &ecount > &htmldefinition.GetElementCount() Then
            MessageBox(0, "", 158, 20112, "Error. HTML schema element count mismatch.  Tree element count %1.  HTML element count %2.  Level %3.", &ecount, &htmldefinition.GetElementCount(), &level);
            Return False;
         End-If;
         &etype = &htmldefinition.GetElementType(&ecount);
         Evaluate &etype
         When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
            If &telementtype <> "PR" Then
               MessageBox(0, "", 158, 20110, "Error. HTML schema element mismatch.  Tree element %1.  HTML Schema element %2. Level %3.  Row %4.", &telementtype, "PR", &level, &y);
               /* 244,253 */
               Return False;
            End-If;
            
            &prim = &htmldefinition.GetPrimitive(&ecount);
            
            rem            MessageBox(0, "", 0, 0, "Found primitive row %1 ecount %2 Name %3 htmltag %4", &y, &ecount, &prim.Id, &prim.TagName);
            
            &rec.IB_LSHTMLTAG.Value = &prim.TagName;
            &rec.IB_LSHTMLTYPE.Value = GetHTMLStrType(&prim.HtmlType);
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COLLECTION
            If &telementtype <> "CL" Then
               MessageBox(0, "", 158, 20110, "Error. HTML schema element mismatch.  Tree element %1.  HTML Schema element %2. Level %3.  Row %4.", &telementtype, "CL", &level, &y);
               Return False;
            End-If;
            &coll = &htmldefinition.GetCollection(&ecount);
            &rec.IB_LSHTMLTAG.Value = &coll.TagName;
            &rec2 = &NODERS.GetRow(&y + 1).GetRecord(1);
            &telementtype2 = &NODERS.GetRow(&y + 1).GetRecord(1).IB_LSELEMENTTYPE.Value;
            Evaluate &coll.GetElementType()
            When = &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
               If &telementtype2 <> "PR" Then
                  MessageBox(0, "", 158, 20110, "Error. HTML schema element mismatch.  Tree element %1.  HTML Schema element %2. Level %3.  Row %4.", &telementtype2, "PR", &level + 1, &y);
                  Return False;
               End-If;
               &prim = &coll.GetPrimitive();
               &rec2.IB_LSHTMLTAG.Value = &prim.TagName;
               &rec2.IB_LSHTMLTYPE.Value = GetHTMLStrType(&prim.HtmlType);
               Break;
            When = &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
               If &telementtype2 <> "CP" Then
                  MessageBox(0, "", 158, 20110, "Error. HTML schema element mismatch.  Tree element %1.  HTML Schema element %2. Level %3.  Row %4.", &telementtype2, "CP", &level + 1, &y);
                  Return False;
               End-If;
               &comp = &coll.GetCompound();
               &rec2.IB_LSHTMLTAG.Value = &comp.TagName;
               
               If Not (getdochtmlschemareference(&rec2.IB_LSSCHEMA.Value, &rec2.IB_LSVARIANT.Value, &comp.HtmlSchema, &y, &level + 2, True, &rec2.IB_PACKAGEID.Value, 0, &lsrec)) Then
                  MessageBox(0, "", 158, 20111, "Error.  Unable to retrieve HTML Schema %1 %2 %3.", &rec2.IB_LSSCHEMA.Value, &rec2.IB_LSVARIANT.Value, &comp.HtmlSchema);
                  /* 244, 254 */
                  Return False;
               End-If;
               Break;
            When-Other
            End-Evaluate;
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
            If &telementtype <> "CP" Then
               MessageBox(0, "", 158, 20110, "Error. HTML schema element mismatch.  Tree element %1.  HTML Schema element %2. Level %3. Row %4.", &telementtype, "CP", &level, &y);
               Return False;
            End-If;
            &comp = &htmldefinition.GetCompound(&ecount);
            &rec.IB_LSHTMLTAG.Value = &comp.TagName;
            
            If Not (getdochtmlschemareference(&rec.IB_LSSCHEMA.Value, &rec.IB_LSVARIANT.Value, &comp.HtmlSchema, &y, &level + 1, True, &rec.IB_PACKAGEID.Value, 0, &lsrec)) Then
               Return False;
            End-If;
            Break;
         When-Other
            MessageBox(0, "", 158, 20109, "Error.  Invalid HTML schema type %1.  Level %2.", &etype, &level);
            /* 244, 255 */
            Return False;
         End-Evaluate;
         &ecount = &ecount + 1;
      End-If;
   End-For;
   Return True;
End-Function;

/* Populate html schema fields in current tree. */
Function gethtmlschemareference(&schema As string, &variant As string, &htmlname As string, &seq As number, &level As number, &isref As boolean, &package As string, &lrow As number) Returns boolean
   Local Record &lsrec;
   &lsrec = GetLevel0().GetRow(1).GetRecord(Record.PSIBLOGICAL_WRK);
   Return getdochtmlschemareference(&schema, &variant, &htmlname, &seq, &level, &isref, &package, &lrow, &lsrec);
End-Function;

/* Populate xml schema fields in current tree. */
Function getjsonschemareference(&schema As string, &variant As string, &jsonname As string, &seq As number, &level As number, &isref As boolean, &package As string, &lrow As number) Returns boolean
   Local Record &lsrec;
   &lsrec = GetLevel0().GetRow(1).GetRecord(Record.PSIBLOGICAL_WRK);
   Return getdocjsonschemareference(&schema, &variant, &jsonname, &seq, &level, &isref, &package, &lrow, &lsrec);
End-Function;

/* Navigate the complex primitive at row &r and make sure that the element child's name
matches the compound name. */
Function setcomplexprimitivename(&rs As Rowset, &r As number, &cname As string)
   Local number &j, &lastrow;
   Local Record &mrec;
   
   If &r = &rs.ActiveRowCount Then
      Return;
   End-If;
   &lastrow = findlastrow(&rs, &r);
   
   For &j = &r + 1 To &lastrow
      &mrec = &rs.GetRow(&j).GetRecord(1);
      If &mrec.IB_LSELEMENTTYPE.Value = "PR" Then
         If (&mrec.IB_LSXMLNODETYPE.Value = "2" Or
               &mrec.IB_LSXMLNODETYPE.Value = "3") And
               &mrec.IB_LSITEMNAME.Value <> &cname Then
            &mrec.IB_LSITEMNAME.Value = &cname;
            &mrec.TREE_NODE.Value = &cname;
            /* If the row we are changing is the one being currently displayed, make sure the display matches the change. */
            If &j = &CROWNUM Then
               PSIBLOGSCHM_NDE.IB_LSITEMNAME.Value = &cname;
            End-If;
         End-If;
      End-If;
   End-For;
End-Function;

Function setrelprimitiverow(&rel As any, &rec As Record)
   Local string &recname, &fieldname;
   Local string &isKey;
   SQLExec("select 'Y' from pskeydefn where recname=:1 and fieldname=:2", &rec.IB_RECNAME.Value, &rec.IB_RECFLDNAME.Value, &isKey);
   &rel.appendprimitive(&rec.IB_RECNAME.Value, &rec.IB_RECFLDNAME.Value, All(&isKey));
End-Function;

Function setrelcompoundrow(&rel As any, &rec As Record, &relname As string)
   Local string &package, &schema, &variant;
   &package = &rec.IB_PACKAGEID.Value;
   &schema = &rec.IB_LSSCHEMA.Value;
   &variant = &rec.IB_LSVARIANT.Value;
   &rel.AppendCompound(&package, &schema, &variant, &relname);
End-Function;

Function setrelcollectionrow(&rel As any, &rec As Record, &relname As string, &nrs As Rowset, &trow As number, &xml As string)
   Local PT_SCHEMA:RelationalSchemaCollection &coll;
   
   &coll = &rel.AppendCollection();
   saverelcollection(&coll, &nrs, &rec, &trow, &relname, &xml);
End-Function;

Function saverelschema(&package As string, &schema As string, &variant As string, &nrs As Rowset, &wrec As Record, &xml As string, &relname As string) Returns number
   Local PT_SCHEMA:RelationalSchemaDefinition &reldefinition;
   Local boolean &ret;
   Local number &t;
   Local Record &rec;
   
   &reldefinition = create PT_SCHEMA:RelationalSchemaDefinition(&package, &schema, &variant, &relname);
   If Not &reldefinition.IsNew Then
      &ret = &reldefinition.Delete();
      &reldefinition = create PT_SCHEMA:RelationalSchemaDefinition(&package, &schema, &variant, &relname);
   End-If;
   
   /* Save Header fields. */
   &reldefinition.ObjectOwnerId = &wrec.OBJECTOWNERID.Value;
   &reldefinition.Label = &wrec.IB_RELLABEL.Value;
   &reldefinition.Description = &wrec.IB_RELDESCR.Value;
   &reldefinition.RecordName = &wrec.IB_RELRECNAME.Value;
   
   /* Save Tree data. */
   For &t = 1 To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&t).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = 2 Then
         Evaluate &rec.IB_LSELEMENTTYPE.Value
         When "PR"
            setrelprimitiverow(&reldefinition, &rec);
            Break;
         When "CL"
            setrelcollectionrow(&reldefinition, &rec, &relname, &nrs, &t, &xml);
            Break;
         When "CP"
            setrelcompoundrow(&reldefinition, &rec, &relname);
            Break;
         When-Other
            Error MsgGetText(244, 96, "Error. Function %1 invalid type %2.", "saverelschema", &rec.IB_LSELEMENTTYPE.Value);
            Exit;
         End-Evaluate;
      End-If;
   End-For;
   If &reldefinition.Save() Then
      Return 0;
   Else
      Return - 601;
   End-If;
End-Function;

/* Populate xml tag field with member name if left empty. Populate node type with the
default node type if left empty. Also track the number of attributes and return back to calling program. */
Function defaultxmlfields(&rs As Rowset) Returns number
   Local number &k;
   Local Record &source_r;
   Local number &attributecount;
   
   For &k = 1 To &rs.ActiveRowCount
      &source_r = &rs.GetRow(&k).GetRecord(1);
      
      /* Only process for items that are not part of a compound. */
      If None(&source_r.IB_LSADDCOMPCHILD.Value) And
            All(&source_r.IB_LSITEMNAME.Value) Then
         If None(&source_r.IB_LSXMLTAG.Value) Then
            If &source_r.IB_LSELEMENTTYPE.Value = "CL" Then
               &source_r.IB_LSXMLTAG.Value = &PSCOLXMLTAG;
            Else
               &source_r.IB_LSXMLTAG.Value = &source_r.IB_LSITEMNAME.Value;
            End-If;
         End-If;
         If None(&source_r.IB_LSXMLNODETYPE.Value) Then
            &source_r.IB_LSXMLNODETYPE.Value = PSIBLOGICAL_WRK.IB_LSXMLNODETYPE;
         End-If;
         If None(&source_r.IB_LSPRIMWHITESP.Value) Then
            If PSIBLOGICAL_WRK.IB_LSTRIMWHITE = "Y" Then
               &source_r.IB_LSPRIMWHITESP.Value = "1";
            Else
               &source_r.IB_LSPRIMWHITESP.Value = "0";
            End-If;
         End-If;
         If &source_r.IB_LSXMLNODETYPE.Value = "1" And
               &source_r.TREE_LEVEL_NUM.Value = 2 Then
            &attributecount = &attributecount + 1;
         End-If;
      End-If;
      /* For complex primitive compounds, make sure the element has the same name as the compound. */
      If &source_r.IB_LSELEMENTTYPE.Value = "CP" And
            &source_r.IB_ISCMPPRIM.Value = "1" Then
         setcomplexprimitivename(&rs, &k, &source_r.IB_LSITEMNAME.Value);
      End-If;
   End-For;
   Return &attributecount;
End-Function;

Function clearrelational(&rs As Rowset)
   Local number &r;
   Local Record &crec, &nrec;
   
   For &r = 1 To &rs.ActiveRowCount
      &crec = &rs.GetRow(&r).GetRecord(1);
      If &crec.TREE_LEVEL_NUM.Value = 2 Then
         If &crec.IB_LSELEMENTTYPE.Value = "PR" Then
            &crec.IB_RECNAME.Value = "";
            &crec.IB_RECFLDNAME.Value = "";
            &crec.IB_RECISKEY.Value = "N";
         End-If;
         If &crec.IB_LSELEMENTTYPE.Value = "CL" Then
            If &r <> &rs.ActiveRowCount Then
               &nrec = &rs.GetRow(&r + 1).GetRecord(1);
               If &nrec.IB_LSELEMENTTYPE.Value = "PR" Then
                  &nrec.IB_RECNAME.Value = "";
                  &nrec.IB_RECFLDNAME.Value = "";
                  &nrec.IB_RECISKEY.Value = "N";
               End-If;
            End-If;
         End-If;
      End-If;
   End-For;
End-Function;

Function setrelational(&rs As Rowset, &headerrecord As string)
   Local number &r;
   Local Record &crec, &nrec;
   
   For &r = 1 To &rs.ActiveRowCount
      &crec = &rs.GetRow(&r).GetRecord(1);
      If &crec.TREE_LEVEL_NUM.Value = 2 Then
         If &crec.IB_LSELEMENTTYPE.Value = "PR" Then
            If &crec.IB_RECNAME.Value <> &headerrecord Then
               &crec.IB_RECNAME.Value = &headerrecord;
               &crec.IB_RECFLDNAME.Value = "";
               &crec.IB_RECISKEY.Value = "N";
            End-If;
         End-If;
         If &crec.IB_LSELEMENTTYPE.Value = "CL" Then
            If &r <> &rs.ActiveRowCount Then
               &nrec = &rs.GetRow(&r + 1).GetRecord(1);
               If &nrec.IB_LSELEMENTTYPE.Value = "PR" Then
                  If &crec.IB_RECNAME.Value <> &headerrecord Then
                     &crec.IB_RECNAME.Value = &headerrecord;
                     &crec.IB_RECFLDNAME.Value = "";
                     &crec.IB_RECISKEY.Value = "N";
                  End-If;
               End-If;
            End-If;
         End-If;
      End-If;
   End-For;
End-Function;

/* For this alias check, we require both message and alias.  We will always have an alias on
these message documents. */
Function duplicatealias(&mname As string, &alias As string) Returns boolean
   Local number &cnt;
   SQLExec("select count(*) from psmsgdefn where msgname <> :1 and xmlalias = :2", &mname, &alias, &cnt);
   If &cnt > 0 Then
      Return True;
   Else
      SQLExec("select count(*) from psmsgdefn where msgname = :1", &alias, &cnt);
      If &cnt > 0 Then
         Return True;
      Else
         Return False;
      End-If;
   End-If;
End-Function;

Function isschemasaved(&pack As string, &schema As string, &variant As string) Returns boolean
   Local number &cnt;
   SQLExec("select count(*) from pslsdefn where ib_packageid = :1 and ib_schemaname = :2 and ib_variantname = :3", &pack, &schema, &variant, &cnt);
   If &cnt > 0 Then
      Return True;
   Else
      Return False;
   End-If;
End-Function;

/* 
Copy in the prefix and uri of referenced component.  If no prefix, make up prefix using keys.
Generated prefix returned in the &genprefix parameter.
*/
Function copyreferencedxmlnamespaces(&package As string, &schema As string, &variant As string, &xmlname As string, &nrs As Rowset, &genprefix As string) Returns boolean
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition;
   Local PT_SCHEMA:XmlSchemaNamespace &targetnamespace;
   Local number &y;
   Local string &prefix, &uri;
   
   &xmldefinition = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &xmlname);
   If &xmldefinition.IsNew Then
      Return False;
   End-If;
   &targetnamespace = &xmldefinition.GetTargetNamespace();
   If &targetnamespace <> Null Then
      &prefix = &targetnamespace.Prefix;
      &uri = &targetnamespace.Uri;
      If None(&prefix) Then
         &prefix = &package | "." | &schema | "." | &variant;
      End-If;
      &genprefix = &prefix;
      If All(&uri) Then
         If Not namespaceisduplicate(&nrs, &prefix, &uri) Then
            insnamespacerow(&nrs, &prefix, &uri);
         End-If;
      End-If;
   End-If;
   Return True;
End-Function;

/* Check to make sure any namespace prefixes don't clash with current set. */
Function checkreferencedxmlnamespaces(&package As string, &schema As string, &variant As string, &xmlname As string, &nrs As Rowset) Returns boolean
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition;
   Local PT_SCHEMA:XmlSchemaNamespace &targetnamespace;
   Local number &y;
   Local string &prefix, &uri;
   
   &xmldefinition = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &xmlname);
   If &xmldefinition.IsNew Then
      Return False;
   End-If;
   For &y = 1 To &xmldefinition.GetImportedNamespacesCount()
      &targetnamespace = &xmldefinition.GetImportedNamespaces(&y);
      If &targetnamespace <> Null Then
         &prefix = &targetnamespace.Prefix;
         &uri = &targetnamespace.Uri;
         If All(&prefix) Then
            If namespaceisduplicate(&nrs, &prefix, &uri) Then
               Return False;
            End-If;
         End-If;
      End-If;
   End-For;
   Return True;
End-Function;

Function getLogicalAndSchemaDetails(&package As string, &schema As string, &variant As string, &xmlname As string, &prefix As string, &nonamespace As string, &roottag As string, &rootelement As string)
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition;
   Local PT_SCHEMA:LogicalSchemaDefinition &lsdefinition;
   Local PT_SCHEMA:XmlSchemaNamespace &targetnamespace;
   
   &xmldefinition = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &xmlname);
   If &xmldefinition.IsNew Then
      Return;
   End-If;
   
   &prefix = "";
   &nonamespace = BooltoYN(&xmldefinition.NoTargetNamespace);
   &targetnamespace = &xmldefinition.GetTargetNamespace();
   If &targetnamespace <> Null Then
      &prefix = &targetnamespace.Prefix;
   End-If;
   &roottag = &xmldefinition.Label;
   
   &lsdefinition = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
   If &lsdefinition.IsNew Then
      Return;
   End-If;
   
   &rootelement = &lsdefinition.Label;
End-Function;

/* Make sure new message name/version combo does not already exist. */
Function validatenewmessage(&msgname As string, &msgver As string) Returns boolean
   Local number &cnt;
   
   SQLExec("select count(*) from psmsgver where msgname = :1 and apmsgver = :2", &msgname, &msgver, &cnt);
   If &cnt > 0 Then
      Return False;
   End-If;
   Return True;
End-Function;

/* ******************************************************************************************************** */
/* API for dynamically creating documents. */
/* ******************************************************************************************************** */
/* ******************************************************************************************************** */

Function numberofchildren(&r As Rowset, &crnum As number) Returns number
   Local number &clevel, &y, &num;
   Local Record &crec;
   
   If &crnum >= &r.ActiveRowCount Then
      Return 0
   End-If;
   &clevel = &r.GetRow(&crnum).GetRecord(1).TREE_LEVEL_NUM.Value;
   For &y = &crnum + 1 To &r.ActiveRowCount
      &crec = &r.GetRow(&y).GetRecord(1);
      If &crec.TREE_LEVEL_NUM.Value = &clevel + 1 Then
         &num = &num + 1;
      Else
         Return &num;
      End-If;
   End-For;
   Return &num;
End-Function;

/* Basic rowset checks to make sure the rowset complies to the basic necessary structure. */
Function checkrowsetforerrors(&r As Rowset, &bShowMessages As boolean) Returns number
   Local number &x, &numchild;
   Local Record &xrec, &nrec;
   Local boolean &blastrow;
   
   For &x = 1 To &r.ActiveRowCount
      &xrec = &r.GetRow(&x).GetRecord(Record.PSIBLOGSCHM_NDE);
      If &x < &r.ActiveRowCount Then
         &nrec = &r.GetRow(&x + 1).GetRecord(Record.PSIBLOGSCHM_NDE);
         &blastrow = False;
      Else
         &blastrow = True;
      End-If;
      
      If Not &blastrow Then
         If &nrec.TREE_LEVEL_NUM.Value <> &xrec.TREE_LEVEL_NUM.Value + 1 And
               &nrec.TREE_LEVEL_NUM.Value > &xrec.TREE_LEVEL_NUM.Value Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 130, "Error. Found orphan child. A parent row exists with a next row level greater than parent + 1.");
            End-If;
            Return - 50
         End-If;
      End-If;
      
      If None(&xrec.IB_ISREQUIRED.Value) Then
         &xrec.IB_ISREQUIRED.Value = "N";
      End-If;
      
      If &xrec.TREE_LEVEL_NUM.Value < 2 Then
         If &bShowMessages Then
            MessageBox(0, "", 244, 131, "Error. Level number less than 2.");
         End-If;
         Return - 51;
      End-If;
      If None(&xrec.IB_LSITEMNAME.Value) Then
         If &bShowMessages Then
            MessageBox(0, "", 244, 132, "Error. Missing element name.");
         End-If;
         Return - 52;
      End-If;
      If &xrec.IB_LSELEMENTTYPE.Value <> "PR" And
            &xrec.IB_LSELEMENTTYPE.Value <> "CL" And
            &xrec.IB_LSELEMENTTYPE.Value <> "CP" Then
         If &bShowMessages Then
            MessageBox(0, "", 244, 133, "Error. Invalid element type %1.", &xrec.IB_LSELEMENTTYPE.Value);
         End-If;
         Return - 53;
      End-If;
      If &xrec.IB_LSELEMENTTYPE.Value = "PR" Then
         If None(&xrec.IB_LSITEMTYPE.Value) Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 86, "Error. Missing type for primitive element %1.", &xrec.IB_LSITEMNAME.Value);
            End-If;
            Return - 54;
         End-If;
         If Not &blastrow Then
            If &nrec.TREE_LEVEL_NUM.Value > &xrec.TREE_LEVEL_NUM.Value Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 134, "Error. Found primitive element %1 with a child.", &xrec.IB_LSITEMNAME.Value);
               End-If;
               Return - 55;
            End-If;
         End-If;
         If &xrec.IB_LSXMLNODETYPE.Value <> "1" And
               &xrec.IB_LSXMLNODETYPE.Value <> "2" And
               &xrec.IB_LSXMLNODETYPE.Value <> "3" Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 135, "Error. Element %1 contains an invalid XML node type %2.  Must be 1, 2, or 3.", &xrec.IB_LSITEMNAME.Value, &xrec.IB_LSXMLNODETYPE.Value);
            End-If;
            Return - 56;
         End-If;
         If &xrec.IB_LSITEMTYPE.Value <> "BO" And
               &xrec.IB_LSITEMTYPE.Value <> "BI" And
               &xrec.IB_LSITEMTYPE.Value <> "CH" And
               &xrec.IB_LSITEMTYPE.Value <> "ST" And
               &xrec.IB_LSITEMTYPE.Value <> "IN" And
               &xrec.IB_LSITEMTYPE.Value <> "DE" And
               &xrec.IB_LSITEMTYPE.Value <> "DA" And
               &xrec.IB_LSITEMTYPE.Value <> "TI" And
               &xrec.IB_LSITEMTYPE.Value <> "DT" And
               &xrec.IB_LSITEMTYPE.Value <> "TE" Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 136, "Error. Invalid primitive type %1.", &xrec.IB_LSITEMTYPE.Value);
            End-If;
            Return - 57;
         End-If;
         If &xrec.IB_LSITEMTYPE.Value = "CH" Then
            &xrec.IB_LSLENGTH.Value = 1;
         End-If;
         If None(&xrec.IB_SCHEMAUNBOUND.Value) Then
            &xrec.IB_SCHEMAUNBOUND.Value = "N";
         End-If;
         If &xrec.IB_LSPRIMWHITESP.Value <> "1" Then
            &xrec.IB_LSPRIMWHITESP.Value = "0";
         End-If;
      End-If;
      
      If &xrec.IB_LSELEMENTTYPE.Value = "CP" Then
         If None(&xrec.IB_PACKAGEID.Value) Or
               None(&xrec.IB_LSSCHEMA.Value) Or
               None(&xrec.IB_LSVARIANT.Value) Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 137, "Error. Compound %1 missing a referenced document key.", &xrec.IB_LSITEMNAME.Value);
            End-If;
            Return - 58;
         End-If;
         If Not &blastrow Then
            If &nrec.TREE_LEVEL_NUM.Value > &xrec.TREE_LEVEL_NUM.Value And
                  &xrec.IB_ISCMPPRIM.Value <> "1" Then
               If &bShowMessages Then
                  MessageBox(0, "", 244, 138, "Error. Compound %1 contains a child element.", &xrec.IB_LSITEMNAME.Value);
               End-If;
               Return - 59;
            End-If;
         End-If;
      End-If;
      
      If &xrec.IB_LSELEMENTTYPE.Value = "CL" Then
         If &blastrow Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 139, "Error. Collection %1 found as the last row.", &xrec.IB_LSITEMNAME.Value);
            End-If;
            Return - 60;
         End-If;
         If &nrec.TREE_LEVEL_NUM.Value <> &xrec.TREE_LEVEL_NUM.Value + 1 Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 140, "Error. Found collection %1 with child having an invalid level number.", &xrec.IB_LSITEMNAME.Value);
            End-If;
            Return - 61;
         End-If;
         &numchild = numberofchildren(&r, &x);
         If &numchild > 1 Or
               &numchild = 0 Then
            If &bShowMessages Then
               MessageBox(0, "", 244, 141, "Error. Found collection %1 with either no child or more than one child.");
            End-If;
            Return - 62;
         End-If;
      End-If;
   End-For;
   Return 0;
End-Function;

Function removeimportednamespace(&nrs As Rowset, &package As string, &schema As string, &variant As string, &xml As string)
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition5;
   Local PT_SCHEMA:XmlSchemaNamespace &targetnamespace5;
   Local string &prefix, &uri;
   Local number &g;
   Local Row &grow;
   
   If None(&package) Or
         None(&schema) Or
         None(&variant) Then
      Return;
   End-If;
   
   &xmldefinition5 = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &XMLNAME);
   If &xmldefinition5.IsNew Then
      Return;
   End-If;
   
   &targetnamespace5 = &xmldefinition5.GetTargetNamespace();
   
   If &targetnamespace5 <> Null Then
      &prefix = &targetnamespace5.Prefix;
      &uri = &targetnamespace5.Uri;
   Else
      Return;
   End-If;
   
   If None(&prefix) Then
      &prefix = &package | "." | &schema | "." | &variant;
   End-If;
   
   If &nrs <> Null Then
      For &g = &nrs.ActiveRowCount To 1 Step - 1
         &grow = &nrs.GetRow(&g);
         If &grow.PSLSIMPNMSPC_VW.IB_LSIMPPREFIX.Value = &prefix And
               &grow.PSLSIMPNMSPC_VW.IB_LSIMPURI.Value = &uri Then
            &nrs.DeleteRow(&g);
         End-If;
      End-For;
   End-If;
End-Function;

Function insertdeletelist(&package As string, &schema As string, &variant As string)
   Local Rowset &rs;
   Local number &x;
   Local Record &rec;
   
   &rs = GetLevel0().GetRow(1).GetRowset(Scroll.PSIBDOCLIST_VW);
   If None(&package) Or
         None(&schema) Or
         None(&variant) Then
      Return;
   End-If;
   /* Check for duplicates. */
   For &x = 1 To &rs.ActiveRowCount
      &rec = &rs.GetRow(&x).GetRecord(1);
      If &rec.IB_EXTPACKAGEID.Value = &package And
            &rec.IB_EXTSCHEMANAME.Value = &schema And
            &rec.IB_EXTVARIANTNAME.Value = &variant Then
         Return;
      End-If;
   End-For;
   If All(&rs.GetRow(&rs.ActiveRowCount).GetRecord(1).IB_EXTSCHEMANAME.Value) Then
      &rs.InsertRow(&rs.ActiveRowCount);
   End-If;
   &rec = &rs.GetRow(&rs.ActiveRowCount).GetRecord(1);
   &rec.IB_EXTPACKAGEID.Value = &package;
   &rec.IB_EXTSCHEMANAME.Value = &schema;
   &rec.IB_EXTVARIANTNAME.Value = &variant;
End-Function;

/* Check to see if the document is referenced in another document. */
Function isdocumentreferenced(&package As string, &schema As string, &variant As string) Returns boolean
   Local number &c;
   SQLExec("select count(*) from pslsdepchlddfn where ib_extpackageid = :1 and ib_extschemaname = :2 and ib_extvariantname = :3", &package, &schema, &variant, &c);
   If &c > 0 Then
      Return True;
   Else
      Return False;
   End-If;
End-Function;

/* Check to see if the document is referenced by a layout. */
Function islayoutreferenced(&package As string, &schema As string, &variant As string) Returns boolean
   Local number &c;
   Local SQL &sql;
   Local string &pa_package, &pa_schema, &pa_variant, &exists;
   
   SQLExec("select 'X' from PSDOCLODEFN where IB_PACKAGEID = :1 and IB_SCHEMANAME = :2 and IB_VARIANTNAME = :3", &package, &schema, &variant, &exists);
   If All(&exists) Then
      Return True;
   End-If;
   
   /*** Check parent documents too for layout references ***/
   &sql = CreateSQL("select IB_PACKAGEID, IB_SCHEMANAME, IB_VARIANTNAME from PSLSDEPCHLDDFN where IB_EXTPACKAGEID = :1 and IB_EXTSCHEMANAME = :2 and IB_EXTVARIANTNAME = :3", &package, &schema, &variant);
   While &sql.Fetch(&pa_package, &pa_schema, &pa_variant)
      SQLExec("select 'X' from PSDOCLODEFN where IB_PACKAGEID = :1 and IB_SCHEMANAME = :2 and IB_VARIANTNAME = :3", &pa_package, &pa_schema, &pa_variant, &exists);
      If All(&exists) Then
         Return True;
      End-If;
   End-While;
   Return False;
End-Function;

/* Check to see if the document is autogenerated. */
Function isdocumentautogenerated(&package As string, &schema As string, &variant As string) Returns boolean
   Local number &c;
   SQLExec("select count(*) from pslsdefn where ib_packageid = :1 and ib_schemaname = :2 and ib_variantname = :3 and ib_autogenerated = 1", &package, &schema, &variant, &c);
   If &c > 0 Then
      Return True;
   Else
      Return False;
   End-If;
End-Function;

/* Check to see if the document is referenced by other objects. */
Function isdocumentmetadataref Returns boolean
   Local Row &krow;
   Local Rowset &krs;
   
   &krs = GetLevel0().GetRow(1).GetRowset(Scroll.PSIBLSREF_VW);
   &krow = &krs.GetRow(1);
   
   If All(&krow.GetRecord(Record.PSIBLSREF_VW).IB_METADATAITEM.Value) Then
      Return True;
   End-If;
   Return False;
End-Function;

Function deleterelationalobject(&package As string, &schema As string, &variant As string) Returns boolean
   Local PT_SCHEMA:RelationalSchemaDefinition &reldefinition;
   &reldefinition = create PT_SCHEMA:RelationalSchemaDefinition(&package, &schema, &variant, &RELATIONALNAME);
   Return &reldefinition.Delete();
End-Function;

Function deletecomplexcompounds(&package As string, &schema As string, &variant As string)
   Local PT_SCHEMA:LogicalSchemaDefinition &dlsdefinition, &dlsdefinition2;
   Local PT_SCHEMA:LogicalSchemaCompound &dcomp;
   Local string &etype, &rpackage, &rschema, &rvariant;
   Local number &y;
   Local boolean &bRet;
   Local PT_SCHEMA:LogicalSchemaCollection &collec;
   Local PT_SCHEMA:LogicalSchemaCompound &dcompc;
   Local string &rpackagec, &rschemac, &rvariantc;
   Local PT_SCHEMA:LogicalSchemaDefinition &dlsdefinition3;
   
   &dlsdefinition = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
   If &dlsdefinition.IsNew Then
      Return;
   End-If;
   
   For &y = 1 To &dlsdefinition.GetElementCount()
      &etype = &dlsdefinition.GetElementType(&y);
      Evaluate &etype
      When &LS_CONSTANTS.ELEMENT_TYPE_COLLECTION
         &collec = &dlsdefinition.GetCollection(&y);
         Evaluate &collec.GetElementType()
         When = &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
            &dcompc = &collec.GetCompound();
            &rpackagec = &dcompc.Package;
            &rschemac = &dcompc.LogicalSchema;
            &rvariantc = &dcompc.Variant;
            If isspecialcompound(&rpackagec, &rschemac, &rvariantc) Then
               &dlsdefinition3 = create PT_SCHEMA:LogicalSchemaDefinition(&rpackagec, &rschemac, &rvariantc);
               If Not &dlsdefinition3.IsNew Then
                  &bRet = &dlsdefinition3.Delete();
               End-If;
            End-If;
            Break;
         End-Evaluate;
         Break;
      When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
         &dcomp = &dlsdefinition.GetCompound(&y);
         &rpackage = &dcomp.Package;
         &rschema = &dcomp.LogicalSchema;
         &rvariant = &dcomp.Variant;
         If isspecialcompound(&rpackage, &rschema, &rvariant) Then
            &dlsdefinition2 = create PT_SCHEMA:LogicalSchemaDefinition(&rpackage, &rschema, &rvariant);
            If Not &dlsdefinition2.IsNew Then
               &bRet = &dlsdefinition2.Delete();
            End-If;
         End-If;
         Break;
      End-Evaluate;
   End-For;
End-Function;

Function deletedocumentobjectmain(&package As string, &schema As string, &variant As string, &delcomp As boolean, &forcedelete As boolean) Returns boolean
   Local PT_SCHEMA:LogicalSchemaDefinition &lsdefinition;
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition;
   Local PT_SCHEMA:RelationalSchemaDefinition &reldefinition;
   Local PT_SCHEMA:JsonSchemaDefinition &jsondefinition;
   Local PT_SCHEMA:HtmlSchemaDefinition &htmldefinition;
   
   Local SQL &childsql;
   
   Local PT_SCHEMA:DependencyDefn &lsdep;
   Local boolean &ret;
   Local string &bres;
   Local string &msgname, &apmsgver;
   Local string &extpkg, &extsch, &extver;
   
   If None(&package) Or
         None(&schema) Or
         None(&variant) Then
      Return False;
   End-If;
   
   /* Delete child documents first */
   &childsql = CreateSQL("select IB_EXTPACKAGEID, IB_EXTSCHEMANAME, IB_EXTVARIANTNAME from PSLSDEPCHLDDFN where IB_PACKAGEID = :1 AND IB_SCHEMANAME = :2 AND IB_VARIANTNAME = :3", &package, &schema, &variant);
   
   While &childsql.Fetch(&extpkg, &extsch, &extver)
      &ret = deletedocumentobjectmain(&extpkg, &extsch, &extver, True, True);
   End-While;
   
   If Not isdocumentautogenerated(&package, &schema, &variant) And
         &forcedelete Then
      &forcedelete = False;
   End-If;
   
   /* Do not delete if item is referenced. */
   If Not (&forcedelete) And
         isdocumentreferenced(&package, &schema, &variant) Then
      Return False;
   End-If;
   
   &LS_CONSTANTS = create PT_SCHEMA:SchemaConstants();
   &XMLNAME = &LS_CONSTANTS.TYPE_XML;
   &JSONNAME = &LS_CONSTANTS.TYPE_JSON;
   &lsdefinition = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
   &xmldefinition = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &XMLNAME);
   &reldefinition = create PT_SCHEMA:RelationalSchemaDefinition(&package, &schema, &variant, &RELATIONALNAME);
   &jsondefinition = create PT_SCHEMA:JsonSchemaDefinition(&package, &schema, &variant, &JSONNAME);
   &htmldefinition = create PT_SCHEMA:HtmlSchemaDefinition(&package, &schema, &variant, &HTMLNAME);
   
   &lsdep = create PT_SCHEMA:DependencyDefn(&package, &schema, &variant);
   /*** Delete Document Schema ***/
   &ret = %IntBroker.DeleteDocSchema(CreateKey(&package, &schema, &variant));
   
   If Not &xmldefinition.IsNew Then
      &ret = &xmldefinition.Delete();
   End-If;
   If Not &reldefinition.IsNew Then
      &ret = &reldefinition.Delete();
   End-If;
   If Not &jsondefinition.IsNew Then
      &ret = &jsondefinition.Delete();
   End-If;
   If Not &htmldefinition.IsNew Then
      &ret = &htmldefinition.Delete();
   End-If;
   If Not &lsdefinition.IsNew Then
      If &delcomp Then
         deletecomplexcompounds(&package, &schema, &variant);
      End-If;
      &ret = &lsdefinition.Delete();
   End-If;
   If Not &lsdep.IsNew Then
      &ret = &lsdep.Delete();
   End-If;
   
   Return True;
End-Function;

Function deletedocumentobject(&package As string, &schema As string, &variant As string) Returns boolean
   Return deletedocumentobjectmain(&package, &schema, &variant, True, False);
End-Function;

/* Clean out all documents in current database. */
Function deletealldocuments()
   Local SQL &MYSQL;
   Local boolean &bret;
   Local string &package, &schema, &variant;
   
   &MYSQL = CreateSQL("select ib_packageid, ib_schemaname, ib_variantname from pslsdefn");
   While &MYSQL.Fetch(&package, &schema, &variant)
      &bret = deletedocumentobject(&package, &schema, &variant);
   End-While;
End-Function;

Function insoutrow(&r As Rowset, &d As string)
   Local Record &rec;
   If All(&r.GetRow(&r.ActiveRowCount).GetRecord(1).IB_NOTE.Value) Then
      &r.InsertRow(&r.ActiveRowCount);
   End-If;
   &rec = &r.GetRow(&r.ActiveRowCount).GetRecord(1);
   &rec.IB_NOTE.Value = &d;
End-Function;

/* This method is only used for analysis. */
Function getprimitivetypetext(&p As number) Returns string
   Local string &ttext;
   &ttext = "";
   Evaluate &p
   When %Document_Boolean
      SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'BO'", &ttext);
   When %Document_Time
      SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'TI'", &ttext);
      Break;
   When %Document_DateTime
      SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'DT'", &ttext);
      Break;
   When %Document_Text
      SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'TE'", &ttext);
      Break;
   When %Document_Binary
      rem SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'BI'", &ttext);
      Break;
   When %Document_String
      SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'ST'", &ttext);
      Break;
   When %Document_Char
      SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'CH'", &ttext);
      Break;
   When %Document_Integer
      SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'IN'", &ttext);
      Break;
   When %Document_Decimal
      SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'DE'", &ttext);
      Break;
   When %Document_Date
      SQLExec("select xlatshortname from psxlatitem where fieldname = 'IB_LSITEMTYPE' and fieldvalue = 'DA'", &ttext);
      Break;
   End-Evaluate;
   Return &ttext;
End-Function;

/* &nrs is populated with the contents of the Document and the related XML Document. The rowset must contain field IB_NOTE. 
This is for rowset output.  No translation impact with hard-coded text. */
Function analyzedocumentobject(&package As string, &schema As string, &variant As string, &nrs As Rowset) Returns boolean
   Local PT_SCHEMA:LogicalSchemaDefinition &lsdefinition;
   Local PT_SCHEMA:LogicalSchemaPrimitive &prim;
   Local PT_SCHEMA:LogicalSchemaCollection &coll, &coll2;
   Local PT_SCHEMA:LogicalSchemaCompound &comp;
   Local PT_SCHEMA:XmlSchemaDefinition &xmldefinition;
   Local PT_SCHEMA:XmlSchemaPrimitive &xprim;
   Local PT_SCHEMA:XmlSchemaCollection &xcoll;
   Local PT_SCHEMA:XmlSchemaCompound &xcomp;
   
   Local number &y;
   Local string &etype, &cstr;
   Local string &blanks;
   
   If None(&package) Or
         None(&schema) Or
         None(&variant) Then
      Return False;
   End-If;
   
   &lsdefinition = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
   If &lsdefinition.IsNew Then
      Return False;
   End-If;
   
   &LS_CONSTANTS = create PT_SCHEMA:SchemaConstants();
   &XMLNAME = &LS_CONSTANTS.TYPE_XML;
   &JSONNAME = &LS_CONSTANTS.TYPE_JSON;
   &nrs.Flush();
   &blanks = "     ";
   insoutrow(&nrs, MsgGetText(244, 149, "Document"));
   insoutrow(&nrs, &package | " " | &schema | " " | &variant);
   For &y = 1 To &lsdefinition.GetElementCount()
      &etype = &lsdefinition.GetElementType(&y);
      Evaluate &etype
      When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
         &prim = &lsdefinition.GetPrimitive(&y);
         insoutrow(&nrs, &blanks | MsgGetText(244, 142, "Primitive" | ":" | &prim.Name));
         Break;
      When &LS_CONSTANTS.ELEMENT_TYPE_COLLECTION
         &coll = &lsdefinition.GetCollection(&y);
         Evaluate &coll.GetElementType()
         When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
            &prim = &coll.GetPrimitive();
            &cstr = " " | MsgGetText(244, 142, "Primitive") | ":" | &prim.Name;
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
            &comp = &coll.GetCompound();
            &cstr = " " | MsgGetText(244, 144, "Compound") | ":" | &comp.Name | " " | &comp.Package | " " | &comp.LogicalSchema | " " | &comp.Variant;
            Break;
         End-Evaluate;
         insoutrow(&nrs, &blanks | MsgGetText(244, 143, "Collection") | ":" | &coll.Name | " " | &cstr);
         Break;
      When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
         &comp = &lsdefinition.GetCompound(&y);
         insoutrow(&nrs, &blanks | MsgGetText(244, 144, "Compound") | ":" | &comp.Name | " " | &comp.Package | " " | &comp.LogicalSchema | " " | &comp.Variant);
         Break;
      End-Evaluate;
   End-For;
   
   &xmldefinition = create PT_SCHEMA:XmlSchemaDefinition(&package, &schema, &variant, &XMLNAME);
   If &xmldefinition.IsNew Then
      Return False;
   End-If;
   
   insoutrow(&nrs, "XML");
   For &y = 1 To &xmldefinition.GetElementCount()
      &etype = &xmldefinition.GetElementType(&y);
      Evaluate &etype
      When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
         &xprim = &xmldefinition.GetPrimitive(&y);
         insoutrow(&nrs, &blanks | MsgGetText(244, 146, "XML Primitive") | ":" | &xprim.TagName);
         Break;
      When &LS_CONSTANTS.ELEMENT_TYPE_COLLECTION
         &xcoll = &xmldefinition.GetCollection(&y);
         Evaluate &xcoll.GetElementType()
         When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
            &xprim = &xcoll.GetPrimitive();
            &cstr = " " | MsgGetText(244, 146, "XML Primitive") | ":" | &xprim.TagName;
            Break;
         When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
            &xcomp = &xcoll.GetCompound();
            &cstr = " " | MsgGetText(244, 148, "XML Compound") | ":" | &xcomp.TagName | " " | &xcomp.Package | " " | &xcomp.LogicalSchema | " " | &xcomp.Variant;
            Break;
         End-Evaluate;
         insoutrow(&nrs, &blanks | MsgGetText(244, 147, "XML Collection") | ":" | &xcoll.TagName | " " | &cstr);
         Break;
      When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
         &xcomp = &xmldefinition.GetCompound(&y);
         insoutrow(&nrs, &blanks | MsgGetText(244, 148, "XML Compound") | ":" | &xcomp.TagName | " " | &xcomp.Package | " " | &xcomp.LogicalSchema | " " | &xcomp.Variant);
         Break;
      End-Evaluate;
   End-For;
   Return True;
End-Function;

/* Takes a rowset as input and returns a string representation of the rowset rows.  Rowset must include field IB_NOTE. */
Function docrowsettostring(&nrs As Rowset, &rstr As string)
   Local number &y;
   Local Record &rec;
   Local string &CRLF;
   
   &rstr = "";
   &CRLF = Char(13) | Char(10);
   For &y = 1 To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&y).GetRecord(1);
      &rstr = &rstr | &rec.IB_NOTE.Value | &CRLF;
   End-For;
End-Function;

/* Traverse an object of type Compound and return as a string for analysis. */
Function traversecompoundtotext(&CP As Compound, &rstr As string, &level As number)
   Local number &x;
   Local number &etype;
   Local Primitive &PRIM;
   Local Compound &COMP;
   Local Collection &COLL;
   Local string &ttext;
   Local string &CRLF;
   Local string &spaces;
   
   For &x = 1 To &level
      &spaces = &spaces | "  ";
   End-For;
   &spaces = &level | "-" | &spaces;
   
   &CRLF = Char(13) | Char(10);
   
   For &x = 1 To &CP.PropertyCount
      &etype = &CP.GetPropertyByIndex(&x).ElementType;
      
      Evaluate &etype
      When %Document_Primitive
         &PRIM = &CP.GetPropertyByIndex(&x);
         &ttext = getprimitivetypetext(&PRIM.PrimitiveType);
         &rstr = &rstr | &spaces | MsgGetText(244, 142, "Primitive") | ":" | &PRIM.Name | " " | &ttext | &CRLF;
         Break;
      When %Document_Compound
         &COMP = &CP.GetPropertyByIndex(&x);
         &rstr = &rstr | &spaces | MsgGetText(244, 144, "Compound") | ":" | &COMP.Name | " " | &COMP.PropertyCount | &CRLF;
         traversecompoundtotext(&COMP, &rstr, &level + 1);
         Break;
      When %Document_Collection
         &COLL = &CP.GetPropertyByIndex(&x);
         &rstr = &rstr | &spaces | MsgGetText(244, 143, "Collection") | ":" | &COLL.Name | " " | &COLL.DefinedMinOccurs | " " | &COLL.DefinedMaxOccurs | &CRLF;
         &EL = &COLL.CreateItem();
         Evaluate &EL.ElementType
         When %Document_Primitive
            /* EL is a primitive. */
            &ttext = getprimitivetypetext(&EL.PrimitiveType);
            &rstr = &rstr | &spaces | " " | MsgGetText(244, 142, "Primitive") | ":" | &EL.Name | " " | &ttext | &CRLF;
            Break;
         When %Document_Compound
            /* EL is a compound. */
            &rstr = &rstr | &spaces | " " | MsgGetText(244, 144, "Compound") | ":" | &EL.Name | " " | &EL.PropertyCount | &CRLF;
            traversecompoundtotext(&EL, &rstr, &level + 1);
            Break;
         End-Evaluate;
         Break;
      End-Evaluate;
   End-For;
End-Function;

Function hidepagedata()
   Local Record &pagerec;
   &pagerec = GetLevel0().GetRow(1).GetRecord(Record.PSIBLOGSCHM_NDE);
   If %Page = "IB_LOGICALSCHEMA" Then
      hideallfields(&pagerec);
   End-If;
   If %Page = "IB_XMLSCHEMA" Then
      hideallxmlfields(&pagerec);
   End-If;
   If %Page = "IB_RELATSCHEMA" Then
      hideallrelfields(&pagerec);
   End-If;
   If %Page = "IB_JSONSCHEMA" Then
      hidealljsonfields(&pagerec);
   End-If;
   If %Page = "IB_HTMLSCHEMA" Then
      hideallhtmlfields(&pagerec);
   End-If;
End-Function;

Function copypagedata()
   Local Record &pagerec;
   Local Record &rec;
   /* Copy current object data back into tree. */
   &pagerec = GetLevel0().GetRow(1).GetRecord(Record.PSIBLOGSCHM_NDE);
   
   If &CROWNUM <> 0 And
         &CROWNUM <> 2 Then
      &rec = &NODERS.GetRow(&CROWNUM).GetRecord(1);
      If %Page = "IB_LOGICALSCHEMA" Then
         copyEnumToField(&pagerec);
         copydata(&rec, &pagerec);
      End-If;
      If %Page = "IB_XMLSCHEMA" Then
         copyxmldata(&rec, &pagerec);
      End-If;
      If %Page = "IB_RELATSCHEMA" Then
         copyreldata(&rec, &pagerec);
      End-If;
      If %Page = "IB_JSONSCHEMA" Then
         copyjsondata(&rec, &pagerec);
      End-If;
      If %Page = "IB_HTMLSCHEMA" Then
         copyhtmldata(&rec, &pagerec);
      End-If;
   End-If;
End-Function;

/* Object Deletion via straight SQL.  INTERNAL USE ONLY. */
Function documentrawdelete()
   /* Logical Document */
   SQLExec("delete from pslsdefn");
   SQLExec("delete from pslsdefnbody");
   SQLExec("delete from pslsdefnlang");
   SQLExec("delete from pslsdefndel");
   
   /* Physical Document */
   SQLExec("delete from pslsdefnname");
   SQLExec("delete from psphysschdefn");
   SQLExec("delete from psphysschbody");
   SQLExec("delete from psphysschdel");
   SQLExec("delete from psphysschlang");
   SQLExec("delete from psphysschname");
   
   /* Document schemas. */
   SQLExec("delete from psdocscmadata");
   SQLExec("delete from psdocscmadel");
   SQLExec("delete from psdocscmadfn");
   
   /* Dependencies */
   SQLExec("delete from pslsdepdefn");
   SQLExec("delete from pslsdepdefndel");
   SQLExec("delete from pslsdepdefnlang");
   SQLExec("delete from pslsdepchlddfn");
End-Function;

Function isparent(&rs As Rowset, &crownum As number) Returns boolean
   Local Row &crow, &nrow;
   
   If &crownum = &rs.ActiveRowCount Then
      Return False;
   End-If;
   /* At this point, there is always at least one row below &crownum. */
   &crow = &rs.GetRow(&crownum);
   &nrow = &rs.GetRow(&crownum + 1);
   If &nrow.GetRecord(1).TREE_LEVEL_NUM.Value = &crow.GetRecord(1).TREE_LEVEL_NUM.Value + 1 Then
      Return True;
   Else
      Return False;
   End-If;
End-Function;

Function clearcontainerflag(&package As string, &schema As string, &variant As string) Returns boolean
   Local PT_SCHEMA:LogicalSchemaDefinition &lsdefinition5;
   
   &lsdefinition5 = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
   If &lsdefinition5.IsNew Then
      Return True;
   End-If;
   &lsdefinition5.IsContainer = False;
   If &lsdefinition5.Save() Then
      Return True;
   Else
      Return False;
   End-If;
End-Function;

/* When copying a document, the related complex primitives must be renamed. Pass in the range of rows to perform
the renaming.  For a full document rename, pass in 1 to rowset active row count. */
Function changecomplexschemanames(&cschema As string, &nrs As Rowset, &fromrow As number, &torow As number)
   Local number &r;
   Local Record &rec, &chrec;
   
   If None(&fromrow) Then
      &fromrow = 1;
   End-If;
   If None(&torow) Then
      &torow = &nrs.ActiveRowCount;
   End-If;
   
   For &r = &fromrow To &torow
      &rec = &nrs.GetRow(&r).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = 2 Then
         Evaluate &rec.IB_LSELEMENTTYPE.Value
         When "CP"
            If &rec.IB_ISCMPPRIM.Value = "1" Then
               &rec.IB_LSSCHEMA.Value = randomschemaname(&cschema);
            End-If;
            Break;
         When "CL"
            /* Get child row. */
            If &r + 1 <= &nrs.ActiveRowCount Then
               &chrec = &nrs.GetRow(&r + 1).GetRecord(1);
               If &chrec.IB_LSELEMENTTYPE.Value = "CP" And
                     &chrec.IB_ISCMPPRIM.Value = "1" Then
                  &chrec.IB_LSSCHEMA.Value = randomschemaname(&cschema);
               End-If;
            End-If;
         End-Evaluate;
      End-If;
   End-For;
End-Function;

/* Checks the passed in document to see if there is a recursive reference. If there is, the function returns false.
If everything is ok, return 1.  If there is a recursion problem, return 0.  If the maximum recursion is found, return -1. */
Function recursioncheckok(&level As number, &drs As Rowset, &package As string, &schema As string, &variant As string, &maxlevels As number) Returns number
   Local Rowset &d2rs;
   Local number &d, &d2, &nret;
   Local Record &drec, &drec2;
   
   /* Check to see if the object is in the passed rowset.  If it is, return false. */
   For &d = 1 To &drs.ActiveRowCount
      &drec = &drs.GetRow(&d).GetRecord(1);
      If &drec.IB_PACKAGEID3.Value = &package And
            &drec.IB_SCHEMANAME.Value = &schema And
            &drec.IB_VARIANTNAME.Value = &variant Then
         Return 0;
      End-If;
   End-For;
   
   If &level = &maxlevels Then
      Return - 1;
   End-If;
   
   /* Check the ancestors of each row in the rowset for recursion. */
   For &d = 1 To &drs.ActiveRowCount
      &drec = &drs.GetRow(&d).GetRecord(1);
      If All(&drec.IB_PACKAGEID3.Value) Then
         &d2rs = CreateRowset(Record.PSLSDEFREF_VW);
         &d2rs.Fill("where ib_extpackageid = :1 and ib_extschemaname = :2 and ib_extvariantname = :3", &drec.IB_PACKAGEID3.Value, &drec.IB_SCHEMANAME.Value, &drec.IB_VARIANTNAME.Value);
         For &d2 = 1 To &d2rs.ActiveRowCount
            &drec2 = &d2rs.GetRow(&d2).GetRecord(1);
            &nret = recursioncheckok(&level + 1, &d2rs, &package, &schema, &variant, &maxlevels);
            If &nret < 1 Then
               Return &nret;
            End-If;
         End-For;
      End-If;
   End-For;
   
   Return 1;
End-Function;

Function setjsonprimitive(&json As any, &rec As Record, &lastprim As boolean)
   Local string &tag;
   Local boolean &exp;
   
   &tag = &rec.IB_LSJSONTAG.Value;
   If None(&tag) Then
      &tag = &rec.IB_LSITEMNAME.Value;
   End-If;
   &exp = False;
   If &rec.IB_LSJSONEXP.Value = "Y" Then
      &exp = True;
   End-If;
   
   &json.AppendPrimitive(&tag, &exp, &lastprim);
End-Function;

Function sethtmlprimitive(&html As any, &rec As Record)
   Local string &tag;
   Local integer &type;
   
   &tag = &rec.IB_LSHTMLTAG.Value;
   If None(&tag) Then
      &tag = &rec.IB_LSITEMNAME.Value;
   End-If;
   &type = GetHTMLNumType(&rec.IB_LSHTMLTYPE.Value);
   &html.AppendPrimitive(&tag, &type);
End-Function;

Function setjsoncompound(&json As any, &rec As Record, &jsonschema As string, &lastseq As number, &isCompoundJSon As boolean, &upddoclist As array of string)
   Local string &tag, &jname;
   Local string &childschema, &childvariant, &childpackage;
   Local PT_SCHEMA:JsonSchemaDefinition &checkjsondefinition;
   Local Record &wrec = CreateRecord(Record.PSIBLOGICAL_WRK);
   
   &tag = &rec.IB_LSJSONTAG.Value;
   If None(&tag) Then
      &tag = &rec.IB_LSITEMNAME.Value;
   End-If;
   &childschema = &rec.IB_LSSCHEMA.Value;
   &childvariant = &rec.IB_LSVARIANT.Value;
   &childpackage = &rec.IB_PACKAGEID.Value;
   &json.AppendCompound(&tag, &lastseq, &childpackage, &childschema, &childvariant, &jsonschema);
   
   &checkjsondefinition = create PT_SCHEMA:JsonSchemaDefinition(&childpackage, &childschema, &childvariant, &jsonschema);
   
   /*** Design change - we are now resaving all the child documents - so &isCompound JSon is always true ***/
   &isCompoundJSon = True;
   If &upddoclist.Find(&childpackage | "." | &childschema | "." | &childvariant) = 0 Then
      &upddoclist.Push(&childpackage | "." | &childschema | "." | &childvariant);
   End-If;
End-Function;

Function sethtmlcompound(&html As any, &rec As Record, &htmlschema As string, &lastseq As number, &isCompoundHtml As boolean)
   Local string &tag, &jname;
   Local string &childschema, &childvariant, &childpackage;
   Local PT_SCHEMA:HtmlSchemaDefinition &checkhtmldefinition;
   Local Record &wrec = CreateRecord(Record.PSIBLOGICAL_WRK);
   
   &tag = &rec.IB_LSHTMLTAG.Value;
   If None(&tag) Then
      &tag = &rec.IB_LSITEMNAME.Value;
   End-If;
   &childschema = &rec.IB_LSSCHEMA.Value;
   &childvariant = &rec.IB_LSVARIANT.Value;
   &childpackage = &rec.IB_PACKAGEID.Value;
   &html.AppendCompound(&tag, &lastseq, &childpackage, &childschema, &childvariant, &htmlschema);
   
   &checkhtmldefinition = create PT_SCHEMA:HtmlSchemaDefinition(&childpackage, &childschema, &childvariant, &htmlschema);
   
   /*** Add code to save HTML of referenced document here ***/
   &isCompoundHtml = True;
End-Function;

Function setjsoncollection(&nrs As Rowset, &json As any, &rec As Record, &crow As number, &jsonschema As string, &lastseq As number, &isCompoundJSon As boolean, &upddoclist As array of string)
   Local string &tag;
   Local PT_SCHEMA:JsonSchemaCollection &coll;
   
   &tag = &rec.IB_LSJSONTAG.Value;
   If None(&tag) Then
      &tag = &PSCOLXMLTAG;
   End-If;
   
   &coll = &json.AppendCollection(&tag, &lastseq);
   savejsoncollection(&nrs, &coll, &rec, &crow, &jsonschema, &isCompoundJSon, &upddoclist);
End-Function;

Function sethtmlcollection(&nrs As Rowset, &html As any, &rec As Record, &crow As number, &htmlschema As string, &lastseq As number, &isCompoundHtml As boolean)
   Local string &tag;
   Local PT_SCHEMA:HtmlSchemaCollection &chtml;
   
   &tag = &rec.IB_LSHTMLTAG.Value;
   If None(&tag) Then
      &tag = &PSCOLHTMLTAG;
   End-If;
   
   &chtml = &html.AppendCollection(&tag, &lastseq);
   savehtmlcollection(&nrs, &chtml, &rec, &crow, &htmlschema, &isCompoundHtml);
End-Function;

Function jsondefined(&schema As string, &variant As string, &jsonschema As string, &package As string) Returns boolean
   Local PT_SCHEMA:JsonSchemaDefinition &jsondefinition;
   Local boolean &retval;
   
   &jsondefinition = create PT_SCHEMA:JsonSchemaDefinition(&package, &schema, &variant, &jsonschema);
   If &jsondefinition.IsNew Then
      &retval = &jsondefinition.Delete();
      Return False;
   End-If;
   Return True;
End-Function;

Function isAllCollection(&pos As number, &nrs As Rowset) Returns boolean
   Local Record &rec;
   Local number &idx;
   
   If &pos >= &nrs.ActiveRowCount Then
      Return False;
   End-If;
   For &idx = &pos To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&idx).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = 2 And
            &rec.IB_LSELEMENTTYPE.Value <> "CL" Then
         Return False;
      End-If;
   End-For;
   Return True;
End-Function;

Function savejsonschema(&schema As string, &variant As string, &jsonschema As string, &package As string, &nrs As Rowset, &nmrs As Rowset, &wrec As Record, &bShowMessages As boolean, &upddoclist As array of string) Returns number
   Local PT_SCHEMA:JsonSchemaDefinition &jsondefinition;
   Local number &t;
   Local Rowset &rs;
   Local Record &rec, &nextrec;
   Local boolean &retval;
   Local string &tschema;
   Local number &lastrow = 0;
   Local number &lastseq = 0;
   Local boolean &isCompoundJson = True;
   Local boolean &isChildJson = True;
   Local boolean &isLastPrimitive = False;
   
   &jsondefinition = create PT_SCHEMA:JsonSchemaDefinition(&package, &schema, &variant, &jsonschema);
   If Not &jsondefinition.IsNew Then
      &retval = &jsondefinition.Delete();
      &jsondefinition = create PT_SCHEMA:JsonSchemaDefinition(&package, &schema, &variant, &jsonschema);
   End-If;
   
   /* Save header fields. */
   If None(&wrec.IB_LSJSONLABEL.Value) Then
      &wrec.IB_LSJSONLABEL.Value = &schema;
   End-If;
   
   &jsondefinition.Description = &wrec.IB_DESCRLONG.Value;
   &jsondefinition.Label = &wrec.IB_LSJSONLABEL.Value;
   &jsondefinition.JsonName = &wrec.IB_LSJSONLABEL.Value;
   
   &jsondefinition.HideParentObject = True;
   If &wrec.IB_LSJSONHIDELBL.Value = "N" Then
      &jsondefinition.HideParentObject = False;
   End-If;
   
   /* Get the last element on level 2 */
   For &t = 1 To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&t).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = 2 Then
         &lastrow = &t;
      End-If;
   End-For;
   
   /* Save tree data. */
   For &t = 1 To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&t).GetRecord(1);
      &lastseq = 1;
      If &t = &lastrow Then
         &lastseq = 0;
      End-If;
      
      If &rec.TREE_LEVEL_NUM.Value = 2 Then
         /*** Check the next item to know if we are on the last primitive ***/
         &isLastPrimitive = isAllCollection(&t + 1, &nrs);
         Evaluate &rec.IB_LSELEMENTTYPE.Value
         When "PR"
            setjsonprimitive(&jsondefinition, &rec, &isLastPrimitive);
            Break;
         When "CL"
            setjsoncollection(&nrs, &jsondefinition, &rec, &t, &jsonschema, &lastseq, &isChildJson, &upddoclist);
            Break;
         When "CP"
            setjsoncompound(&jsondefinition, &rec, &jsonschema, &lastseq, &isChildJson, &upddoclist);
            If Not (&isChildJson) Then
               &isCompoundJson = False;
            End-If;
            Break;
         When-Other
            If &bShowMessages Then
               MessageBox(0, "", 244, 96, "Error. Function %1 invalid type %2.", "savejsonschema", &rec.IB_LSELEMENTTYPE.Value);
            End-If;
            Return - 602;
         End-Evaluate;
      End-If;
   End-For;
   
   If &jsondefinition.Save() Then
      Return 0;
   Else
      If &bShowMessages Then
         MessageBox(0, "", 244, 251, "Error saving JSON document.  Package %1 schema %2 version %3", &package, &schema, &variant);
      End-If;
      Return - 601;
   End-If;
End-Function;

Function savehtmlschema(&schema As string, &variant As string, &htmlschema As string, &package As string, &nrs As Rowset, &nmrs As Rowset, &wrec As Record, &bShowMessages As boolean) Returns number
   Local PT_SCHEMA:HtmlSchemaDefinition &htmldefinition;
   Local number &t;
   Local Rowset &rs;
   Local Record &rec;
   Local boolean &retval;
   Local string &tschema;
   Local number &lastrow = 0;
   Local number &lastseq = 0;
   Local boolean &isCompoundHtml = True;
   Local boolean &isChildHtml = True;
   
   &htmldefinition = create PT_SCHEMA:HtmlSchemaDefinition(&package, &schema, &variant, &htmlschema);
   If Not &htmldefinition.IsNew Then
      &retval = &htmldefinition.Delete();
      &htmldefinition = create PT_SCHEMA:HtmlSchemaDefinition(&package, &schema, &variant, &htmlschema);
   End-If;
   
   /* Save header fields. */
   If None(&wrec.IB_LSHTMLLABEL.Value) Then
      &wrec.IB_LSHTMLLABEL.Value = &schema;
   End-If;
   
   rem &htmldefinition.Description = &wrec.IB_DESCRLONG.Value;
   &htmldefinition.Label = &wrec.IB_LSHTMLLABEL.Value;
   &htmldefinition.HtmlName = &wrec.IB_LSHTMLLABEL.Value;
   
   /* Get the last element on level 2 */
   For &t = 1 To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&t).GetRecord(1);
      If &rec.TREE_LEVEL_NUM.Value = 2 Then
         &lastrow = &t;
      End-If;
   End-For;
   
   /* Save tree data. */
   For &t = 1 To &nrs.ActiveRowCount
      &rec = &nrs.GetRow(&t).GetRecord(1);
      &lastseq = 1;
      If &t = &lastrow Then
         &lastseq = 0;
      End-If;
      
      If &rec.TREE_LEVEL_NUM.Value = 2 Then
         Evaluate &rec.IB_LSELEMENTTYPE.Value
         When "PR"
            sethtmlprimitive(&htmldefinition, &rec);
            Break;
         When "CL"
            sethtmlcollection(&nrs, &htmldefinition, &rec, &t, &htmlschema, &lastseq, &isChildHtml);
            Break;
         When "CP"
            sethtmlcompound(&htmldefinition, &rec, &htmlschema, &lastseq, &isChildHtml);
            Break;
         When-Other
            If &bShowMessages Then
               MessageBox(0, "", 158, 20107, "Error. Function %1 invalid type %2.", "savehtmlschema", &rec.IB_LSELEMENTTYPE.Value);
            End-If;
            Return - 702;
         End-Evaluate;
      End-If;
   End-For;
   
   If &htmldefinition.Save() Then
      Return 0;
   Else
      If &bShowMessages Then
         MessageBox(0, "", 158, 20108, "Error saving HTML document.  Package %1 schema %2 version %3.", &package, &schema, &variant);
      End-If;
      Return - 701;
   End-If;
End-Function;

Function buildjsonschema(&schema As string, &variant As string, &jsonschema As string, &package As string) Returns boolean
   Local number &y;
   Local string &etype, &nextetype;
   Local PT_SCHEMA:LogicalSchemaDefinition &lsdefinition;
   Local PT_SCHEMA:JsonSchemaDefinition &jsondefinition;
   Local PT_SCHEMA:LogicalSchemaPrimitive &prim;
   Local PT_SCHEMA:JsonSchemaPrimitive &jprim;
   Local PT_SCHEMA:LogicalSchemaCollection &coll;
   Local PT_SCHEMA:JsonSchemaCollection &jcoll;
   Local PT_SCHEMA:LogicalSchemaCompound &comp;
   Local PT_SCHEMA:JsonSchemaCompound &jcomp;
   Local number &numelements;
   Local number &lastrow = 0;
   Local boolean &retval;
   Local boolean &lastprim = False;
   
   /*** Get Logical Schema Definition ***/
   &lsdefinition = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
   rem   &lsdefinition.Debug();
   If &lsdefinition.IsNew Then
      Return False;
   End-If;
   
   /*** Get JSON Definition - Rebuild if it exists ***/
   &jsondefinition = create PT_SCHEMA:JsonSchemaDefinition(&package, &schema, &variant, &jsonschema);
   If Not &jsondefinition.IsNew Then
      &retval = &jsondefinition.Delete();
      &jsondefinition = create PT_SCHEMA:JsonSchemaDefinition(&package, &schema, &variant, &jsonschema);
   End-If;
   
   /*** Set JSON Properties ***/
   &jsondefinition.JsonName = &schema;
   &jsondefinition.Label = &schema;
   &jsondefinition.Description = "";
   
   /*** Get all Logical Definition Contents and create JSON components ***/
   &numelements = &lsdefinition.GetElementCount();
   For &y = 1 To &lsdefinition.GetElementCount()
      &etype = &lsdefinition.GetElementType(&y);
      
      If &y = &numelements Then
         &lastrow = 1;
      Else
         &lastrow = 0;
      End-If;
      
      &lastprim = False;
      If &y + 1 <= &lsdefinition.GetElementCount() Then
         &nextetype = &lsdefinition.GetElementType(&y + 1);
         If &etype = &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE And
               &nextetype <> &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE Then
            &lastprim = True;
         End-If;
      End-If;
      
      If &y = &lsdefinition.GetElementCount() Then
         &lastprim = True;
      End-If;
      
      Evaluate &etype
      When &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
         &prim = &lsdefinition.GetPrimitive(&y);
         &jsondefinition.AppendPrimitive(&prim.Name, False, &lastprim);
         Break;
      When &LS_CONSTANTS.ELEMENT_TYPE_COLLECTION
         &coll = &lsdefinition.GetCollection(&y);
         &jcoll = &jsondefinition.AppendCollection(&coll.Name, &lastrow);
         
         /* Collection Has a Single Child - Primitive or Compound only. */
         Evaluate &coll.GetElementType()
         When = &LS_CONSTANTS.ELEMENT_TYPE_PRIMITIVE
            &prim = &coll.GetPrimitive();
            &jcoll.AppendPrimitive(&prim.Name, False, False);
            Break;
         When = &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
            &comp = &coll.GetCompound();
            &jcomp = &jcoll.AppendCompound(&comp.Name, &lastrow, &comp.Package, &comp.LogicalSchema, &comp.Variant, &jsonschema);
            If Not jsondefined(&comp.LogicalSchema, &comp.Variant, &jsonschema, &comp.Package) Then
               &retval = buildjsonschema(&comp.LogicalSchema, &comp.Variant, &jsonschema, &comp.Package);
            End-If;
            Break;
         End-Evaluate;
         Break;
      When &LS_CONSTANTS.ELEMENT_TYPE_COMPOUND
         &comp = &lsdefinition.GetCompound(&y);
         &jcomp = &jsondefinition.AppendCompound(&comp.Name, &lastrow, &comp.Package, &comp.LogicalSchema, &comp.Variant, &jsonschema);
         If Not jsondefined(&comp.LogicalSchema, &comp.Variant, &jsonschema, &comp.Package) Then
            &retval = buildjsonschema(&comp.LogicalSchema, &comp.Variant, &jsonschema, &comp.Package);
         End-If;
         Break;
      When-Other
         Return False;
      End-Evaluate;
   End-For;
   Return &jsondefinition.Save();
End-Function;

/* &wrec will point at record PSIBLOGICAL_WRK and contains all the document creation parameter values.
   &nrs points at a rowset of record PSIBLOGSCHM_NDE.  Must adhere to all the documented restrictions.
   &nmspcrs points at a rowset of record PSLSIMPNMSPC_VW for imported namespaces.
   The package, schema, and variant combination should not already exist.  Calling code should handle situations
   where users want to re-create an existing document.  Currently not doing Relational here.
   USERS SHOULD NOT CALL THIS METHOD WITH ROWSETS WITH CIRCULAR REFERENCES
*/
Function createdocumentobject(&package As string, &schema As string, &variant As string, &nrs As Rowset, &nmspcrs As Rowset, &wrec As Record, &bShowMessages As boolean) Returns number
   Local number &cnt, &ret;
   Local string &mname, &xmlalias;
   Local array of string &upddoclist;
   Local boolean &bret;
   
   &LS_CONSTANTS = create PT_SCHEMA:SchemaConstants();
   &HTMLNAME = &LS_CONSTANTS.TYPE_HTML; /* HTML */
   &XMLNAME = &LS_CONSTANTS.TYPE_XML;
   &RELATIONALNAME = &LS_CONSTANTS.TYPE_RELATIONAL;
   &JSONNAME = &LS_CONSTANTS.TYPE_JSON;
   
   &upddoclist = CreateArrayRept("", 0);
   
   If None(&package) Or
         None(&schema) Or
         None(&variant) Then
      If &bShowMessages Then
         MessageBox(0, "", 244, 129, "Error.  One of the document key values is missing.");
      End-If;
      Return - 100;
   End-If;
   SQLExec("select count(*) from pslsdefn where ib_packageid = :1 and ib_schemaname = :2 and ib_variantname = :3", &package, &schema, &variant, &cnt);
   If &cnt > 0 Then
      If &bShowMessages Then
         MessageBox(0, "", 244, 66, "Error.  Selected name cominbation matches an existing document.");
      End-If;
      Return - 101;
   End-If;
   &wrec.XMLALIAS.Value = &xmlalias;
   &ret = checkrowsetforerrors(&nrs, &bShowMessages);
   If &ret < 0 Then
      Return &ret;
   End-If;
   
   /* Error checks. */
   &ret = validatexmlschema(&nrs, &wrec.IB_LSTGTPREFIX.Value, False);
   If &ret < 0 Then
      Return &ret;
   End-If;
   &ret = validatelogicalschema(&nrs, False);
   If &ret < 0 Then
      Return &ret;
   End-If;
   
   &ret = savelogicalschema(&schema, &variant, &package, &nrs, &wrec, &XMLNAME, &RELATIONALNAME, &JSONNAME, &HTMLNAME, &bShowMessages);
   If &ret < 0 Then
      Return &ret;
   End-If;
   &ret = savexmlschema(&schema, &variant, &XMLNAME, &package, &nrs, &nmspcrs, &wrec, &bShowMessages);
   If &ret < 0 Then
      Return &ret;
   End-If;
   &ret = savejsonschema(&schema, &variant, &JSONNAME, &package, &nrs, &nmspcrs, &wrec, &bShowMessages, &upddoclist);
   If &ret < 0 Then
      Return &ret;
   End-If;
   &ret = savehtmlschema(&schema, &variant, &HTMLNAME, &package, &nrs, &nmspcrs, &wrec, &bShowMessages);
   If &ret < 0 Then
      Return &ret;
   End-If;
   If All(&wrec.IB_RELRECNAME.Value) Then
      &ret = saverelschema(&package, &schema, &variant, &nrs, &wrec, &XMLNAME, &RELATIONALNAME);
      If &ret < 0 Then
         &bret = deleterelationalobject(&package, &schema, &variant);
         Return &ret;
      End-If;
   End-If;
   
   Return 0;
End-Function;


Function readdocument(&package As string, &schema As string, &variant As string, &wrec As Record, &nmspc_rs As Rowset) Returns boolean
   /* Initialize all the needed variables */
   Local string &strdesclang = "";
   Local string &strdescvalu = "";
   Local number &idx, &relcnt;
   Local PT_SCHEMA:LogicalSchemaRelatedLang &lsrellang;
   Local PT_SCHEMA:LogicalSchemaDefinition &lsdefinition;
   Local boolean &ret;
   Local string &lsdescription;
   
   &nmspc_rs = CreateRowset(Record.PSLSIMPNMSPC_VW);
   &LS_CONSTANTS = create PT_SCHEMA:SchemaConstants();
   &XMLNAME = &LS_CONSTANTS.TYPE_XML;
   &RELATIONALNAME = &LS_CONSTANTS.TYPE_RELATIONAL;
   &JSONNAME = &LS_CONSTANTS.TYPE_JSON;
   &HTMLNAME = &LS_CONSTANTS.TYPE_HTML;
   
   /* Retrieve the Document definition */
   &lsdefinition = create PT_SCHEMA:LogicalSchemaDefinition(&package, &schema, &variant);
   
   /* Update the records based on the definition */
   If None(&wrec.DESCR.Value) Then
      &wrec.DESCR.Value = &lsdefinition.Label;
   End-If;
   
   /*** Retrieve Related Language Descriptions ***/
   If None(&wrec.DESCRLONG.Value) Then
      &wrec.DESCRLONG.Value = &lsdefinition.Description;
   End-If;
   
   &relcnt = &lsdefinition.GetRelatedLangCount();
   For &idx = 1 To &relcnt
      &lsrellang = &lsdefinition.GetRelatedLang(&idx);
      If Len(&strdesclang) <> 0 Then
         &strdesclang = &strdesclang | &ENUMDELIMETER;
         &strdescvalu = &strdescvalu | &ENUMDELIMETER;
      End-If;
      &strdescvalu = &strdescvalu | &lsrellang.Description;
      &strdesclang = &strdesclang | &lsrellang.LanguageCd;
      
      If &lsrellang.LanguageCd = %Language_User Then
         &wrec.DESCRLONG.Value = &lsrellang.Description;
      End-If;
   End-For;
   
   /*** Add the base language and description to the list if its not null ***/
   &lsdescription = &lsdefinition.Description;
   If All(&lsdescription) Then
      If Len(&strdesclang) <> 0 Then
         &strdesclang = &strdesclang | &ENUMDELIMETER;
         &strdescvalu = &strdescvalu | &ENUMDELIMETER;
      End-If;
      &strdesclang = &strdesclang | %Language_Base;
      &strdescvalu = &strdescvalu | &lsdescription;
   End-If;
   
   &wrec.IB_DESCLANG_LIST.Value = &strdesclang;
   &wrec.IB_DESCVALU_LIST.Value = &strdescvalu;
   
   If None(&wrec.OBJECTOWNERID.Value) Then
      &wrec.OBJECTOWNERID.Value = &lsdefinition.ObjectOwnerId;
   End-If;
   If None(&wrec.IB_ISPRIVATE.Value) Then
      &wrec.IB_ISPRIVATE.Value = BooltoYN(&lsdefinition.IsPrivate);;
   End-If;
   If None(&wrec.IB_ISIMPORTED.Value) Then
      &wrec.IB_ISIMPORTED.Value = BooltoYN(&lsdefinition.IsImported);
   End-If;
   If None(&wrec.IB_ISCONTAINER.Value) Then
      If (&lsdefinition.IsContainer) Then
         &wrec.IB_ISCONTAINER.Value = "1";
      Else
         &wrec.IB_ISCONTAINER.Value = "0";
      End-If;
   End-If;
   &wrec.IB_ISCMPPRIM.Value = "0";
   
   /* Build the rowset for the tree -- will not be displayed on screen */
   maketreeheader(&lsdefinition.Label);
   
   /* Read the details of the document definition and load on the variables */
   If Not getlogicalschemareference(&schema, &variant, 2, 2, False, &package, False, False) Then
      Return False;
      Exit;
   End-If;
   
   /* If xml schema does not exist, we do nothing.  Any errors while loading show up as pop-ups. */
   &ret = getdocxmlschemareference(&schema, &variant, &XMLNAME, 2, 2, False, &package, 0, &wrec, &nmspc_rs);
   /* Retrieve relational schema if it exists. */
   &ret = getdocrelschemareference(&package, &schema, &variant, 2, 2, False, &RELATIONALNAME, 0, &wrec);
   /* Retrieve json schema if it exists. */
   &ret = getdocjsonschemareference(&schema, &variant, &JSONNAME, 2, 2, False, &package, 0, &wrec);
   /* Retrieve html schema if it exists. */
   &ret = getdochtmlschemareference(&schema, &variant, &HTMLNAME, 2, 2, False, &package, 0, &wrec);
   
   Return True;
End-Function;

Function writedocument(&package As string, &schema As string, &variant As string, &wrec As Record, &nmspc_rs As Rowset) Returns boolean
   Local boolean &bRet;
   Local array of string &upddoclist;
   
   &LS_CONSTANTS = create PT_SCHEMA:SchemaConstants();
   &HTMLNAME = &LS_CONSTANTS.TYPE_HTML; /* HTML */
   &XMLNAME = &LS_CONSTANTS.TYPE_XML;
   &RELATIONALNAME = &LS_CONSTANTS.TYPE_RELATIONAL;
   &JSONNAME = &LS_CONSTANTS.TYPE_JSON;
   
   &upddoclist = CreateArrayRept("", 0);
   
   /* Save the document definition */
   If savelogicalschema(&schema, &variant, &package, &NODERS, &wrec, &XMLNAME, &RELATIONALNAME, &JSONNAME, &HTMLNAME, False) = 0 Then
      /* Save the XML Schema for the document definition */
      If savexmlschema(&schema, &variant, &XMLNAME, &package, &NODERS, &nmspc_rs, &wrec, False) = 0 Then
         If savejsonschema(&schema, &variant, &JSONNAME, &package, &NODERS, &nmspc_rs, &wrec, False, &upddoclist) = 0 Then
            If savehtmlschema(&schema, &variant, &HTMLNAME, &package, &NODERS, &nmspc_rs, &wrec, False) = 0 Then
               If All(&wrec.IB_RELRECNAME.Value) Then
                  /* Save the Relational Schema for the document definition */
                  If saverelschema(&package, &schema, &variant, &NODERS, &wrec, &XMLNAME, &RELATIONALNAME) = 0 Then
                     Return True;
                  End-If;
               Else
                  &bRet = deleterelationalobject(&package, &schema, &variant);
                  Return True;
               End-If;
            End-If;
         End-If;
      End-If;
   End-If;
   Return False;
End-Function;

Function updatedocument(&package As string, &schema As string, &variant As string, &wrec As Record) Returns boolean
   Local Rowset &nmspc_rs;
   &nmspc_rs = CreateRowset(Record.PSLSIMPNMSPC_VW);
   
   /* Read document definition and update the contents based on &wrec */
   If Not (readdocument(&package, &schema, &variant, &wrec, &nmspc_rs)) Then
      Return False;
   End-If;
   
   /* Write document definition*/
   Return writedocument(&package, &schema, &variant, &wrec, &nmspc_rs);
End-Function;

Function renamedocument(&package As string, &schema As string, &variant As string, &newpackage As string, &newschema As string, &newvariant As string) Returns boolean
   Local Record &wrec = CreateRecord(Record.PSIBLOGICAL_WRK);
   Local Rowset &nmspc_rs;
   &nmspc_rs = CreateRowset(Record.PSLSIMPNMSPC_VW);
   
   /* Read old document definition */
   If Not (readdocument(&package, &schema, &variant, &wrec, &nmspc_rs)) Then
      Return False;
   End-If;
   
   /* Change the description if its the same as the schema name */
   If &wrec.DESCR.Value = &schema Then
      &wrec.DESCR.Value = &newschema;
   End-If;
   
   /* Check for the following properties.  If they are set, don't rename */
   If &wrec.IB_ISIMPORTED.Value = "Y" Then
      Return False;
   End-If;
   If &wrec.IB_ISCONTAINER.Value = "1" Then
      Return False;
   End-If;
   
   /* Write new document definition*/
   If Not (writedocument(&newpackage, &newschema, &newvariant, &wrec, &nmspc_rs)) Then
      Return False;
   End-If;
   
   /* Delete old document definition but not the associated complex primitives*/
   Return deletedocumentobjectmain(&package, &schema, &variant, False, False);
End-Function;


Function updateIsImported(&package As string, &schema As string, &variant As string, &updateval As boolean) Returns boolean
   Local Record &wrec = CreateRecord(Record.PSIBLOGICAL_WRK);
   
   /* Set the new value for isImported */
   &wrec.IB_ISIMPORTED.Value = BooltoYN(&updateval);
   Return updatedocument(&package, &schema, &variant, &wrec);
End-Function;

Function updateIsContainer(&package As string, &schema As string, &variant As string, &updateval As boolean) Returns boolean
   Local Record &wrec = CreateRecord(Record.PSIBLOGICAL_WRK);
   
   /* Set the new value for isContainer */
   If (&updateval) Then
      &wrec.IB_ISCONTAINER.Value = "1";
   Else
      &wrec.IB_ISCONTAINER.Value = "0";
   End-If;
   
   Return updatedocument(&package, &schema, &variant, &wrec);
End-Function;

Function getDocumentTreeRowset(&package As string, &schema As string, &variant As string) Returns Rowset
   Local Record &wrec = CreateRecord(Record.PSIBLOGICAL_WRK);
   Local Rowset &nmspc_rs;
   &nmspc_rs = CreateRowset(Record.PSLSIMPNMSPC_VW);
   
   /* Read old document definition */
   If readdocument(&package, &schema, &variant, &wrec, &nmspc_rs) Then
      Return &NODERS;
   End-If;
   
   Return Null;
End-Function;

