import PSXP_RPTDEFNMANAGER:*;
import %metadata:*;
import %metadata:XMLPubRptMgr:*;
import %metadata:XMLPubTmpltMgr:*; /* MD CPY */
import %metadata:FileMgr:FileMgr:*; /* MD CPY */

import PSXP_ENGINE:*;
import PSXP_XMLGEN:*;
import PSXP_ENGINE:PDFMerger; /* OIT Merge */
import PT_MCF_MAIL:MCFOutboundEmail;
import PT_CONQRS:CONQRSMGR;
import PT_CONQRS:SCHED_INFO;

/* ****************************************************** */
/* This class represents a Report definition.             */
/* ****************************************************** */
class ReportDefn
   /* Managed Object Methods */
   method ReportDefn(&ReportID As string);
   method Delete();
   method Rename(&NewReportID As string);
   method Get();
   method Create();
   method Save();
   method Close();
   method CopyDefn(&sTargID As string) Returns boolean; /* MD CPY */
   
   method GetTemplateList() Returns array of PSXP_RPTDEFNMANAGER:TemplateDefn;
   method GetTemplate(&TemplateID As string) Returns PSXP_RPTDEFNMANAGER:TemplateDefn;
   method AddTemplate(&TemplateID As string) Returns PSXP_RPTDEFNMANAGER:TemplateDefn;
   method DeleteTemplate(&TemplateID As string);
   method SetDefaultTemplate(&TemplateID As string);
   method GetDefaultTemplateID() Returns string;
   method GetDefaultTemplate() Returns PSXP_RPTDEFNMANAGER:TemplateDefn;
   method IsDefaultTemplate(&TemplateId As string) Returns boolean;
   method GetActiveTemplatesByDistributionChannel(&DistributionChannel As string, &AsOfDate As date) Returns array of PSXP_RPTDEFNMANAGER:TemplateDefn;
   
   method GetTemplateControlList() Returns array of PSXP_RPTDEFNMANAGER:TemplateControl;
   method GetTemplateControl(&FieldValue As string) Returns PSXP_RPTDEFNMANAGER:TemplateControl;
   method AddTemplateControl(&FieldValue As string) Returns PSXP_RPTDEFNMANAGER:TemplateControl;
   method DeleteTemplateControl(&FieldValue As string);
   
   method GetDatasource() Returns PSXP_RPTDEFNMANAGER:DataSourceDefn;
   method SetDatasource(&DatasourceID As string, &DatasourceType As string, &Public As boolean);
   
   method EnableOutputFormat(&FormatType As string);
   method DisableOutputFormat(&FormatType As string);
   method GetOutputFormats() Returns array of string;
   method SetDefaultOutputFormat(&FormatType As string);
   method GetDefaultOutputFormat() Returns string;
   method IsOutputFormatEnabled(&FormatType As string) Returns boolean;
   
   method AddReportViewer(&DistIDType As string, &DistID As string);
   method DeleteReportViewer(&DistIdType As string, &DistID As string);
   method GetReportViewers() Returns array of PSXP_RPTDEFNMANAGER:ReportViewer;
   method IsReportViewerEnabled(&DistIDType As string, &DistID As string) Returns boolean;
   
   method AddScopeField(&DataSrcFieldName As string, &SecJoinTblFieldName As string);
   method DeleteScopeField(&DataSrcFieldName As string, &SecJoinTblFieldName As string);
   method GetScopeFields() Returns array of PSXP_RPTDEFNMANAGER:ScopeField;
   method AddSearchField(&FieldName As string);
   method DeleteSearchField(&FieldName As string);
   method GetSearchFields() Returns array of string;
   
   method GetProperties() Returns PSXP_ENGINE:Properties;
   method AddProperty(&sPropName As string, &sPropValue As string);
   method DeleteProperty(&sPropName As string);
   
   
   /* Runtime Methods */
   method SetRuntimeProperties(&asName As array of string, &asValue As array of string);
   
   method SetRuntimeDataXMLDoc(&Data As XmlDoc);
   method SetRuntimeDataRowset(&Data As Rowset);
   method SetRuntimeDataXMLFile(&Data As string);
   method SetPrinterType(&OutDestFormat As string);
   
   method GetPSQueryPromptRecord() Returns Record;
   method SetPSQueryPromptRecord(&PromptRecord As Record);
   
   method ProcessReport(&TemplateID As string, &LanguageCd As string, &AsOfDate As date, &OutputFormat As string);
   method ProcessETextReport(&TemplateID As string, &LanguageCd As string, &AsOfDate As date) Returns string;
   method Publish(&sServerName As string, &reportPath As string, &sFolderName As string, &processInstanceId As number);
   method PrintOutput(&DestPrinter As string);
   method DisplayOutput();
   method GetOutDestFormatString(&OutDestFormat As number) Returns string;
   method EmailOutput(&processInstanceId As number) Returns boolean;
   
   /* Public Help Methods */
   method GetMetaData() Returns %metadata:XMLPubRptMgr:XMLPubRptMgr;
   method GetMetaDataTemplateControl(&sFieldValue As string) Returns %metadata:XMLPubRptMgr:RptTmpltCntrl;
   method ValidateSave(&aErrs As array of string out) Returns boolean;
   method Exists(&ReportID As string) Returns boolean;
   method SetChanged();
   method GetFinalProperties() Returns PSXP_ENGINE:Properties; /* MD Submit */
   
   /* MD OIT */
   method setPDFConversionFiles(&convArray As array of string);
   method setPDFConversionTimeOut(&interval As number);
   method setPDFConversionPageNumbering(&x As number, &y As number);
   
   
   /* Managed Object Properties */
   property string ID readonly;
   property string Description get set;
   property string Status get set;
   property string CategoryID get set;
   property string TemplateType get set;
   property boolean OutputEditable get set;
   
   property boolean EnforceUniqueBurstValue get set;
   property string OutDestination get set;
   property string OutDestinationType get set;
   property string DestinationPrinter get set;
   property string FolderName get set;
   property date ArchiveDate get set;
   property number ArchiveAfter get set;
   property string ArchiveUnit get set;
   property string BurstFieldName get set;
   property string ReportFileName get set;
   property string SecurityJoinTable get set;
   property string SecurityFieldName get set;
   property string SecurityIDType get set;
   property string TemplateControlFieldName get set;
   property string AllowRecipientEntry get set;
   property string AllowViewerEntry get set;
   
   property string ObjectOwnerID get set;
   property string RegisteredBy get;
   property datetime RegisteredDTTM get;
   property string LastUpdateOprID get;
   property datetime LastUpdateDTTM get;
   property boolean UseBurstValueAsOutputFileName;
   property string RunControlId; /* mdu conn */
   property number ProcessInstance; /* mdu XXX */
   /*Other Properties*/
   property boolean IsReadOnly get;
   rem rsh ICE 1836783000;
   property boolean BurstValueAsOutSubDir;
   property boolean Debug;
   property boolean DefnChanged readonly; /* MD RET4 */
   property boolean ReusePDFSignatureForBursInst; /* MD Signature */
   property boolean SetStaticPDFReport; /* MD Submit */
   
   rem image REST requirement;
   property string BaseImageURI;
   
private
   instance %metadata:XMLPubRptMgr:XMLPubRptMgr &Report;
   instance array of PSXP_RPTDEFNMANAGER:TemplateDefn &TmpDefns;
   instance array of PSXP_RPTDEFNMANAGER:TemplateControl &TmpCtrls;
   instance array of string &DeleteOnSaveTmpIDs;
   instance array of PSXP_RPTDEFNMANAGER:TemplateDefn &CommitedNewTmps;
   instance PSXP_ENGINE:Properties &oRuntimeProperties;
   instance PSXP_RPTDEFNMANAGER:DataSourceDefn &oDSDefn; /* bug 12402786  */
   
   instance XmlDoc &DataXMLDoc;
   instance Rowset &DataRowSet;
   instance string &DataXMLFile;
   instance boolean &DefnNew;
   instance boolean &DefnGet;
   
   instance PSXP_RPTDEFNMANAGER:Utility &MyUtil;
   instance integer &DefnPermission;
   rem rsh ICE 1836783000;
   instance string &sSrvTmpDir;
   instance string &sSrvOutDir;
   instance string &sSrvProcDir; /* 2037749000 - temp subdir for temp files including templates/subtemplates/xliff etc*/
   instance boolean &bIsOutDestinationSet; /* mdu outdestin */
   
   instance ApiObject &oQuery;
   instance PT_CONQRS:CONQRSMGR &ConQryInst;
   instance Record &recQryPrompt;
   instance string &sDirSep;
   instance array of PSXP_RPTDEFNMANAGER:ReportOutput &arOutput;
   instance string &sOutDestFormat;
   instance string &sDistributionNode_URL; /* mdu XXX */
   rem RSH;
   instance PSXP_ENGINE:Properties &oSystemProperties;
   instance boolean &UseGlobalProperties;
   instance boolean &UseDefaultOutDestination; /* outdestin */
   
   rem rshpdf;
   instance boolean &UsePDFOptimized;
   
   rem rshwe;
   instance PSXP_ENGINE:Properties &oFinalProperties;
   instance array of string &aNoCDATAFields; /* ICE 2038507000 */
   instance boolean &IsNoArchiveValue; /* MD RET4 */
   instance number &IsBurstFileParsinqRequired; /* MD res 889197  */
   instance array of string &FieldsToParse; /* MD res 889197 */
   instance string &sPrinterType;
   
   /* MD Signature */
   instance boolean &IsPDFSignatureRequired;
   instance array of string &aSignatureFields;
   instance array of string &aSignatureValues;
   instance boolean &bReportWasSecured;
   
   /* MD submit */
   instance boolean &IsPDFSubmitEnabled;
   
   /* MD ext email */
   instance string &sBurstFieldValue;
   instance boolean &bIsExtEmail;
   instance string &extEmailAppclass;
   instance array of string &aExtUserEmailAddresses;
   
   /* MD OIT */
   instance array of string &arrPDFConversion;
   instance number &pdfConversionTimeOut;
   instance array of string &files2Convert; /* OIT Merge */
   instance boolean &IsPDFExportSecurityDisabled; /* OIT Merge */
   instance string &envServerDir; /* OIT Merge */
   instance number &pageNumberPosX;
   instance number &pageNumberPosY;
   
   method processFinalProperties();
   method FetchPermission() Returns boolean;
   method InternalDeleteTemplate(&nInx As integer);
   method InternalSaveTemplate(&TmpDefn As PSXP_RPTDEFNMANAGER:TemplateDefn);
   method ForceDeleteTemplate(&TemplateID As string);
   method ForceRollbackTemplates();
   method InternalDeleteTemplateControl(&nInx As integer);
   method DeleteFile(&sFilePath As string);
   method deleteDataXML();
   method SetSystemProperties();
   
   method GetTemplateRuntime(&TemplateId As string) Returns PSXP_RPTDEFNMANAGER:TemplateDefn;
   method GetTemplateFileRuntime(&oTemplate As PSXP_RPTDEFNMANAGER:TemplateDefn, &AsOfDate As date) Returns PSXP_RPTDEFNMANAGER:TemplateFile;
   rem rsh ICE 1836783000;
   method GetPDFMapFile(&sMapFile As string, &oTmplateFile As PSXP_RPTDEFNMANAGER:TemplateFile) Returns boolean;
   rem rsh ICE 1836783000;
   method ConvEtxTemplateToXsl(&sTmplFile As string, &oTemplateFile As PSXP_RPTDEFNMANAGER:TemplateFile) Returns boolean;
   rem rsh ICE 1836783000;
   method ConvRtfTemplateToXsl(&sTmplFile As string, &oTemplateFile As PSXP_RPTDEFNMANAGER:TemplateFile, &LocaleCd As string) Returns boolean;
   method GetXliffFile(&oTmplDefn As PSXP_RPTDEFNMANAGER:TemplateDefn, &oTemplateFile As PSXP_RPTDEFNMANAGER:TemplateFile, &LanguageCd As string) Returns string;
   
   /* runtime data processing methods */
   method OpenQueryDs() Returns boolean;
   method GenerateXmlFromQuery() Returns string;
   method GenerateXmlFileFromQuery(&sDataFile As string);
   method GenerateXmlFileFromConnQuery(&sOutFile As string out, &sProcessId As string);
   method GenerateXmlFromRowset() Returns string;
   method GenerateXmlFromXmlDoc() Returns string;
   method ReadDataFile() Returns string;
   method ReadXMLFile(&sFilePath As string) Returns string;
   rem rsh ICE 1836783000;
   method WriteXmlDataFile(&sXmlData As string, &sFileName As string);
   
   /* runtime output processing methods */
   method GenerateOutput(&sTmplFile As string, &sMapFile As string, &sDataFile As string, &sXliffFile As string, &sLocaleCd As string, &sOutputFile As string, &iOutputFormat As integer, &sErr As string) Returns boolean;
   method GenerateStringOutput(&sTmplFile As string, &sXmlData As string, &sLocaleCd As string, &sErr As string) Returns string;
   rem RSH;
   method TranslateUserFileName(&sUserfilename As string, &oBurstFileInfo As PSXP_RPTDEFNMANAGER:BurstFileInfo, &LanguageCd As string, &AsOfDate As date) Returns string;
   
   /* publish */
   method Publish_Message_Attrib(&prcsinstId As number, &reportId As number, &sDbName As string, &sFileURL As string, &attrArray As array of array of string) Returns boolean;
   
   rem RSH;
   method getPubAttributes(&oBurstFileInfo As PSXP_RPTDEFNMANAGER:BurstFileInfo) Returns array of array of string;
   
   method isBurstingOn() Returns boolean;
   rem rshwe2 1891427000;
   
   method isBurstSecurityOn() Returns boolean; /*res 929638*/
   method PostReportDistribute(&processInstanceId As number, &sDbName As string, &outDest As string, &sReportDescr As string, &folderName As string, &serverName As string, &dExpire As date, &attrArray As array of array of string, &oRptViewerArray As array of PSXP_RPTDEFNMANAGER:ReportViewer, &distPageEmailList As string, &emailSubject As string, &emailText As string, &sburstVal As string, &sFileName As string, &LogLevel As number) Returns boolean;
   
   method getRptDefnDistribution(&oRptViewerArray As array of PSXP_RPTDEFNMANAGER:ReportViewer) Returns array of PSXP_RPTDEFNMANAGER:ReportViewer;
   method getRuntimeDistribution(&processInstanceId As number, &oRptViewerArray As array of PSXP_RPTDEFNMANAGER:ReportViewer) Returns array of PSXP_RPTDEFNMANAGER:ReportViewer;
   method getBurstDistribution(&oBurstFileInfo As PSXP_RPTDEFNMANAGER:BurstFileInfo, &aRptViewers As array of PSXP_RPTDEFNMANAGER:ReportViewer) Returns array of PSXP_RPTDEFNMANAGER:ReportViewer;
   method getXMLDocFromDataFile(&sFilePath As string, &oXmlDoc As XmlDoc) Returns boolean; /* mdu 1548157000  */
   
   method getRecepientTagValue(&oBurstFileInfo As PSXP_RPTDEFNMANAGER:BurstFileInfo, &sTagName As string) Returns string;
   method getRolesInPermList(&sPermList As string) Returns array of string;
   method generateExpiryDate(&processInstanceId As number) Returns date;
   method getDefaultFolderName() Returns string;
   method getDefaultArchiveDays() Returns integer;
   
   /* Email output enhancement - following 3 methods */
   method PrepareAndSendEmail(&emailAddresses As array of string, &AttachFiles As array of string, &efnames As array of string, &subject As string, &emailText As string) Returns boolean;
   method getEmailAddresses(&aViewers As array of PSXP_RPTDEFNMANAGER:ReportViewer) Returns array of string;
   method CombineArrays(&Array1 As array of string out, &Array2 As array of string);
   method getDistEmailInfo(&processInstanceId As number) Returns array of PSXP_RPTDEFNMANAGER:ReportViewer;
   method getDistPageEmailList(&processInstanceId As number, &subject As string out, &emlText As string out) Returns array of string;
   
   /* printing */
   method PrintReport(&sDestPrinter As string, &sRptDir As string, &sOutputFile As string);
   
   /* cleanup output */
   method CleanOutput();
   method SetQueryTrackingURL();
   method RemoveCDATAfromFieldList(&sDataFile As string); /* ICE 2038507000 */
   method SyncArchiveValueFields(); /* MD RET4 */
   method SetBurstParsingOptions(&oBurstFileInfo As PSXP_RPTDEFNMANAGER:BurstFileInfo); /* MD res.888676  */
   
   /* MD Signature */
   method ParseDataValues(&oBurstFileInfo As PSXP_RPTDEFNMANAGER:BurstFileInfo, &oDigSign As PSXP_RPTDEFNMANAGER:DigitalSignature, &isBursted As boolean);
   method cleanupProcessing(&bDeleteRoot As boolean);
   
   /* MD ext email */
   method getExtEmailAddressArray() Returns boolean;
   
   /* MD OIT */
   method setPDFConversionData(&sOutputFile As string); /* OIT Merge */
   method cleanupConversionArray(&filesArr As array of string) Returns array of string; /* OIT 901R1 */
   method mergePDFReportWithAttachments(&sOutputFile As string) Returns boolean; /* OIT Merge */
   method getfilenamesArr(&fulpathArr As array of string) Returns array of string; /* MD OIT PDF */
   
   Constant &DistIdType_User = 2;
   Constant &DistIdType_Role = 3;
   Constant &DistIdType_PermList = 4;
   
   Constant &sDistIdType_User = "USER";
   Constant &sDistIdType_Role = "ROLE";
   
   Constant &PSXP_MsgSet = 235;
   Constant &PSXP_PublicDSOprID = "";
   Constant &PSXP_PDFConverterTimeOut = 20; /* MD OIT */
end-class;

Declare Function GetLocaleCode PeopleCode PSXPFUNCLIB.FUNCLIB FieldFormula;
Declare Function GetDirectoryFromPath PeopleCode PSXPFUNCLIB.FUNCLIB FieldFormula;
Declare Function GetFileNameFromPath PeopleCode PSXPFUNCLIB.FUNCLIB FieldFormula; /* MD OIT PDF */

/* ****************************************************** */
/* TemplateDefn constructor                               */
/* ****************************************************** */
method ReportDefn
   /+ &ReportID as String +/
   &ID = &ReportID;
   
   &Report = Null;
   &TmpDefns = Null;
   &TmpCtrls = Null;
   &DeleteOnSaveTmpIDs = Null;
   &CommitedNewTmps = Null;
   
   &MyUtil = create PSXP_RPTDEFNMANAGER:Utility();
   %This.SetSystemProperties();
   &oRuntimeProperties = Null;
   &DataXMLDoc = Null;
   &DataRowSet = Null;
   &DataXMLFile = "";
   
   &DefnNew = False;
   &DefnGet = False;
   &DefnChanged = False;
   &DefnPermission = &MyUtil.PSXP_PermUnknown;
   
   &sDirSep = "/";
   &sDistributionNode_URL = ""; /*mdu XXX */
   
   &envServerDir = GetEnv("PS_SERVDIR"); /* OIT Merge */
   If &envServerDir = "" Then /* for  AE 2 tier debugging set your PRCS tools directory */
      rem &envServerDir = "D:\PeopleSoft\PT855-903R1\appserv\prcs\MQ559033";
   End-If;
   
   If Substring(&envServerDir, 1, 1) <> "/" Then
      &sDirSep = "\";
   End-If;
   
   rem set default values;
   %This.UseBurstValueAsOutputFileName = False;
   %This.UseGlobalProperties = True;
   %This.BurstValueAsOutSubDir = False;
   %This.Debug = False;
   &aNoCDATAFields = Null; /*ICE 2038507000*/
   &oDSDefn = Null; /* bug 12402786  */
   &IsBurstFileParsinqRequired = - 1; /* MD res 889197  */
   &BaseImageURI = "";
   
   /* MD Signature */
   &IsPDFSignatureRequired = False;
   &ReusePDFSignatureForBursInst = False;
   &bReportWasSecured = False;
   &aSignatureFields = Null;
   &aSignatureValues = Null;
   
   &IsPDFSubmitEnabled = False; /* MD Submit */
   &aExtUserEmailAddresses = Null; /* MD ext email */
   
   &arrPDFConversion = CreateArrayRept("", 0); /* MD OIT */
   &pdfConversionTimeOut = 0; /* MD OIT */
   
end-method;

rem RSH;
method SetSystemProperties
   &oSystemProperties = &MyUtil.GetSystemProperties();
   If &oSystemProperties = Null Or
         &oSystemProperties.size() = 0 Then
      throw CreateException(235, 3262, "ERROR: Can't read system properties from xdo.cfg file, check log file for details");
   End-If;
   
   Local string &sValue;
   Local boolean &bRes = &oSystemProperties.getProperty("system-temp-dir", &sValue);
   If &bRes = False Or
         &sValue = "" Then
      WriteToLog(%ApplicationLogFence_Error, "WARNING: 'system-temp-dir' property is not defined in xdo.cfg");
   Else
      If Not FileExists(&sValue, %FilePath_Absolute) Then
         throw CreateException(235, 3263, "ERROR: 'system-temp-dir' property is pointing to an invalid directory");
      End-If;
   End-If;
end-method;


/* ****************************************************** */
/* Delete method                                          */
/* ****************************************************** */
method Delete
   Local boolean &rtn;
   Local %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager &mgr;
   Local %metadata:Key &key;
   Local PSXP_RPTDEFNMANAGER:ReportDefn &deleteRptDefn;
   Local %metadata:XMLPubRptMgr:RptTmpl &oInfo;
   Local integer &i;
   
   If Not %This.FetchPermission() Then
      throw CreateException(&PSXP_MsgSet, 2008, "Report definition %1 does not exist.", &ID);
   End-If;
   
   If Not &DefnPermission = &MyUtil.PSXP_PermFullAccess Then
      throw CreateException(&PSXP_MsgSet, 2023, "User %1 does not have permission to update report definition %2.", %OperatorId, &ID);
   End-If;
   
   /* delete all templates */
   &deleteRptDefn = create PSXP_RPTDEFNMANAGER:ReportDefn(&ID);
   &deleteRptDefn.Get();
   
   For &i = 1 To &deleteRptDefn.GetMetaData().Count_Xprpttmpl
      &oInfo = &deleteRptDefn.GetMetaData().Get_Xprpttmpl(&i);
      %This.ForceDeleteTemplate(&oInfo.Template_id);
   End-For;
   
   &deleteRptDefn = Null;
   
   /* delete defn */
   &mgr = create %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager();
   &key = create %metadata:Key(Key:Class_ReportDefn, &ID);
   &rtn = &mgr.DeleteDefn(&key);
   If &rtn = False Then
      throw CreateException(&PSXP_MsgSet, 2001, "Delete of report definition %1 failed.", &ID);
   End-If;
   &ConQryInst = Null;
   &DefnNew = False;
   &DefnGet = False;
   &DefnChanged = False;
end-method;

method ForceDeleteTemplate
   /+ &TemplateID as String +/
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   
   try
      &oTmpDefn = create PSXP_RPTDEFNMANAGER:TemplateDefn(&TemplateID);
      &oTmpDefn.Delete();
   catch Exception &e
      /* error */
      WriteToLog(%ApplicationLogFence_Error, "Force delete of template definition " | &TemplateID | " failed. " | &e.ToString());
   end-try;
end-method;


/* ****************************************************** */
/* Save method                                            */
/* ****************************************************** */
method Save
   Local boolean &rtn;
   Local array of string &aErrs;
   Local string &sErr;
   Local integer &i, &j;
   
   If (&DefnPermission = &MyUtil.PSXP_PermNoAccess Or
         &DefnPermission = &MyUtil.PSXP_PermReadOnly) And
         ( Not IsUserInRole("XMLP Service User") And
            %Component <> "") Then
      throw CreateException(&PSXP_MsgSet, 2023, "User %1 does not have permission to update report definition %2.", %OperatorId, &ID);
   End-If;
   
   &rtn = &Report.ValidateDefn();
   If &rtn = False Then
      throw CreateException(&PSXP_MsgSet, 2003, "Validate report definition %1 failed. %2", &ID, "");
   End-If;
   
   &rtn = %This.ValidateSave(&aErrs);
   If &rtn = False Then
      If Not &aErrs = Null Then
         For &i = 1 To &aErrs.Len
            &sErr = &sErr | "  " | &aErrs [&i];
         End-For;
      End-If;
      
      throw CreateException(&PSXP_MsgSet, 2003, "Validate report definition %1 failed. %2", &ID, &sErr);
   End-If;
   
   &CommitedNewTmps = Null;
   
   try
      /* save all templates */
      If Not &TmpDefns = Null Then
         For &i = 1 To &TmpDefns.Len
            %This.InternalSaveTemplate(&TmpDefns [&i]);
         End-For;
      End-If;
   catch Exception &e
      /* error */
      %This.ForceRollbackTemplates();
      throw &e;
   end-try;
   
   %This.SyncArchiveValueFields(); /* MD RET4 */
   
   /* save defn */
   If (&DefnNew = True) Then
      &Report.Registered_by = %UserId;
      &Report.Registered_dttm = %Datetime;
      &rtn = &Report.SaveNewDefn();
   Else
      If (&DefnGet = True) And
            (&DefnChanged = True) Then
         &rtn = &Report.UpdateDefn();
      End-If;
   End-If;
   
   If &rtn = False Then
      %This.ForceRollbackTemplates();
      throw CreateException(&PSXP_MsgSet, 2004, "Save of report definition %1 failed.", &ID);
   End-If;
   
   &CommitedNewTmps = Null;
   
   /* delete templates */
   If Not &DeleteOnSaveTmpIDs = Null Then
      For &i = 1 To &DeleteOnSaveTmpIDs.Len
         %This.ForceDeleteTemplate(&DeleteOnSaveTmpIDs [&i]);
      End-For;
      &DeleteOnSaveTmpIDs = Null;
   End-If;
   
   &DefnNew = False;
   &DefnGet = True;
   &DefnChanged = False;
end-method;

rem rshw ICE 1836783000;
method Close
   If %This.Debug = False And
         FileExists(%This.sSrvTmpDir, %FilePath_Absolute) Then
      try
         RemoveDirectory(%This.sSrvTmpDir, %FilePath_Absolute + %Remove_Subtree);
      catch Exception &Exp
         WriteToLog(%ApplicationLogFence_Error, "Could not delete Directory:" | %This.sSrvTmpDir);
      end-try;
      
      
   End-If;
end-method;

method ForceRollbackTemplates
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   Local integer &i;
   
   WriteToLog(%ApplicationLogFence_Error, "Save of report definition " | &ID | " failed. Rollback new template definition(s) ...");
   
   If Not &CommitedNewTmps = Null Then
      For &i = 1 To &CommitedNewTmps.Len
         &oTmpDefn = &CommitedNewTmps [&i];
         WriteToLog(%ApplicationLogFence_Error, "Rollback new template definition " | &oTmpDefn.ID);
         &oTmpDefn.OnRollbackNew();
         %This.ForceDeleteTemplate(&oTmpDefn.ID);
      End-For;
   End-If;
   
   &CommitedNewTmps = Null;
end-method;

method InternalSaveTemplate
   /+ &TmpDefn as PSXP_RPTDEFNMANAGER:TemplateDefn +/
   Local boolean &bNew;
   
   &bNew = &TmpDefn.IsNew();
   &TmpDefn.Save();
   
   If &bNew Then
      If &CommitedNewTmps = Null Then
         &CommitedNewTmps = CreateArray(&TmpDefn);
      Else
         &CommitedNewTmps.Push(&TmpDefn);
      End-If;
   End-If;
end-method;

method ValidateSave
   /+ &aErrs as Array of String out +/
   /+ Returns Boolean +/
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   Local string &sErr;
   Local boolean &bRet;
   Local integer &i;
   
   &bRet = True;
   &sErr = "";
   
   If &DefnNew = True And
         %This.Exists(&ID) Then
      &sErr = MsgGet(&PSXP_MsgSet, 2007, "Report definition %1 already exists.", &ID);
   Else
      If &DefnGet = True And
            &DefnChanged = True And
            Not %This.Exists(&ID) Then
         &sErr = MsgGet(&PSXP_MsgSet, 2008, "Report definition %1 does not exist.", &ID);
      End-If;
   End-If;
   
   If Not &sErr = "" Then
      If &aErrs = Null Then
         &aErrs = CreateArray(&sErr);
      Else
         &aErrs.Push(&sErr);
      End-If;
      &bRet = False;
   End-If;
   
   If Not &TmpDefns = Null Then
      For &i = 1 To &TmpDefns.Len
         &oTmpDefn = &TmpDefns [&i];
         If Not &oTmpDefn.ValidateSave(&aErrs) Then
            &bRet = False;
         End-If;
      End-For;
   End-If;
   
   Return &bRet;
end-method;

method Exists
   /+ &ReportID as String +/
   /+ Returns Boolean +/
   Local %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager &mgr;
   Local %metadata:Key &key;
   
   &mgr = create %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager();
   &key = create %metadata:Key(Key:Class_ReportDefn, &ReportID);
   Return &mgr.DefnExists(&key);
end-method;

method SetChanged
   &DefnChanged = True;
end-method;



/* ****************************************************** */
/* Rename method                                          */
/* ****************************************************** */
method Rename
   /+ &NewReportID as String +/
   Local %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager &mgr;
   Local %metadata:Key &oldkey;
   Local %metadata:Key &newkey;
   Local boolean &rtn;
   
   If &ID = &NewReportID Then
      Return;
   End-If;
   
   If Not %This.FetchPermission() Then
      throw CreateException(&PSXP_MsgSet, 2008, "Report definition %1 does not exist.", &ID);
   End-If;
   
   If Not &DefnPermission = &MyUtil.PSXP_PermFullAccess Then
      throw CreateException(&PSXP_MsgSet, 2023, "User %1 does not have permission to update report definition %2.", %OperatorId, &ID);
   End-If;
   
   &mgr = create %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager();
   &oldkey = create %metadata:Key(Key:Class_ReportDefn, &ID);
   &newkey = create %metadata:Key(Key:Class_ReportDefn, &NewReportID);
   &rtn = &mgr.RenameDefn(&oldkey, &newkey);
   If &rtn = False Then
      throw CreateException(&PSXP_MsgSet, 2009, "Rename of report definition %1 to %2 failed.", &ID, &NewReportID);
   End-If;
end-method;


/* ****************************************************** */
/* Get method                                             */
/* ****************************************************** */
method Get
   Local %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager &mgr;
   Local %metadata:Key &key;
   
   If Not %This.FetchPermission() Then
      throw CreateException(&PSXP_MsgSet, 2008, "Report definition %1 does not exist.", &ID);
   End-If;
   rem WriteToLog(%ApplicationLogFence_Level1, "Report: " | &ID | "User: " | %OperatorId | " DefnPermission: " | String(&DefnPermission) | " IsReadOnly: " | String(%This.IsReadOnly));
   
   If &DefnPermission = &MyUtil.PSXP_PermNoAccess And
         ( Not IsUserInRole("XMLP Service User") And
            %Component <> "") Then
      throw CreateException(&PSXP_MsgSet, 2022, "User %1 does not have permission to access report definition %2.", %OperatorId, &ID);
   End-If;
   
   &mgr = create %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager();
   &key = create %metadata:Key(Key:Class_ReportDefn, &ID);
   &Report = &mgr.GetDefnToUpdate(&key);
   If &Report = Null Then
      throw CreateException(&PSXP_MsgSet, 2010, "Get of report definition %1 failed.", &ID);
   End-If;
   
   &DefnNew = False;
   &DefnGet = True;
   &DefnChanged = False;
end-method;


method FetchPermission
   /+ Returns Boolean +/
   Local string &sRptCatId, &sOprId;
   Local integer &iPerm;
   Local SQL &mySQL;
   Local boolean &bRet, &bGblPrivShared; /* bug 20968564 */
   Local number &nCnt;
   
   &sRptCatId = "";
   /* bug 20968564 */
   /*&mySQL = CreateSQL("SELECT REPORT_CATEGORY_ID FROM PSXPRPTDEFN WHERE REPORT_DEFN_ID = :1", &ID);
   &bRet = &mySQL.Fetch(&sRptCatId);*/
   &mySQL = CreateSQL("SELECT OPRID, REPORT_CATEGORY_ID FROM PSXPRPTDEFN WHERE REPORT_DEFN_ID = :1", &ID);
   &bRet = &mySQL.Fetch(&sOprId, &sRptCatId);
   &mySQL.Close();
   
   If Not &bRet Then
      Return False;
   End-If;
   
   &DefnPermission = &MyUtil.GetReportCategoryUserPermission(&sRptCatId, %OperatorId);
   
   If &DefnPermission >= &MyUtil.PSXP_PermReadOnly Then
      /*bug 20968564 - If the Report is private and not owned by %OperatorId, we need to downgrade permissions appropriately*/
      If All(&sOprId) And
            &sOprId <> %OperatorId Then
         /* bug 20968564 - check if private shared mode is set globally*/
         SQLExec("SELECT COUNT(*) FROM PSXPGLBPROP WHERE PROPLNAME = 'psxp_private_report_access' AND PROPVALUE = 'Shared'", &nCnt);
         If &nCnt = 0 Then
            &bGblPrivShared = False;
         Else
            &bGblPrivShared = True;
         End-If;
         
         If &bGblPrivShared = True Then
            SQLExec("SELECT COUNT(*) FROM PSXPRPTDEFN A, PSQRYDEFN Q WHERE A.REPORT_DEFN_ID = :1 AND A.DS_TYPE = 'QRY' AND A.DS_ID = Q.QRYNAME AND Q.OPRID = %OperatorId AND NOT EXISTS(SELECT 'X' FROM PSXPRPTPROP P WHERE P.REPORT_DEFN_ID = A.REPORT_DEFN_ID AND P.PROPLNAME = 'psxp_private_report_access' AND P.PROPVALUE = 'Owner')", &ID, &nCnt);
         Else
            SQLExec("SELECT COUNT(*) FROM PSXPRPTDEFN A WHERE A.REPORT_DEFN_ID = :1 AND EXISTS(SELECT 'X' FROM PSQRYDEFN Q, PSXPRPTPROP P WHERE A.DS_TYPE = 'QRY' AND A.DS_ID = Q.QRYNAME AND Q.OPRID = %OperatorId AND P.REPORT_DEFN_ID = A.REPORT_DEFN_ID AND P.PROPLNAME = 'psxp_private_report_access' AND P.PROPVALUE = 'Shared')", &ID, &nCnt);
         End-If;
         
         If &nCnt = 0 Then /*private report - owner access only*/
            &DefnPermission = &MyUtil.PSXP_PermNoAccess;
         Else /*private report - shared - Read Only access*/
            &DefnPermission = &MyUtil.PSXP_PermReadOnly;
         End-If;
      End-If;
   End-If;
   
   Return True;
end-method;


/* ****************************************************** */
/* Create method                                          */
/* ****************************************************** */
method Create
   Local %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager &mgr;
   Local %metadata:Key &key;
   
   &mgr = create %metadata:XMLPubRptMgr:XMLPubRptMgr_Manager();
   &key = create %metadata:Key(Key:Class_ReportDefn, &ID);
   If (&mgr.DefnExists(&key) = True) Then
      throw CreateException(&PSXP_MsgSet, 2007, "Report definition %1 already exists.", &ID);
   End-If;
   
   &Report = &mgr.CreateDefn();
   If &Report = Null Then
      throw CreateException(&PSXP_MsgSet, 2011, "Create of report definition %1 failed.", &ID);
   End-If;
   
   &Report.Report_defn_id = &ID;
   &DefnNew = True;
   &DefnGet = False;
   &DefnChanged = True;
   
   &DefnPermission = &MyUtil.PSXP_PermFullAccess;
end-method;


/* ****************************************************** */
/* Runtime Methods                                 */
/* ****************************************************** */

/* ****************************************************** */
/* GetTemplateList method                              */
/* ****************************************************** */
method GetTemplateList
   /+ Returns Array of PSXP_RPTDEFNMANAGER:TemplateDefn +/
   Local integer &i;
   Local %metadata:XMLPubRptMgr:RptTmpl &oInfo;
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   
   If &TmpDefns = Null Then
      For &i = 1 To &Report.Count_Xprpttmpl
         &oInfo = &Report.Get_Xprpttmpl(&i);
         &oTmpDefn = create PSXP_RPTDEFNMANAGER:TemplateDefn(&oInfo.Template_id);
         &oTmpDefn.Get();
         
         If &TmpDefns = Null Then
            &TmpDefns = CreateArray(&oTmpDefn);
         Else
            &TmpDefns.Push(&oTmpDefn);
         End-If;
      End-For;
   End-If;
   
   Return &TmpDefns;
end-method;


/* ****************************************************** */
/* GetTemplate method                              */
/* ****************************************************** */
method GetTemplate
   /+ &TemplateID as String +/
   /+ Returns PSXP_RPTDEFNMANAGER:TemplateDefn +/
   Local array of PSXP_RPTDEFNMANAGER:TemplateDefn &aTmpDefns;
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   Local integer &i;
   
   &aTmpDefns = %This.GetTemplateList();
   
   If Not &TmpDefns = Null Then
      For &i = 1 To &TmpDefns.Len
         &oTmpDefn = &TmpDefns [&i];
         If &oTmpDefn.ID = &TemplateID Then
            Return &oTmpDefn;
         End-If;
      End-For;
   End-If;
   
   throw CreateException(&PSXP_MsgSet, 2012, "Template definition %1 not found in the report definition.", &TemplateID);
end-method;


/* ****************************************************** */
/* AddTemplate method                              */
/* ****************************************************** */
method AddTemplate
   /+ &TemplateID as String +/
   /+ Returns PSXP_RPTDEFNMANAGER:TemplateDefn +/
   Local array of PSXP_RPTDEFNMANAGER:TemplateDefn &aTmpDefns;
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   Local %metadata:XMLPubRptMgr:RptTmpl &oInfo;
   Local integer &i;
   
   &aTmpDefns = %This.GetTemplateList();
   
   /* search existing */
   If Not &TmpDefns = Null Then
      For &i = 1 To &TmpDefns.Len
         &oTmpDefn = &TmpDefns [&i];
         If &oTmpDefn.ID = &TemplateID Then
            throw CreateException(&PSXP_MsgSet, 2013, "Template definition %1 already exists in the report definition.", &TemplateID);
         End-If;
      End-For;
   End-If;
   
   /* append new */
   &DefnChanged = True;
   
   &oInfo = &Report.Append_Xprpttmpl(&Report.Count_Xprpttmpl);
   If &oInfo = Null Then
      throw CreateException(&PSXP_MsgSet, 2014, "Can't add template definition %1 to the report definition.", &TemplateID);
   End-If;
   
   /* Initialize */
   &oInfo.Template_id = &TemplateID;
   
   &oTmpDefn = create PSXP_RPTDEFNMANAGER:TemplateDefn(&TemplateID);
   &oTmpDefn.Create();
   
   If &TmpDefns = Null Then
      &TmpDefns = CreateArray(&oTmpDefn);
   Else
      &TmpDefns.Push(&oTmpDefn);
   End-If;
   
   Return &oTmpDefn;
end-method;


/* ****************************************************** */
/* DeleteTemplate method                              */
/* ****************************************************** */
method DeleteTemplate
   /+ &TemplateID as String +/
   Local array of PSXP_RPTDEFNMANAGER:TemplateDefn &aTmpDefns;
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   Local %metadata:XMLPubRptMgr:RptTmpl &oInfo;
   Local integer &i;
   
   &aTmpDefns = %This.GetTemplateList();
   
   If Not &TmpDefns = Null Then
      For &i = 1 To &TmpDefns.Len
         &oTmpDefn = &TmpDefns [&i];
         If &oTmpDefn.ID = &TemplateID Then
            &DefnChanged = True;
            %This.InternalDeleteTemplate(&i);
            Return;
         End-If;
      End-For;
   End-If;
   
   throw CreateException(&PSXP_MsgSet, 2012, "Template definition %1 not found in the report definition.", &TemplateID);
end-method;

method InternalDeleteTemplate
   /+ &nInx as Integer +/
   Local array of PSXP_RPTDEFNMANAGER:TemplateDefn &newTmpDefns;
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   Local %metadata:XMLPubRptMgr:RptTmpl &oRptTmp;
   Local string &sTmpID;
   Local integer &i, &j, &k;
   
   /* remember delete template */
   &oTmpDefn = &TmpDefns [&nInx];
   &sTmpID = &oTmpDefn.ID;
   If Not &oTmpDefn.IsNew() Then
      If &DeleteOnSaveTmpIDs = Null Then
         &DeleteOnSaveTmpIDs = CreateArray(&oTmpDefn.ID);
      Else
         &DeleteOnSaveTmpIDs.Push(&oTmpDefn.ID);
      End-If;
   End-If;
   
   /* remove the delete */
   &j = &nInx - 1;
   For &i = 1 To &j
      &oTmpDefn = &TmpDefns [&i];
      
      If &newTmpDefns = Null Then
         &newTmpDefns = CreateArray(&oTmpDefn);
      Else
         &newTmpDefns.Push(&oTmpDefn);
      End-If;
   End-For;
   
   &j = &nInx + 1;
   &k = &TmpDefns.Len;
   For &i = &j To &k
      &oTmpDefn = &TmpDefns [&i];
      
      If &newTmpDefns = Null Then
         &newTmpDefns = CreateArray(&oTmpDefn);
      Else
         &newTmpDefns.Push(&oTmpDefn);
      End-If;
   End-For;
   
   &TmpDefns = &newTmpDefns;
   
   /* remove metadata */
   For &i = 1 To &Report.Count_Xprpttmpl
      &oRptTmp = &Report.Get_Xprpttmpl(&i);
      If &oRptTmp.Template_id = &sTmpID Then
         &Report.Delete_Xprpttmpl(&i);
         Return;
      End-If;
   End-For;
end-method;


/* ****************************************************** */
/* SetDefaultTemplate method                              */
/* ****************************************************** */
method SetDefaultTemplate
   /+ &TemplateID as String +/
   Local integer &i;
   Local %metadata:XMLPubRptMgr:RptTmpl &oInfo;
   Local string &sTmpID;
   
   If &TemplateID = %This.GetDefaultTemplateID() Then
      Return;
   End-If;
   
   &DefnChanged = True;
   
   For &i = 1 To &Report.Count_Xprpttmpl
      &oInfo = &Report.Get_Xprpttmpl(&i);
      
      If &oInfo.Template_id = &TemplateID Then
         &oInfo.Is_default = "Y"
      Else
         &oInfo.Is_default = "N"
      End-If
   End-For;
end-method;


/* ****************************************************** */
/* GetDefaultTemplateID method                              */
/* ****************************************************** */
method GetDefaultTemplateID
   /+ Returns String +/
   Local integer &i;
   Local %metadata:XMLPubRptMgr:RptTmpl &oInfo;
   
   For &i = 1 To &Report.Count_Xprpttmpl
      &oInfo = &Report.Get_Xprpttmpl(&i);
      
      If &oInfo.Is_default = "Y" Or
            &oInfo.Is_default = "y" Then
         Return &oInfo.Template_id;
      End-If;
   End-For;
   
   Return "";
end-method;


/* ****************************************************** */
/* GetDefaultTemplate method                              */
/* ****************************************************** */
method GetDefaultTemplate
   /+ Returns PSXP_RPTDEFNMANAGER:TemplateDefn +/
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   Local string &sTmpID;
   
   &sTmpID = %This.GetDefaultTemplateID();
   
   If Len(&sTmpID) = 0 Then
      Return Null;
   Else
      Return %This.GetTemplate(&sTmpID);
   End-If;
end-method;


/* ****************************************************** */
/* IsDefaultTemplate method                              */
/* ****************************************************** */
method IsDefaultTemplate
   /+ &TemplateId as String +/
   /+ Returns Boolean +/
   If Len(&TemplateId) = 0 Then
      Return False;
   End-If;
   
   Return (&TemplateId = %This.GetDefaultTemplateID());
end-method;

/* ****************************************************** */
/* GetActiveTemplatesByDistributionChannel method         */
/* ****************************************************** */
method GetActiveTemplatesByDistributionChannel
   /+ &DistributionChannel as String, +/
   /+ &AsOfDate as Date +/
   /+ Returns Array of PSXP_RPTDEFNMANAGER:TemplateDefn +/
   Local array of PSXP_RPTDEFNMANAGER:TemplateDefn &aTmpDefns, &aTmpDefnsRet;
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpDefn;
   Local PSXP_RPTDEFNMANAGER:TemplateFile &oTmplFile;
   Local integer &i;
   
   If None(&AsOfDate) Then
      &AsOfDate = %AsOfDate;
   End-If;
   
   &aTmpDefns = %This.GetTemplateList();
   
   If Not &TmpDefns = Null Then
      For &i = 1 To &TmpDefns.Len
         &oTmpDefn = &TmpDefns [&i];
         
         If Not &oTmpDefn.DistributionChannel = &DistributionChannel Then
            Continue;
         End-If;
         
         try
            &oTmplFile = &oTmpDefn.GetActiveTemplateFile(&AsOfDate);
         catch Exception &e
            &oTmplFile = Null;
         end-try;
         
         If &oTmplFile = Null Then
            Continue;
         End-If;
         
         If &aTmpDefnsRet = Null Then
            &aTmpDefnsRet = CreateArray(&oTmpDefn);
         Else
            &aTmpDefnsRet.Push(&oTmpDefn);
         End-If;
      End-For;
   End-If;
   
   Return &aTmpDefnsRet;
end-method;


/* ****************************************************** */
/* GetDatasource method                              */
/* ****************************************************** */
method GetDatasource
   /+ Returns PSXP_RPTDEFNMANAGER:DataSourceDefn +/
   Local boolean &Public;
   
   /* bug 12402786 returning DS if it has been set */
   If &oDSDefn <> Null Then
      Return &oDSDefn;
   End-If;
   
   If Len(&Report.Ds_id) = 0 Or
         Len(&Report.Ds_type) = 0 Then
      Return Null;
   End-If;
   
   &Public = True;
   If &Report.Opr_Id <> &PSXP_PublicDSOprID And
         Len(&Report.Opr_Id) > 0 Then
      &Public = False;
   End-If;
   
   &oDSDefn = create PSXP_RPTDEFNMANAGER:DataSourceDefn(&Report.Ds_type, &Report.Ds_id, &Public);
   &oDSDefn.Get();
   
   Return &oDSDefn;
end-method;


/* ****************************************************** */
/* SetDatasource method                              */
/* ****************************************************** */
method SetDatasource
   /+ &DatasourceID as String, +/
   /+ &DatasourceType as String, +/
   /+ &Public as Boolean +/
   Local string &newOprID;
   
   If &Public Then
      &newOprID = &PSXP_PublicDSOprID;
   Else
      &newOprID = %OperatorId;
   End-If;
   
   If &Report.Ds_id = &DatasourceID And
         &Report.Ds_type = &DatasourceType And
         &Report.Opr_Id = &newOprID Then
      Return;
   End-If;
   
   &DefnChanged = True;
   &Report.Ds_id = &DatasourceID;
   &Report.Ds_type = &DatasourceType;
   &Report.Opr_Id = &newOprID;
   
   If Not &oQuery = Null Then
      &oQuery.Close();
      &oQuery = Null;
   End-If;
   &recQryPrompt = Null;
end-method;


/* ****************************************************** */
/* EnableOutputFormat method                              */
/* ****************************************************** */
method EnableOutputFormat
   /+ &FormatType as String +/
   Local %metadata:XMLPubRptMgr:OutFormat &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptoutfmt
      &oInfo = &Report.Get_Xprptoutfmt(&i);
      If &oInfo.Format_type = &FormatType Then
         Return;
      End-If;
   End-For;
   
   &DefnChanged = True;
   &oInfo = &Report.Append_Xprptoutfmt(&Report.Count_Xprptoutfmt);
   &oInfo.Format_type = &FormatType;
   &oInfo.Is_default = "N";
end-method;


/* ****************************************************** */
/* DisableOutputFormat method                              */
/* ****************************************************** */
method DisableOutputFormat
   /+ &FormatType as String +/
   Local %metadata:XMLPubRptMgr:OutFormat &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptoutfmt
      &oInfo = &Report.Get_Xprptoutfmt(&i);
      If &oInfo.Format_type = &FormatType Then
         &DefnChanged = True;
         &Report.Delete_Xprptoutfmt(&i);
         Return;
      End-If;
   End-For;
end-method;


/* ****************************************************** */
/* GetOutputFormats method                              */
/* ****************************************************** */
method GetOutputFormats
   /+ Returns Array of String +/
   Local array of string &aFormats;
   Local %metadata:XMLPubRptMgr:OutFormat &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptoutfmt
      &oInfo = &Report.Get_Xprptoutfmt(&i);
      
      If &aFormats = Null Then
         &aFormats = CreateArray(&oInfo.Format_type);
      Else
         &aFormats.Push(&oInfo.Format_type);
      End-If;
   End-For;
   
   Return &aFormats;
end-method;


/* ****************************************************** */
/* GetDefaultOutputFormat method                              */
/* ****************************************************** */
method GetDefaultOutputFormat
   /+ Returns String +/
   Local %metadata:XMLPubRptMgr:OutFormat &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptoutfmt
      &oInfo = &Report.Get_Xprptoutfmt(&i);
      If &oInfo.Is_default = "Y" Or
            &oInfo.Is_default = "y" Then
         Return &oInfo.Format_type;
      End-If;
   End-For;
   
   Return "";
end-method;


/* ****************************************************** */
/* SetDefaultOutputFormat method                              */
/* ****************************************************** */
method SetDefaultOutputFormat
   /+ &FormatType as String +/
   Local %metadata:XMLPubRptMgr:OutFormat &oInfo;
   Local string &sFmt;
   Local boolean &bFound;
   Local integer &i;
   
   If &FormatType = %This.GetDefaultOutputFormat() Then
      Return;
   End-If;
   
   &DefnChanged = True;
   
   &bFound = False;
   For &i = 1 To &Report.Count_Xprptoutfmt
      &oInfo = &Report.Get_Xprptoutfmt(&i);
      If &oInfo.Format_type = &FormatType Then
         &bFound = True;
         &oInfo.Is_default = "Y";
      Else
         &oInfo.Is_default = "N";
      End-If;
   End-For;
   
   If Not &bFound Then
      &oInfo = &Report.Append_Xprptoutfmt(&Report.Count_Xprptoutfmt);
      &oInfo.Format_type = &FormatType;
      &oInfo.Is_default = "Y";
   End-If;
end-method;


/* ****************************************************** */
/* IsOutputFormatEnabled method                              */
/* ****************************************************** */
method IsOutputFormatEnabled
   /+ &FormatType as String +/
   /+ Returns Boolean +/
   Local %metadata:XMLPubRptMgr:OutFormat &oInfo;
   Local integer &i;
   
   If ((&FormatType = "PCL") Or
         (&FormatType = "PS")) Then
      &FormatType = "PDF";
   End-If;
   
   For &i = 1 To &Report.Count_Xprptoutfmt
      &oInfo = &Report.Get_Xprptoutfmt(&i);
      If &oInfo.Format_type = &FormatType Then
         Return True;
      End-If;
   End-For;
   
   Return False;
end-method;


/* ****************************************************** */
/* AddReportViewer method                              */
/* ****************************************************** */
method AddReportViewer
   /+ &DistIDType as String, +/
   /+ &DistID as String +/
   Local %metadata:XMLPubRptMgr:RptViewer &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptviewer
      &oInfo = &Report.Get_Xprptviewer(&i);
      If &oInfo.Distidtype = &DistIDType And
            &oInfo.Distid = &DistID Then
         Return;
      End-If;
   End-For;
   
   &DefnChanged = True;
   &oInfo = &Report.Append_Xprptviewer(&Report.Count_Xprptviewer);
   &oInfo.Distidtype = &DistIDType;
   &oInfo.Distid = &DistID;
end-method;


/* ****************************************************** */
/* DeleteReportViewer method                              */
/* ****************************************************** */
method DeleteReportViewer
   /+ &DistIdType as String, +/
   /+ &DistID as String +/
   Local %metadata:XMLPubRptMgr:RptViewer &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptviewer
      &oInfo = &Report.Get_Xprptviewer(&i);
      If &oInfo.Distidtype = &DistIdType And
            &oInfo.Distid = &DistID Then
         &DefnChanged = True;
         &Report.Delete_Xprptviewer(&i);
         Return;
      End-If;
   End-For;
   
   rem throw CreateException(&PSXP_MsgSet, 2021, "Report viewer %1 type %2 not found in the report definition.", &DistID, &DistIdType);
end-method;


/* ****************************************************** */
/* GetReportViewers method                            */
/* ****************************************************** */
method GetReportViewers
   /+ Returns Array of PSXP_RPTDEFNMANAGER:ReportViewer +/
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &aViewers;
   Local PSXP_RPTDEFNMANAGER:ReportViewer &oViewer;
   Local %metadata:XMLPubRptMgr:RptViewer &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptviewer
      &oInfo = &Report.Get_Xprptviewer(&i);
      &oViewer = create PSXP_RPTDEFNMANAGER:ReportViewer(&oInfo.Distidtype, &oInfo.Distid);
      
      If &aViewers = Null Then
         &aViewers = CreateArray(&oViewer);
      Else
         &aViewers.Push(&oViewer);
      End-If;
   End-For;
   
   Return &aViewers;
end-method;


/* ****************************************************** */
/* IsReportViewerEnabled method                            */
/* ****************************************************** */
method IsReportViewerEnabled
   /+ &DistIDType as String, +/
   /+ &DistID as String +/
   /+ Returns Boolean +/
   Local %metadata:XMLPubRptMgr:RptViewer &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptviewer
      &oInfo = &Report.Get_Xprptviewer(&i);
      If &oInfo.Distidtype = &DistIDType And
            &oInfo.Distid = &DistID Then
         Return True;
      End-If;
   End-For;
   
   Return False;
end-method;


/* ****************************************************** */
/* GetScopeFields method                            */
/* ****************************************************** */
method GetScopeFields
   /+ Returns Array of PSXP_RPTDEFNMANAGER:ScopeField +/
   Local array of PSXP_RPTDEFNMANAGER:ScopeField &aScopes;
   Local PSXP_RPTDEFNMANAGER:ScopeField &oScope;
   Local %metadata:XMLPubRptMgr:RptScopeFld &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptscopefld
      &oInfo = &Report.Get_Xprptscopefld(&i);
      &oScope = create PSXP_RPTDEFNMANAGER:ScopeField(&oInfo.Ds_field_name, &oInfo.Sec_join_fld_name);
      
      If &aScopes = Null Then
         &aScopes = CreateArray(&oScope);
      Else
         &aScopes.Push(&oScope);
      End-If;
   End-For;
   
   Return &aScopes;
end-method;


/* ****************************************************** */
/* AddScopeField method                            */
/* ****************************************************** */
method AddScopeField
   /+ &DataSrcFieldName as String, +/
   /+ &SecJoinTblFieldName as String +/
   Local %metadata:XMLPubRptMgr:RptScopeFld &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptscopefld
      &oInfo = &Report.Get_Xprptscopefld(&i);
      If &oInfo.Ds_field_name = &DataSrcFieldName And
            &oInfo.Sec_join_fld_name = &SecJoinTblFieldName Then
         rem throw CreateException(&PSXP_MsgSet, 2015, "Scope field %1 %2 already exists in the report definition.", &DataSrcFieldName, &SecJoinTblFieldName);
         Return;
      End-If;
   End-For;
   
   &DefnChanged = True;
   &oInfo = &Report.Append_Xprptscopefld(&Report.Count_Xprptscopefld);
   &oInfo.Ds_field_name = &DataSrcFieldName;
   &oInfo.Sec_join_fld_name = &SecJoinTblFieldName;
end-method;


/* ****************************************************** */
/* DeleteScopeField method                            */
/* ****************************************************** */
method DeleteScopeField
   /+ &DataSrcFieldName as String, +/
   /+ &SecJoinTblFieldName as String +/
   Local %metadata:XMLPubRptMgr:RptScopeFld &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptscopefld
      &oInfo = &Report.Get_Xprptscopefld(&i);
      If &oInfo.Ds_field_name = &DataSrcFieldName And
            &oInfo.Sec_join_fld_name = &SecJoinTblFieldName Then
         &DefnChanged = True;
         &Report.Delete_Xprptscopefld(&i);
         Return;
      End-If;
   End-For;
   
end-method;


/* ****************************************************** */
/* AddSearchField method                            */
/* ****************************************************** */
method AddSearchField
   /+ &FieldName as String +/
   Local %metadata:XMLPubRptMgr:RptSrchKeys &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptsrchkeys
      &oInfo = &Report.Get_Xprptsrchkeys(&i);
      If &oInfo.Search_fieldname = &FieldName Then
         Return;
      End-If;
   End-For;
   
   &DefnChanged = True;
   &oInfo = &Report.Append_Xprptsrchkeys(&Report.Count_Xprptsrchkeys);
   &oInfo.Search_fieldname = &FieldName;
end-method;


/* ****************************************************** */
/* DeleteSearchField method                            */
/* ****************************************************** */
method DeleteSearchField
   /+ &FieldName as String +/
   Local %metadata:XMLPubRptMgr:RptSrchKeys &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptsrchkeys
      &oInfo = &Report.Get_Xprptsrchkeys(&i);
      If &oInfo.Search_fieldname = &FieldName Then
         &DefnChanged = True;
         &Report.Delete_Xprptsrchkeys(&i);
         Return;
      End-If;
   End-For;
   
end-method;


/* ****************************************************** */
/* GetSearchFields method                            */
/* ****************************************************** */
method GetSearchFields
   /+ Returns Array of String +/
   Local array of string &aFields;
   Local %metadata:XMLPubRptMgr:RptSrchKeys &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptsrchkeys
      &oInfo = &Report.Get_Xprptsrchkeys(&i);
      If &aFields = Null Then
         &aFields = CreateArray(&oInfo.Search_fieldname);
      Else
         &aFields.Push(&oInfo.Search_fieldname);
      End-If;
   End-For;
   
   Return &aFields;
end-method;


/* ****************************************************** */
/* GetProperties method                            		  */
/* ****************************************************** */
method GetProperties
   /+ Returns PSXP_ENGINE:Properties +/
   
   Local PSXP_ENGINE:Properties &oProps;
   Local boolean &bRes;
   Local %metadata:XMLPubRptMgr:RptProp &oInfo;
   Local integer &i;
   &oProps = create PSXP_ENGINE:Properties();
   
   For &i = 1 To &Report.Count_Xprptprop
      &oInfo = &Report.Get_Xprptprop(&i);
      &bRes = &oProps.setProperty(&oInfo.PropName, &oInfo.PropValue);
   End-For;
   
   Return &oProps;
   
end-method;


/* ****************************************************** */
/* AddProperty method                            		  */
/* ****************************************************** */
method AddProperty
   /+ &sPropName as String, +/
   /+ &sPropValue as String +/
   Local %metadata:XMLPubRptMgr:RptProp &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptprop
      &oInfo = &Report.Get_Xprptprop(&i);
      If &oInfo.PropName = &sPropName And
            &oInfo.PropValue = &sPropValue Then
         Return;
      End-If;
   End-For;
   
   &DefnChanged = True;
   &oInfo = &Report.Append_Xprptprop(&Report.Count_Xprptprop);
   &oInfo.PropName = &sPropName;
   &oInfo.PropValue = &sPropValue;
   
end-method;


/* ****************************************************** */
/* DeleteProperty method                            	  */
/* ****************************************************** */
method DeleteProperty
   /+ &sPropName as String +/
   Local %metadata:XMLPubRptMgr:RptProp &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprptprop
      &oInfo = &Report.Get_Xprptprop(&i);
      If &oInfo.PropName = &sPropName Then
         &DefnChanged = True;
         &Report.Delete_Xprptprop(&i);
         Return;
      End-If;
   End-For;
end-method;


/* ****************************************************** */
/* GetTemplateControlList method                            */
/* ****************************************************** */
method GetTemplateControlList
   /+ Returns Array of PSXP_RPTDEFNMANAGER:TemplateControl +/
   Local PSXP_RPTDEFNMANAGER:TemplateControl &oControl;
   Local %metadata:XMLPubRptMgr:RptTmpltCntrl &oInfo;
   Local integer &i;
   
   If &TmpCtrls = Null Then
      For &i = 1 To &Report.Count_Xprpttmplctrl
         &oInfo = &Report.Get_Xprpttmplctrl(&i);
         &oControl = create PSXP_RPTDEFNMANAGER:TemplateControl(%This, &oInfo.Xpfieldvalue);
         
         If &TmpCtrls = Null Then
            &TmpCtrls = CreateArray(&oControl);
         Else
            &TmpCtrls.Push(&oControl);
         End-If;
      End-For;
   End-If;
   
   Return &TmpCtrls;
end-method;


/* ****************************************************** */
/* GetTemplateControl method                            */
/* ****************************************************** */
method GetTemplateControl
   /+ &FieldValue as String +/
   /+ Returns PSXP_RPTDEFNMANAGER:TemplateControl +/
   Local array of PSXP_RPTDEFNMANAGER:TemplateControl &aControls;
   Local PSXP_RPTDEFNMANAGER:TemplateControl &oControl;
   Local %metadata:XMLPubRptMgr:RptTmpltCntrl &oInfo;
   Local integer &i;
   
   &aControls = %This.GetTemplateControlList();
   
   If Not &TmpCtrls = Null Then
      For &i = 1 To &TmpCtrls.Len
         &oControl = &TmpCtrls [&i];
         If &oControl.FieldValue = &FieldValue Then
            Return &oControl;
         End-If;
      End-For;
   End-If;
   
   Return Null;
end-method;


/* ****************************************************** */
/* AddTemplateControl method                            */
/* ****************************************************** */
method AddTemplateControl
   /+ &FieldValue as String +/
   /+ Returns PSXP_RPTDEFNMANAGER:TemplateControl +/
   Local array of PSXP_RPTDEFNMANAGER:TemplateControl &aControls;
   Local PSXP_RPTDEFNMANAGER:TemplateControl &oControl;
   Local %metadata:XMLPubRptMgr:RptTmpltCntrl &oInfo;
   Local integer &i;
   
   &aControls = %This.GetTemplateControlList();
   
   /* search existing */
   If Not &TmpCtrls = Null Then
      For &i = 1 To &TmpCtrls.Len
         &oControl = &TmpCtrls [&i];
         If &oControl.FieldValue = &FieldValue Then
            throw CreateException(&PSXP_MsgSet, 2520, "Template control %1 already exists in the report definition.", &FieldValue);
         End-If;
      End-For;
   End-If;
   
   /* append new */
   &DefnChanged = True;
   &oInfo = &Report.Append_Xprpttmplctrl(&Report.Count_Xprpttmplctrl);
   If &oInfo = Null Then
      throw CreateException(&PSXP_MsgSet, 2521, "Can't add template control %1 to the report definition.", &FieldValue);
   End-If;
   
   /* Initialize */
   &oInfo.Xpfieldvalue = &FieldValue;
   
   &oControl = create PSXP_RPTDEFNMANAGER:TemplateControl(%This, &FieldValue);
   If &TmpCtrls = Null Then
      &TmpCtrls = CreateArray(&oControl);
   Else
      &TmpCtrls.Push(&oControl);
   End-If;
   
   Return &oControl;
end-method;


/* ****************************************************** */
/* DeleteTemplateControl method                            */
/* ****************************************************** */
method DeleteTemplateControl
   /+ &FieldValue as String +/
   Local array of PSXP_RPTDEFNMANAGER:TemplateControl &aControls;
   Local PSXP_RPTDEFNMANAGER:TemplateControl &oControl;
   Local %metadata:XMLPubRptMgr:RptTmpltCntrl &oInfo;
   Local integer &i;
   
   &aControls = %This.GetTemplateControlList();
   
   If Not &TmpCtrls = Null Then
      For &i = 1 To &TmpCtrls.Len
         &oControl = &TmpCtrls [&i];
         If &oControl.FieldValue = &FieldValue Then
            &DefnChanged = True;
            %This.InternalDeleteTemplateControl(&i);
            Return;
         End-If;
      End-For;
   End-If;
   
   throw CreateException(&PSXP_MsgSet, 2519, "Template control %1 not found in the report definition.", &FieldValue);
end-method;

method InternalDeleteTemplateControl
   /+ &nInx as Integer +/
   Local array of PSXP_RPTDEFNMANAGER:TemplateControl &newTmpCtrls;
   Local PSXP_RPTDEFNMANAGER:TemplateControl &oControl;
   Local %metadata:XMLPubRptMgr:RptTmpltCntrl &oInfo;
   Local string &sFieldValue;
   Local integer &i, &j, &k;
   
   &oControl = &TmpCtrls [&nInx];
   &sFieldValue = &oControl.FieldValue;
   
   /* remove the delete */
   &j = &nInx - 1;
   For &i = 1 To &j
      &oControl = &TmpCtrls [&i];
      
      If &newTmpCtrls = Null Then
         &newTmpCtrls = CreateArray(&oControl);
      Else
         &newTmpCtrls.Push(&oControl);
      End-If;
   End-For;
   
   &j = &nInx + 1;
   &k = &TmpCtrls.Len;
   For &i = &j To &k
      &oControl = &TmpCtrls [&i];
      
      If &newTmpCtrls = Null Then
         &newTmpCtrls = CreateArray(&oControl);
      Else
         &newTmpCtrls.Push(&oControl);
      End-If;
   End-For;
   
   &TmpCtrls = &newTmpCtrls;
   
   /* remove metadata */
   For &i = 1 To &Report.Count_Xprpttmplctrl
      &oInfo = &Report.Get_Xprpttmplctrl(&i);
      If &oInfo.Xpfieldvalue = &sFieldValue Then
         &Report.Delete_Xprpttmplctrl(&i);
         Return;
      End-If;
   End-For;
end-method;


/* ****************************************************** */
/* SetRuntimeProperties method                            */
/* ****************************************************** */
method SetRuntimeProperties
   /+ &asName as Array of String, +/
   /+ &asValue as Array of String +/
   
   If &asName = Null And
         &asValue = Null Then
      Return;
   End-If;
   
   If &asName.Len = 0 Or
         &asName.Len <> &asValue.Len Then
      throw CreateException(&PSXP_MsgSet, 2024, "The runtime properties are not valid. Names and Values do not match.");
   End-If;
   &oRuntimeProperties = create PSXP_ENGINE:Properties();
   
   rem rshwe TODO move inside new Properties.encrypt() method ;
   Local array of string &asTempValue = &asValue;
   Local integer &i;
   For &i = 1 To &asName.Len
      rem these properties are hardcoded for performance reasons, otherwise property type need to be checked in PSXPXDOPROP;
      If (&asName [&i] = "pdf-open-password" Or
            &asName [&i] = "pdf-permissions-password") And
            &asTempValue [&i] <> "" Then
         &asTempValue [&i] = Encrypt("xmlpprop", RTrim(LTrim(&asTempValue [&i])));
      End-If;
   End-For;
   
   If Not &oRuntimeProperties.overrideWithArray(&asName, &asTempValue) Then
      throw CreateException(&PSXP_MsgSet, 2024, "The runtime properties are not valid. Names and Values do not match.");
   End-If;
   
end-method;


/* ****************************************************** */
/* SetRuntimeDataXMLDoc method                            */
/* ****************************************************** */
method SetRuntimeDataXMLDoc
   /+ &Data as XmlDoc +/
   &DataXMLDoc = &Data;
end-method;


/* ****************************************************** */
/* SetRuntimeDataRowset method                            */
/* ****************************************************** */
method SetRuntimeDataRowset
   /+ &Data as Rowset +/
   &DataRowSet = &Data;
end-method;


/* ****************************************************** */
/* SetRuntimeDataXMLFile method                            */
/* ****************************************************** */
method SetRuntimeDataXMLFile
   /+ &Data as String +/
   &DataXMLFile = &Data;
end-method;


/* ****************************************************** */
/* SetPrinterType method                                  */
/* ****************************************************** */
method SetPrinterType
   /+ &OutDestFormat as String +/
   If ((&OutDestFormat = "PDF") Or
         (&OutDestFormat = "PCL") Or
         (&OutDestFormat = "PS")) Then
      &sPrinterType = &OutDestFormat;
   Else
      WriteToLog(%ApplicationLogFence_Warning, "Warning! Invalid Printer Format - " | &OutDestFormat);
      
   End-If;
end-method;


/* ****************************************************** */
/* GetPSQueryPromptRecord method                          */
/* ****************************************************** */
method GetPSQueryPromptRecord
   /+ Returns Record +/
   If &Report.Ds_type = "QRY" And
         %This.OpenQueryDs() Then
      /* mdu ICE 1600174000  a call below to &oQuery.RuntimePrompts.Count
      is used to fully populate prompts collection before calling for 
       .PromptRecord in case of 'old queries' */
      Local integer &nTotalPrompts = &oQuery.RuntimePrompts.Count;
      Return &oQuery.PromptRecord;
   End-If;
   Return Null;
end-method;

/* ****************************************************** */
/* SetPSQueryPromptRecord method                          */
/* ****************************************************** */
method SetPSQueryPromptRecord
   /+ &PromptRecord as Record +/
   If &Report.Ds_type = "QRY" Then
      &recQryPrompt = &PromptRecord;
   End-If;
end-method;



rem rshwe;
rem this should only be called once, and early in processreport() (runtime properties already set);
method processFinalProperties
   
   Local string &sep = ""; /* MD Signature */
   Local boolean &bres; /* MD Submit */
   
   If %This.UseGlobalProperties Then
      %This.oFinalProperties = &MyUtil.GetGlobalProperties();
   Else
      %This.oFinalProperties = create PSXP_ENGINE:Properties();
   End-If;
   
   %This.oFinalProperties.override(%This.GetProperties());
   
   If &oRuntimeProperties <> Null Then
      %This.oFinalProperties.override(&oRuntimeProperties);
   End-If;
   %This.oFinalProperties.decrypt();
   
   rem rshpdf;
   Local string &sPropValue;
   If %This.oFinalProperties.getProperty("psxp_pdf_optimized", &sPropValue) = True And
         &sPropValue = "False" Then
      &UsePDFOptimized = False;
   Else
      &UsePDFOptimized = True;
   End-If;
   
   /* outdestin */
   If %This.oFinalProperties.getProperty("psxp_usedefaultoutdestination", &sPropValue) = True And
         &sPropValue = "True" Then
      &UseDefaultOutDestination = True;
   Else
      &UseDefaultOutDestination = False;
   End-If;
   
   /* If public property &Debug set in the code - use it;
      if not check property table */
   If Not &Debug Then
      If %This.oFinalProperties.getProperty("psxp_debug", &sPropValue) = True And
            &sPropValue = "True" Then
         &Debug = True;
      Else
         &Debug = False;
      End-If;
   End-If;
   
   /* ICE 2038507000 */
   If %This.oFinalProperties.getProperty("psxp_nocdatafields", &sPropValue) = True Then
      If All(&sPropValue) Then
         /* 17555747 - Query or CQ fields are always uppercase*/
         If &Report.Ds_type = "QRY" Or
               &Report.Ds_type = "CQR" Then
            &sPropValue = Upper(&sPropValue);
         End-If;
         
         &sep = &MyUtil.GetStringSeparator(&sPropValue); /* get a delimiter */
         If None(&sep) Then
            &sep = " ";
         End-If;
         
         &aNoCDATAFields = Split(&sPropValue, &sep);
         
      Else
         &aNoCDATAFields = Null;
      End-If;
   End-If;
   
   /* MD 935062 */
   /* identical password values should not be allowed in PDF Security */
   Local string &sOpenPwd, &sPermPwd;
   If &sOutDestFormat = "PDF" Then
      If %This.oFinalProperties.getProperty("pdf-security", &sPropValue) = True Then
         If &sPropValue = "True" Then
            If %This.oFinalProperties.getProperty("pdf-open-password", &sPropValue) = True Then
               &sOpenPwd = &sPropValue;
               If %This.oFinalProperties.getProperty("pdf-permissions-password", &sPropValue) = True Then
                  &sPermPwd = &sPropValue;
                  If All(&sPermPwd, &sOpenPwd) And
                        &sPermPwd = &sOpenPwd Then
                     throw CreateException(&PSXP_MsgSet, 999, "PDF Security Passwords");
                  End-If;
               End-If;
            End-If;
         End-If;
      End-If;
   End-If;
   &sPropValue = "";
   
   
   /* MD OIT */
   If &sOutDestFormat = "PDF" Then
      If &pdfConversionTimeOut = 0 Then /* run time property has not been set, so getting value from the global settings */
         If %This.oFinalProperties.getProperty("psxp_pdfconversion_timeout", &sPropValue) = True Then
            &pdfConversionTimeOut = Value(LTrim(RTrim(&sPropValue)));
            If &pdfConversionTimeOut = 0 Then
               &pdfConversionTimeOut = &PSXP_PDFConverterTimeOut;
            End-If;
         Else
            &pdfConversionTimeOut = &PSXP_PDFConverterTimeOut;
         End-If;
      End-If;
   End-If;
   
   
   /* MD Signature */
   If &sOutDestFormat = "PDF" Then
      If %This.oFinalProperties.getProperty("signature-enable", &sPropValue) = True And
            &sPropValue = "True" Then
         &IsPDFSignatureRequired = True;
      Else
         &IsPDFSignatureRequired = False;
      End-If;
   End-If;
   
   /* Getting a list of data fields from report properties that could affect selecting a Digital Signer */
   If &IsPDFSignatureRequired Then
      If %This.oFinalProperties.getProperty("pdf-security", &sPropValue) = True Then
         If &sPropValue = "True" Then
            If %This.oFinalProperties.getProperty("pdf-open-password", &sPropValue) = True Then
               If &sPropValue <> "" Then
                  &bReportWasSecured = True; /* flag to be used when failed report is cleaning up and debug is true */
               End-If;
            End-If;
         End-If;
      End-If;
      &sPropValue = "";
      
      If %This.oFinalProperties.getProperty("psxp_signature_mapfields", &sPropValue) = True Then
         If All(&sPropValue) Then
            &sPropValue = Upper(&sPropValue);
            &sep = &MyUtil.GetStringSeparator(&sPropValue); /* get a delimiter */
            If None(&sep) Then
               &sep = " ";
            End-If;
            &aSignatureFields = Split(&sPropValue, &sep);
         Else
            &aSignatureFields = Null;
         End-If;
      End-If;
   End-If;
   
   /* MD ext email */
   /* Report should be scheduled with EMAIL output (&outdesttype=5)  and have psxp_ext_email_appclass property set */
   If &ProcessInstance > 0 And
         %This.oFinalProperties.getProperty("psxp_ext_email_appclass", &sPropValue) = True And
         All(&sPropValue) Then
      
      Local string &sql = "select OUTDESTTYPE from PSPRCSRQST where PRCSINSTANCE=:1";
      Local number &outdesttype;
      SQLExec(&sql, &ProcessInstance, &outdesttype);
      If &outdesttype = 5 Then
         &bIsExtEmail = True;
         &extEmailAppclass = RTrim(LTrim(&sPropValue));
      Else
         &bIsExtEmail = False;
         &extEmailAppclass = "";
      End-If;
   End-If;
   
   /* OIT Merge */
   /* Temporary disabling PDF Security in a case we are using PDF Conversion process */
   If &arrPDFConversion.Len > 0 Then
      If %This.oFinalProperties.getProperty("pdf-security", &sPropValue) = True Then
         If &sPropValue = "True" Then
            &bres = %This.oFinalProperties.setProperty("pdf-security", "False");
            &IsPDFExportSecurityDisabled = True;
         End-If;
      End-If;
   End-If;
   
   /* MD Submit */
   /* Properties processing only for submittable reports  */
   If Not (%This.TemplateType = "PDF") Then
      Return;
   End-If;
   
   
   
   If %This.SetStaticPDFReport Then
      &bres = %This.oFinalProperties.setProperty("remove-pdf-fields", "True");
      Return;
   End-If;
   
   
   If %This.oFinalProperties.getProperty("psxp_submit_enable", &sPropValue) = True And
         Upper(&sPropValue) = "TRUE" Then
      If %This.oFinalProperties.getProperty("psxp_submit_appclass", &sPropValue) = True And
            (&sPropValue = "" Or
               &sPropValue = " ") Then
         WriteToLog(%ApplicationLogFence_Level1, "'psxp_submit_appclass' is not populated in the report properties. Report will be created as a static one.");
         &IsPDFSubmitEnabled = False;
         &bres = %This.oFinalProperties.setProperty("psxp_submit_enable", "False");
         Return;
      Else
         &IsPDFSubmitEnabled = True;
      End-If;
   End-If;
   
   /* MD res. 919419 */
   /* checking if user calls updatable report from a mobile non-windows device */
   If &ProcessInstance = 0 And
         %Request <> Null Then
      Local boolean &isMobile;
      Local string &MobileTestStr = "android,ipad,iphone,ipod,blackberry,symbianos,symbos,phone,mobile,tablet";
      Local array of string &MobileArr = Split(&MobileTestStr, ",");
      
      Local string &userAgent = Lower(%Request.GetHeader("User-Agent"));
      
      /* For Windows OS (Surface tablet, Windows 2008 laptop with a touch screen,etc.) we should ignore mobile restrictions.  Res 933955 (8.55-12B) */
      If Find("windows", &userAgent) = 0 Then
         
         Local number &ind;
         For &ind = 1 To &MobileArr.Len
            If Find(&MobileArr [&ind], &userAgent) > 0 Then
               &isMobile = True;
               Break;
            End-If;
         End-For;
         
         If &isMobile Then
            WriteToLog(%ApplicationLogFence_Level1, "User Agent is: " | &userAgent);
            WriteToLog(%ApplicationLogFence_Level1, MsgGetText(&PSXP_MsgSet, 261, "Using mobile devices for submitting PDF forms currently is not supported"));
            
            /* Getting submittable property to be used only for mobile devices */
            Local integer &reply = MessageBox(%MsgStyle_YesNo, "", 235, 263, "This form cannot be updated using a mobile device.");
            If &reply <> %MsgResult_Yes Then
               throw CreateException(&PSXP_MsgSet, 999, " ");
            Else
               &IsPDFSubmitEnabled = False;
               &bres = %This.oFinalProperties.setProperty("remove-pdf-fields", "True");
            End-If;
         End-If;
         
      End-If; /* MD Res 933955 end */
      
   End-If; /* MD res. 919419 end */
   
   If Not &IsPDFSubmitEnabled Then
      Return;
   End-If;
   
   /* correct/override  required properties for Submittable report */
   Local string &sOverride = Char(10) | "The following report properties should be used for submittable report:";
   &sOverride = &sOverride | Char(10) | "psxp_submit_enable = True";
   &sOverride = &sOverride | Char(10) | "psxp_pdf_optimized = False";
   &sOverride = &sOverride | Char(10) | "signature-enable = False";
   &sOverride = &sOverride | Char(10) | "pdf-security = False";
   &sOverride = &sOverride | Char(10) | "pdf-no-changing-the-document = False";
   &sOverride = &sOverride | Char(10) | "pdf-changes-allowed = 2";
   &sOverride = &sOverride | Char(10) | "if all-field-readonly = True then all-fields-readonly-asis = True" | Char(10);
   
   
   If &UsePDFOptimized Then
      &bres = %This.oFinalProperties.setProperty("psxp_pdf_optimized", "False");
      &UsePDFOptimized = False;
   End-If;
   
   If %This.oFinalProperties.getProperty("signature-enable", &sPropValue) = True Then
      &bres = %This.oFinalProperties.setProperty("signature-enable", "False");
   End-If;
   
   If %This.oFinalProperties.getProperty("pdf-no-changing-the-document", &sPropValue) = True Then
      &bres = %This.oFinalProperties.setProperty("pdf-no-changing-the-document", "False");
   End-If;
   
   If %This.oFinalProperties.getProperty("pdf-changes-allowed", &sPropValue) = True Then
      &bres = %This.oFinalProperties.setProperty("pdf-changes-allowed", "2");
   End-If;
   
   Local string &sPropVal_AsIs;
   If %This.oFinalProperties.getProperty("all-field-readonly", &sPropValue) = True And
         Upper(&sPropValue) = "TRUE" Then
      If %This.oFinalProperties.getProperty("all-fields-readonly-asis", &sPropVal_AsIs) = True And
            Upper(&sPropVal_AsIs) = "FALSE" Then
         &bres = %This.oFinalProperties.setProperty("all-fields-readonly-asis", "True");
      End-If;
   End-If;
   
   
   /* setting default values */
   If %This.oFinalProperties.getProperty("psxp_submit_service_operation_alias", &sPropValue) Then
      If None(&sPropValue) Then
         &bres = %This.oFinalProperties.setProperty("psxp_submit_service_operation_alias", "PSXP_PDF_SUBMIT");
      End-If;
   Else
      &bres = %This.oFinalProperties.setProperty("psxp_submit_service_operation_alias", "PSXP_PDF_SUBMIT");
   End-If;
   
   If %This.oFinalProperties.getProperty("psxp_submit_service_operation_version", &sPropValue) Then
      If None(&sPropValue) Then
         &bres = %This.oFinalProperties.setProperty("psxp_submit_service_operation_version", "v1");
      End-If;
   Else
      &bres = %This.oFinalProperties.setProperty("psxp_submit_service_operation_version", "v1");
   End-If;
   
   If %This.oFinalProperties.getProperty("psxp_submit_location", &sPropValue) Then
      If None(&sPropValue) Then
         &bres = %This.oFinalProperties.setProperty("psxp_submit_location", "bottom-right");
      End-If;
   Else
      &bres = %This.oFinalProperties.setProperty("psxp_submit_location", "bottom-right");
   End-If;
   
   
   If %This.oFinalProperties.getProperty("psxp_submit_caption", &sPropValue) Then
      If None(&sPropValue) Then
         &bres = %This.oFinalProperties.setProperty("psxp_submit_caption", MsgGetText(235, 250, "###Submit"));
      End-If;
   Else
      &bres = %This.oFinalProperties.setProperty("psxp_submit_caption", MsgGetText(235, 250, "###Submit"));
   End-If;
   
   
   If %This.oFinalProperties.getProperty("psxp_submit_tooltip", &sPropValue) Then
      If None(&sPropValue) Then
         &bres = %This.oFinalProperties.setProperty("psxp_submit_tooltip", MsgGetText(235, 251, "###Press this button to submit your data"));
      End-If;
   Else
      &bres = %This.oFinalProperties.setProperty("psxp_submit_tooltip", MsgGetText(235, 251, "###Press this button to submit your data"));
   End-If;
   
   
   If %This.oFinalProperties.getProperty("psxp_submit_use_HTTPS", &sPropValue) Then
      If None(&sPropValue) Then
         &bres = %This.oFinalProperties.setProperty("psxp_submit_use_HTTPS", "True");
      End-If;
   Else
      &bres = %This.oFinalProperties.setProperty("psxp_submit_use_HTTPS", "True");
   End-If;
   
   
   
   /* disabling updatable PDF reports if security is st on the report definition */
   If %This.oFinalProperties.getProperty("pdf-security", &sPropValue) = True Then
      If &sPropValue = "True" Then
         Local string &securityErr = "Report property pdf-security should be set to false in order to use submittable report.";
         &securityErr = &securityErr | "Disabling submittable features.";
         WriteToLog(%ApplicationLogFence_Level1, &securityErr);
         &bres = %This.oFinalProperties.setProperty("remove-pdf-fields", "True");
         &IsPDFSubmitEnabled = False;
         Return;
      End-If;
   End-If;
   
   
   &IsPDFSubmitEnabled = True;
   
   If %This.Debug Then
      WriteToLog(%ApplicationLogFence_Level1, &sOverride);
   End-If;
   
   
end-method; /* processFinalProperties */


/* ****************************************************** */
/* ProcessReport method                                   */
/* ****************************************************** */
method ProcessReport
   /+ &TemplateID as String, +/
   /+ &LanguageCd as String, +/
   /+ &AsOfDate as Date, +/
   /+ &OutputFormat as String +/
   Local string &sProcessId, &sOutputDir;
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpl;
   Local PSXP_RPTDEFNMANAGER:TemplateFile &oTmplFile;
   Local string &sLocaleCd;
   Local string &sTmplFile, &sMapFile, &sXliffFile;
   Local string &sXmlData;
   Local PSXP_RPTDEFNMANAGER:ReportOutput &oReportOut;
   Local XmlDoc &oXmlDoc;
   Local array of XmlNode &aryBurstNode;
   Local array of string &aryNodePath;
   Local string &sLastNodeVal;
   Local XmlDoc &oBurstDoc;
   Local XmlNode &oBurstNode, &oBaseNode, &oSrcBaseNode;
   Local number &cnt;
   Local string &sAttribName;
   Local number &nBurstIdx;
   Local string &sLocalOutputFile, &sDataFile;
   Local integer &nOutputFormat;
   Local string &sFileExt;
   Local string &sErr;
   Local number &i, &j;
   Local array of XmlNode &aryTplCtlNode;
   Local string &sTmplCtrlFldValue;
   Local PSXP_RPTDEFNMANAGER:TemplateControl &oTmplCtrl;
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oCtlTmpl;
   Local PSXP_RPTDEFNMANAGER:TemplateFile &oCtlTmplFile;
   Local string &sCtlTmplFile, &sCtlMapFile, &sCtlXliffFile, &sCtlLangCd, &sCtlLocaleCd, &sCtlTmplSubdir; /* template control */
   Local string &sOutTmplFile, &sOutMapFile, &sOutXliffFile, &sOutLocaleCd;
   /* output specific instance of template related files */
   Local PSXP_ENGINE:XMLPUtil &oXMLPUtil;
   Local string &sOutFileName;
   rem rsh;
   Local JavaObject &joBurstXml;
   Local number &nBurstCnt;
   Local string &sBurstValue, &sBurstDataFile;
   Local boolean &bResult;
   Local string &sXSLTFile;
   Local JavaObject &oXSLProcessor;
   Local boolean &bUseXform;
   Local PSXP_RPTDEFNMANAGER:BurstFileInfo &oBurstFileInfo; /* MD Signature */
   
   /*Local time &startTime = %PerfTime; */
   
   /* check report status */
   If &Report.Report_status <> "A" Then
      throw CreateException(235, 2300, "This report cannot run because it is not active");
   End-If;
   
   /* check data source status */
   If %This.GetDatasource().Active = False Then
      throw CreateException(235, 2312, "This report cannot run because data source is inactive");
   End-If;
   
   /* check output format */
   If All(&OutputFormat) Then
      If Not %This.IsOutputFormatEnabled(&OutputFormat) Then
         throw CreateException(235, 2301, "Output format %1 not supported for this report", &OutputFormat);
      End-If;
   Else
      rem if unspecified, set to default;
      &OutputFormat = %This.GetDefaultOutputFormat();
   End-If;
   
   
   
   &sOutDestFormat = &OutputFormat;
   
   rem rshw ICE 1836783000;
   &sProcessId = UuidGen();
   
   %This.sSrvTmpDir = &envServerDir | &sDirSep | "files" | &sDirSep | "XMLP" | &sDirSep | &sProcessId;
   CreateDirectory(%This.sSrvTmpDir, %FilePath_Absolute);
   CreateDirectory(%This.sSrvTmpDir | &sDirSep | "Data", %FilePath_Absolute);
   
   /*2037749000 - temp subdir for temp files including templates/subtemplates/xliff etc*/
   %This.sSrvProcDir = %This.sSrvTmpDir | &sDirSep | "Proc";
   CreateDirectory(%This.sSrvProcDir, %FilePath_Absolute);
   
   rem rshwe;
   try /* MD res. 919419 */
      %This.processFinalProperties();
   catch Exception &ee /* MD res. 919419 */
      If &ee.DefaultText = "pdfConversionTimeOut = 0" Then /* MD  OIT */
         Local Exception &xx = CreateException(&PSXP_MsgSet, 999, "Global property psxp_pdfconversion_timeout cannot be set to 0.");
         Error (&xx.ToString( False));
      Else
         If &ee.DefaultText = "PDF Security Passwords" Then /* MD 935062  */
            throw CreateException(&PSXP_MsgSet, 126, "###Passwords for opening the PDF report and for setting permissions cannot be the same.");
         End-If;
         
         throw CreateException(&PSXP_MsgSet, 261, "Using mobile devices for submitting PDF forms currently is not supported");
      End-If;
   end-try;
   
   
   /* Default OutDestination directory will be exposed to the end user only if
      1. report definition sets UseDefaultOutDestination to true 
      2. AND will not provide a value for OutDestination property 
   */
   If %This.OutDestination = "" And
         &UseDefaultOutDestination Then
      &bIsOutDestinationSet = False;
      %This.OutDestination = &envServerDir | &sDirSep | "files" | &sDirSep | "XMLP" | &sDirSep | UuidGen();
      CreateDirectory(%This.OutDestination, %FilePath_Absolute);
      CreateDirectory(%This.OutDestination | &sDirSep | "RptInst", %FilePath_Absolute);
   Else
      &bIsOutDestinationSet = True;
   End-If;
   
   
   If %This.OutDestination <> "" Then
      %This.sSrvOutDir = Substitute(%This.OutDestination, "/", &sDirSep);
      If Substring(%This.sSrvOutDir, Len(%This.sSrvOutDir), 1) = &sDirSep Then
         %This.sSrvOutDir = Substring(%This.sSrvOutDir, 1, Len(%This.sSrvOutDir) - 1);
      End-If;
      
      If Not &bIsOutDestinationSet Then
         %This.sSrvOutDir = %This.sSrvOutDir | &sDirSep | "RptInst";
      End-If;
      
      
      If Not FileExists(%This.sSrvOutDir, %FilePath_Absolute) Then
         CreateDirectory(%This.sSrvOutDir, %FilePath_Absolute);
      End-If;
   Else
      
      rem rshwren ICE 1708378002;
      If &Report.Burst_fieldname <> "" Or
            %This.Debug = True Then
         %This.sSrvOutDir = %This.sSrvTmpDir | &sDirSep | "RptInst";
         CreateDirectory(%This.sSrvOutDir, %FilePath_Absolute);
      Else
         rem for non bursted reports, we use the same temp directory for output, since there is no potential conflict with 
		bursted report temp files this will insure that the temp directory is deleted for web and windows output;
         
         %This.sSrvOutDir = %This.sSrvTmpDir;
      End-If;
   End-If;
   
   WriteToLog(%ApplicationLogFence_Level1, "Using Output Directory:" | %This.sSrvOutDir);
   
   /* Start logging */
   WriteToLog(%ApplicationLogFence_Level1, "BI Publisher ProcessReport Job Start: " | String(%Datetime));
   WriteToLog(%ApplicationLogFence_Level1, "Report Definition Name: " | &ID);
   WriteToLog(%ApplicationLogFence_Level1, "Template ID: " | &TemplateID);
   WriteToLog(%ApplicationLogFence_Level1, "Language CD: " | &LanguageCd);
   WriteToLog(%ApplicationLogFence_Level1, "As of date: " | &AsOfDate);
   WriteToLog(%ApplicationLogFence_Level1, "Output format: " | &OutputFormat);
   
   /* MD Signature */
   /* language */
   If Len(&LanguageCd) <> 3 Then
      &LanguageCd = %Language_User;
   Else
      &LanguageCd = Upper(&LanguageCd);
      SQLExec("SELECT COUNT(*) FROM PSLANGUAGES WHERE LANGUAGE_CD = :1 AND INSTALLED = 1", &LanguageCd, &cnt);
      If &cnt = 0 Then
         &LanguageCd = %Language_User;
      End-If;
   End-If;
   WriteToLog(%ApplicationLogFence_Level1, "Actual Language Code: " | &LanguageCd);
   
   If &AsOfDate = Date("") Then
      &AsOfDate = %Date;
   End-If;
   
   /* get locale code based on language (for rendering only - not usable for datetime/number formatting */
   &sLocaleCd = GetLocaleCode(&LanguageCd);
   
   &nOutputFormat = 1;
   Evaluate &OutputFormat
   When = "HTM" /* HTM */
      &nOutputFormat = 3;
      &sFileExt = "HTM";
      Break;
   When = "XLS" /* XLS */
      Local string &sPropValue;
      If %This.oFinalProperties.getProperty("psxp_excel_outputformat", &sPropValue) = False Then
         &sPropValue = "XLSX";
      End-If;
      
      Evaluate &sPropValue
      When = "XLS-MHTML"
         &nOutputFormat = 4;
         &sFileExt = "XLS";
         Break;
      When = "XLS-HTML" /*bug 17938514 */
         &nOutputFormat = 6;
         &sFileExt = "XLS";
         Break;
      When-Other; /* default to XLSX Excel native format */
         &nOutputFormat = 5;
         &sFileExt = "XLSX";
      End-Evaluate;
      
      Break;
   When = "RTF" /* RTF */
      &nOutputFormat = 1;
      &sFileExt = "RTF";
      Break;
   When = "PDF" /* PDF */
   When = "PCL" /* PCL */
   When = "PS" /* PS */
      &sFileExt = "PDF"; /*When PCL or PS extension is still PDF as the xdo converter will create the PS file*/
      If (&OutputFormat = "PCL") Then
         &nOutputFormat = 23;
         %This.SetPrinterType("PCL");
      Else
         If (&OutputFormat = "PS") Then
            &nOutputFormat = 24;
            %This.SetPrinterType("PS");
         Else
            &nOutputFormat = 2;
            %This.SetPrinterType("PDF");
         End-If;
      End-If;
      
      /* Setting Digital Signature properties */
      If &IsPDFSignatureRequired Then /* MD Signature */
         /*  Digital Signature class instance is created */
         Local PSXP_RPTDEFNMANAGER:DigitalSignature &oSign = create PSXP_RPTDEFNMANAGER:DigitalSignature();
         &oSign.RptDefn = %This;
         &oSign.ProcessInstance = %This.ProcessInstance;
         &oSign.Locale = &sLocaleCd;
         
         If &Report.Burst_fieldname <> "" Then
            &oSign.IsBurstedReport = True;
         Else
            &oSign.IsBurstedReport = False;
         End-If;
         If Not &oSign.setDigitalSignature(%This.oFinalProperties, %This.TemplateType) Then
            WriteToLog(%ApplicationLogFence_Level1, "setDigitalSignature Error: " | &oSign.showLastError());
            &oSign = Null;
         End-If;
      End-If;
      
      Break;
   When = "TXT" /* Text */
      &nOutputFormat = 0; /* number not allocated - support for etext only */
      &sFileExt = "TXT";
      Break;
   When-Other; /* other than eText, default to PDF if no output type is specified */
      If %This.TemplateType = "ETX" Then
         &nOutputFormat = 0;
         &sFileExt = "TXT";
      Else
         &nOutputFormat = 2;
         &sFileExt = "PDF";
         %This.SetPrinterType("PDF");
      End-If;
      Break;
   End-Evaluate;
   WriteToLog(%ApplicationLogFence_Level1, "Actual output format: " | String(&nOutputFormat));
   
   /* download template */
   &oTmpl = %This.GetTemplateRuntime(&TemplateID);
   &TemplateID = &oTmpl.ID;
   WriteToLog(%ApplicationLogFence_Level1, "Actual template ID: " | &TemplateID);
   
   &oTmplFile = %This.GetTemplateFileRuntime(&oTmpl, &AsOfDate);
   WriteToLog(%ApplicationLogFence_Level1, "Actual template date: " | String(&oTmplFile.EffectiveDate));
   
   &oXSLProcessor = CreateJavaObject("com.peoplesoft.pt.xmlpublisher.PTXSLProcessor");
   If &oTmplFile.UseTransform = "Y" Then
      &bUseXform = True;
      &sXSLTFile = &oTmplFile.GetXSLTFile();
   Else
      &bUseXform = False;
   End-If;
   
   /* template conversion */
   
   Evaluate %This.TemplateType
   When = "PDF"
      /* get mapped pdf file and generate map file */
      rem rshw ICE 1766139000;
      &oTmplFile.SetDir(%This.sSrvProcDir | &sDirSep);
      &sTmplFile = &oTmplFile.GetFile();
      WriteToLog(%ApplicationLogFence_Level1, "Template file: " | &sTmplFile);
      rem rsh ICE 1836783000;
      &sMapFile = %This.sSrvProcDir | &sDirSep | &TemplateID | ".map";
      &bResult = %This.GetPDFMapFile(&sMapFile, &oTmplFile);
      rem rshw ICE 1876037000;
      If &bResult = False Then
         &sMapFile = "";
      End-If;
      WriteToLog(%ApplicationLogFence_Level1, "PDF map file: " | &sMapFile);
      
      /* MD Submit */
      If &IsPDFSubmitEnabled Then
         &bResult = %This.oFinalProperties.setProperty("psxp_submit_user", %OperatorId);
         &bResult = %This.oFinalProperties.setProperty("psxp_submit_rptId", %This.ID);
         &bResult = %This.oFinalProperties.setProperty("psxp_submit_templId", &TemplateID);
      End-If;
      
      Break;
   When = "ETX"
      /* convert eText template to XSL */
      rem rsh ICE 1836783000;
      &sTmplFile = %This.sSrvProcDir | &sDirSep | &TemplateID | ".xsl";
      &bResult = %This.ConvEtxTemplateToXsl(&sTmplFile, &oTmplFile);
      WriteToLog(%ApplicationLogFence_Level1, "XSL template: " | &sTmplFile);
      Break;
   When = "RTF"
      /* convert RTF template to XSL */
      rem rsh ICE 1836783000;
      &sTmplFile = %This.sSrvProcDir | &sDirSep | &TemplateID | ".xsl";
      &bResult = %This.ConvRtfTemplateToXsl(&sTmplFile, &oTmplFile, &sLocaleCd);
      WriteToLog(%ApplicationLogFence_Level1, "XSL template: " | &sTmplFile);
      Break;
   When-Other;
      rem rshw2 ICE 1766139000;
      &oTmplFile.SetDir(%This.sSrvProcDir | &sDirSep);
      &sTmplFile = &oTmplFile.GetFile();
      WriteToLog(%ApplicationLogFence_Level1, "Template file: " | &sTmplFile);
      Break;
   End-Evaluate;
   
   /* tranlsation */
   try
      &sXliffFile = %This.GetXliffFile(&oTmpl, &oTmplFile, &LanguageCd);
   catch Exception &e
      rem RSHW TODO: Need to handle this and other exceptions properly;
      WriteToLog(%ApplicationLogFence_Level1, "Error Generting Translation File" | &sXliffFile);
   end-try;
   WriteToLog(%ApplicationLogFence_Level1, "Xliff File: " | &sXliffFile);
   
   
   &sDataFile = &ID | ".xml";
   
   Local string &sConQryOutFileName;
   
   Evaluate &Report.Ds_type
   When = "QRY"
      rem rsh ICE 1836783000;
      &sDataFile = %This.sSrvTmpDir | &sDirSep | "Data" | &sDirSep | &sDataFile;
      %This.GenerateXmlFileFromQuery(&sDataFile);
      Break;
   When = "CQR" /* Connected Query */
      
      %This.GenerateXmlFileFromConnQuery(&sConQryOutFileName, String(&ProcessInstance));
      If Not FileExists(&sConQryOutFileName, %FilePath_Absolute) Then
         throw CreateException(235, 2308, "Data file is required but not specified correctly");
      Else
         %This.SetRuntimeDataXMLFile(&sConQryOutFileName);
      End-If;
      &sDataFile = &DataXMLFile;
      Break;
   When = "RST"
      rem rshw TODO: This function needs to be passed file path instead of returning string;
      &sXmlData = %This.GenerateXmlFromRowset();
      If &sXmlData = "" Then
         throw CreateException(235, 2305, "Failed to generate or read data source XML file");
      End-If;
      rem rsh ICE 1836783000;
      &sDataFile = %This.sSrvTmpDir | &sDirSep | "Data" | &sDirSep | &sDataFile;
      %This.WriteXmlDataFile(&sXmlData, &sDataFile);
      Break;
   When = "XMD"
      &sXmlData = %This.GenerateXmlFromXmlDoc();
      If &sXmlData = "" Then
         throw CreateException(235, 2305, "Failed to generate or read data source XML file");
      End-If;
      rem rsh ICE 1836783000;
      &sDataFile = %This.sSrvTmpDir | &sDirSep | "Data" | &sDirSep | &sDataFile;
      %This.WriteXmlDataFile(&sXmlData, &sDataFile);
      Break;
   When = "XML"
      If &DataXMLFile = "" Then
         throw CreateException(235, 2308, "Data file is required but not specified correctly");
      End-If;
      &sDataFile = &DataXMLFile;
      Break;
   When-Other
      Break;
   End-Evaluate;
   
   /* bug 17555747 -Richtext in CDATA support */
   If (%This.TemplateType = "RTF" And
         &aNoCDATAFields <> Null) Then
      %This.RemoveCDATAfromFieldList(&sDataFile);
   End-If;
   
   Local string &sExtName = &MyUtil.GetFileExtensionFromFileName(&sDataFile); /* MD 902990 */
   
   /* process xml file (including bursting) */
   &arOutput = CreateArrayRept(&oReportOut, 0);
   
   /* sub-template property */
   &oXMLPUtil = create PSXP_ENGINE:XMLPUtil();
   &oXMLPUtil.setGlobalProperty("subtempasofdate", DateTimeToLocalizedString(&AsOfDate, "yyyy-MM-dd"));
   &oXMLPUtil.setGlobalProperty("subtemplangcode", &LanguageCd); /* ICE 1537302000 */
   
   rem rshw ICE 1766139000;
   &oXMLPUtil.setGlobalProperty("SrvTmpDir", %This.sSrvProcDir | &sDirSep);
   
   If &Report.Burst_fieldname <> "" Then
      /* burst */
      WriteToLog(%ApplicationLogFence_Level1, "Burst field: " | &Report.Burst_fieldname);
      
      /* get collection of xml files from source xml */
      &joBurstXml = CreateJavaObject("com.peoplesoft.pt.xmlpublisher.PTBurstXml", %This.sSrvTmpDir | &sDirSep | "Data");
      
      &joBurstXml.setEnforceUniqueBurstValue(%This.EnforceUniqueBurstValue);
      &bResult = &joBurstXml.burst(&sDataFile, &Report.Burst_fieldname);
      If Not &bResult Then
         rem rsh ICE 1836783000;
         rem Bursted files already created are deleted in the Java layer in case of error;
         If &Report.Ds_type <> "XML" And
               %This.Debug = False Then
            %This.DeleteFile(&sDataFile);
         End-If;
         throw CreateException(235, 3258, "Error bursting xml data source file: %1", &joBurstXml.getLastError());
      End-If;
      &nBurstCnt = &joBurstXml.getBurstFilesCount();
      
      If &nBurstCnt > 0 Then
         
         WriteToLog(%ApplicationLogFence_Level1, "Burst file count: " | String(&nBurstCnt));
         For &i = 1 To &nBurstCnt
            &sBurstValue = &joBurstXml.getBurstValue(&i - 1);
            &sBurstDataFile = &joBurstXml.getBurstFile(&i - 1);
            
            rem rsh ICE 1836783000;
            rem rsh sub directory to use for Bursted Files ( should be set to true only when OutDestination is File);
            Local string &sSubDir;
            If %This.BurstValueAsOutSubDir Then
               &sSubDir = &sBurstValue;
               &sSubDir = &MyUtil.ValidateFileName(&sSubDir);
            Else
               &sSubDir = String(&i);
            End-If;
            
            WriteToLog(%ApplicationLogFence_Level2, "Burst value: " | &sBurstValue);
            WriteToLog(%ApplicationLogFence_Level2, "Burst data file: " | &sBurstDataFile);
            rem rsh ICE 1836783000;
            CreateDirectory(%This.sSrvOutDir | &sDirSep | &sSubDir, %FilePath_Absolute);
            
            /* MD Signature Local PSXP_RPTDEFNMANAGER:BurstFileInfo &oBurstFileInfo; */
            &oBurstFileInfo = create PSXP_RPTDEFNMANAGER:BurstFileInfo(&sBurstValue, &sBurstDataFile);
            
            /* MD res.888676  */
            &oBurstFileInfo.Debug = %This.Debug;
            
            /* MD Signature */
            %This.ParseDataValues(&oBurstFileInfo, &oSign, True);
            
            If (&Report.Userfilename <> "") Then
               &sOutFileName = %This.TranslateUserFileName(&Report.Userfilename, &oBurstFileInfo, &LanguageCd, &AsOfDate);
               &sOutFileName = &MyUtil.ValidateFileName(&sOutFileName);
            Else
               If %This.UseBurstValueAsOutputFileName Then
                  &sOutFileName = &sBurstValue;
                  &sOutFileName = &MyUtil.ValidateFileName(&sOutFileName);
               Else
                  &sOutFileName = &ID;
               End-If;
            End-If;
            rem rsh ICE 1836783000;
            
            &sLocalOutputFile = %This.sSrvOutDir | &sDirSep | &sSubDir | &sDirSep | &sOutFileName | "." | Lower(&sFileExt);
            
            /* default templates */
            &sOutTmplFile = &sTmplFile;
            &sOutMapFile = &sMapFile;
            &sOutXliffFile = &sXliffFile;
            &sOutLocaleCd = &sLocaleCd;
            
            /* template switching */
            If &Report.Tmplctrl_fieldname <> "" Then
               WriteToLog(%ApplicationLogFence_Level2, "Template Control Field: " | &Report.Tmplctrl_fieldname);
               &sCtlTmplFile = "";
               &sCtlMapFile = "";
               &sCtlXliffFile = "";
               &sCtlLangCd = "";
               &sCtlTmplSubdir = ""; /*ICE 2037749000*/
               rem rsh only check the first instance of template control field value - ignore if single output have two or more values;
               &sTmplCtrlFldValue = &oBurstFileInfo.getFieldValues(&Report.Tmplctrl_fieldname)[1];
               
               If &sTmplCtrlFldValue <> "" Then
                  
                  WriteToLog(%ApplicationLogFence_Level2, "Template Control Field Value: " | &sTmplCtrlFldValue);
                  &oTmplCtrl = %This.GetTemplateControl(&sTmplCtrlFldValue);
                  
                  
                  If Not &oTmplCtrl = Null Then
                     /*ICE 2037749000 - download dynamic template to own subdir - avoiding potential naming conflict + additional debugging capability*/
                     
                     /* bug 19264023 */
                     &sCtlTmplSubdir = %This.sSrvProcDir | &sDirSep | "Tmpl_Ctrl_" | &MyUtil.ValidateFileName(&sTmplCtrlFldValue);
                     
                     If Not FileExists(&sCtlTmplSubdir, %FilePath_Absolute) Then
                        CreateDirectory(&sCtlTmplSubdir, %FilePath_Absolute);
                     End-If;
                     
                     /* process output specific template */
                     &sCtlLangCd = &oTmplCtrl.LanguageCode;
                     If &sCtlLangCd <> "" Then
                        &oXMLPUtil.setGlobalProperty("subtemplangcode", &sCtlLangCd);
                     Else
                        &sCtlLangCd = &LanguageCd;
                     End-If;
                     &sCtlLocaleCd = GetLocaleCode(&sCtlLangCd);
                     &oCtlTmpl = %This.GetTemplateRuntime(&oTmplCtrl.TemplateID);
                     WriteToLog(%ApplicationLogFence_Level2, "Template ID: " | &oCtlTmpl.ID);
                     
                     &oCtlTmplFile = %This.GetTemplateFileRuntime(&oCtlTmpl, &AsOfDate);
                     WriteToLog(%ApplicationLogFence_Level2, "Template date: " | String(&oCtlTmplFile.EffectiveDate));
                     
                     If &oCtlTmplFile.UseTransform = "Y" Then
                        &bUseXform = True;
                        &sXSLTFile = &oCtlTmplFile.GetXSLTFile();
                     Else
                        &bUseXform = False;
                     End-If;
                     
                     /* template conversion */
                     Evaluate %This.TemplateType
                     When = "PDF"
                        /* get mapped pdf file and generate map file */
                        rem rshw2 ICE 1766139000;
                        &oCtlTmplFile.SetDir(&sCtlTmplSubdir | &sDirSep);
                        &sCtlTmplFile = &oCtlTmplFile.GetFile();
                        WriteToLog(%ApplicationLogFence_Level2, "Template file: " | &sCtlTmplFile);
                        rem rsh ICE 1836783000;
                        &sCtlMapFile = &sCtlTmplSubdir | &sDirSep | &oCtlTmpl.ID | ".map";
                        &bResult = %This.GetPDFMapFile(&sCtlMapFile, &oCtlTmplFile);
                        rem rshw ICE 1876037000;
                        If &bResult = False Then
                           &sCtlMapFile = "";
                        End-If;
                        
                        WriteToLog(%ApplicationLogFence_Level2, "PDF map file: " | &sCtlMapFile);
                        Break;
                     When = "ETX"
                        /* convert eText template to XSL */
                        rem rsh ICE 1836783000;
                        &sCtlTmplFile = &sCtlTmplSubdir | &sDirSep | &oCtlTmpl.ID | ".xsl";
                        &bResult = %This.ConvEtxTemplateToXsl(&sCtlTmplFile, &oCtlTmplFile);
                        WriteToLog(%ApplicationLogFence_Level2, "XSL template: " | &sCtlTmplFile);
                        Break;
                     When = "RTF"
                        /* convert RTF template to XSL */
                        rem rsh ICE 1836783000;
                        &sCtlTmplFile = &sCtlTmplSubdir | &sDirSep | &oCtlTmpl.ID | ".xsl";
                        &bResult = %This.ConvRtfTemplateToXsl(&sCtlTmplFile, &oCtlTmplFile, &sCtlLocaleCd);
                        WriteToLog(%ApplicationLogFence_Level2, "XSL template: " | &sCtlTmplFile);
                        Break;
                     When-Other;
                        rem rshw2 ICE 1766139000;
                        &oCtlTmplFile.SetDir(&sCtlTmplSubdir | &sDirSep);
                        &sCtlTmplFile = &oCtlTmplFile.GetFile();
                        WriteToLog(%ApplicationLogFence_Level2, "Template file: " | &sCtlTmplFile);
                        Break;
                     End-Evaluate;
                     
                     /* tranlsation */
                     If &sCtlLocaleCd <> "" Then
                        try
                           &sCtlXliffFile = %This.GetXliffFile(&oCtlTmpl, &oCtlTmplFile, &sCtlLangCd);
                        catch Exception &e1
                        end-try;
                        WriteToLog(%ApplicationLogFence_Level2, "Xliff File: " | &sCtlXliffFile);
                     End-If;
                     
                     &sOutTmplFile = &sCtlTmplFile;
                     &sOutMapFile = &sCtlMapFile;
                     &sOutXliffFile = &sCtlXliffFile;
                     If &sCtlLangCd <> "" Then
                        &sOutLocaleCd = &sCtlLocaleCd;
                     Else
                        &sOutLocaleCd = &sLocaleCd;
                     End-If;
                  End-If;
               End-If;
            End-If;
            
            &sBurstFieldValue = &sBurstValue; /* OIT 901R1 */
            
            
            If &bUseXform = True Then
               Local string &sBurstDataFileXform;
               
               &sBurstDataFileXform = Substitute(&sBurstDataFile, "." | &sExtName, "_x." | &sExtName);
               
               &oXSLProcessor.xformData(&sXSLTFile, &sBurstDataFile, &sBurstDataFileXform);
               If %This.GenerateOutput(&sOutTmplFile, &sOutMapFile, &sBurstDataFileXform, &sOutXliffFile, &sOutLocaleCd, &sLocalOutputFile, &nOutputFormat, &sErr) = False Then
                  throw CreateException(235, 2309, "Failure in generating report output: %1", &sErr);
               End-If;
            Else
               If %This.GenerateOutput(&sOutTmplFile, &sOutMapFile, &sBurstDataFile, &sOutXliffFile, &sOutLocaleCd, &sLocalOutputFile, &nOutputFormat, &sErr) = False Then
                  throw CreateException(235, 2309, "Failure in generating report output: %1", &sErr);
               End-If;
               
            End-If;
            
            WriteToLog(%ApplicationLogFence_Level2, "Output file: " | &sLocalOutputFile);
            
            /* MD Signature */
            If &IsPDFSignatureRequired And
                  &oSign <> Null Then
               If Not &ReusePDFSignatureForBursInst Then
                  CreateDirectory(%This.sSrvProcDir | &sDirSep | &sSubDir, %FilePath_Absolute);
                  &bResult = &oSign.SignWithDigitalSignature(&sLocalOutputFile, %This.sSrvProcDir | &sDirSep | &sSubDir);
                  &oSign.cleanupCertificate();
               Else
                  &bResult = &oSign.SignWithDigitalSignature(&sLocalOutputFile, %This.sSrvProcDir);
               End-If;
               
               If Not &bResult Then
                  WriteToLog(%ApplicationLogFence_Level1, "SignWithDigitalSignature Error: " | &oSign.showLastError());
                  WriteToLog(%ApplicationLogFence_Level1, "Report could not be signed.  Deleting the report (if debug property is not set): " | %This.ID);
                  &oSign = Null;
                  %This.cleanupProcessing( True);
                  Return;
               End-If;
               
            End-If;
            
            &oReportOut = create PSXP_RPTDEFNMANAGER:ReportOutput(&sBurstValue, &sSubDir, &sOutFileName | "." | Lower(&sFileExt), &sBurstDataFile, &oBurstFileInfo);
            &arOutput.Push(&oReportOut);
         End-For;
      End-If;
      
   Else
      
      /* non-bursted reports */
      /* Resolve Descriptive File Name, if set*/
      If (&Report.Userfilename <> "") Then
         &sOutFileName = %This.TranslateUserFileName(&Report.Userfilename, Null, &LanguageCd, &AsOfDate);
         &sOutFileName = &MyUtil.ValidateFileName(&sOutFileName);
      Else
         &sOutFileName = &ID;
      End-If;
      
      If &oTmplFile.UseTransform = "Y" Then
         Local string &sDataFileXform;
         
         &sDataFileXform = Substitute(&sDataFile, "." | &sExtName, "_x." | &sExtName);
         
         &oXSLProcessor.xformData(&sXSLTFile, &sDataFile, &sDataFileXform);
         rem rsh ICE 1836783000;
         &sLocalOutputFile = %This.sSrvOutDir | &sDirSep | &sOutFileName | "." | Lower(&sFileExt);
         If %This.GenerateOutput(&sTmplFile, &sMapFile, &sDataFileXform, &sXliffFile, &sLocaleCd, &sLocalOutputFile, &nOutputFormat, &sErr) = False Then
            throw CreateException(235, 2309, "Failure in generating report output: %1", &sErr);
         End-If;
      Else
         rem rsh ICE 1836783000;
         &sLocalOutputFile = %This.sSrvOutDir | &sDirSep | &sOutFileName | "." | Lower(&sFileExt);
         If %This.GenerateOutput(&sTmplFile, &sMapFile, &sDataFile, &sXliffFile, &sLocaleCd, &sLocalOutputFile, &nOutputFormat, &sErr) = False Then
            throw CreateException(235, 2309, "Failure in generating report output: %1", &sErr);
         End-If;
         
      End-If;
      
      WriteToLog(%ApplicationLogFence_Level1, "Output file: " | &sLocalOutputFile);
      
      /* MD Signature */
      If &IsPDFSignatureRequired And
            &oSign <> Null Then
         If &oBurstFileInfo = Null Then
            &oBurstFileInfo = create PSXP_RPTDEFNMANAGER:BurstFileInfo("", &sDataFile);
            /* MD res.888676  */
            &oBurstFileInfo.Debug = %This.Debug;
         End-If;
         %This.ParseDataValues(&oBurstFileInfo, &oSign, False);
         &bResult = &oSign.SignWithDigitalSignature(&sLocalOutputFile, %This.sSrvProcDir);
         
         If Not &bResult Then
            WriteToLog(%ApplicationLogFence_Level1, "SignWithDigitalSignature Error: " | &oSign.showLastError());
            WriteToLog(%ApplicationLogFence_Level1, "Report could not be signed. Deleting the report(if debug property is not set): " | %This.ID);
            &oSign = Null;
            %This.cleanupProcessing( True);
            Return;
         End-If;
      End-If;
      
      &oReportOut = create PSXP_RPTDEFNMANAGER:ReportOutput("", "", &sOutFileName | "." | Lower(&sFileExt), &sDataFile, Null);
      &arOutput.Push(&oReportOut);
      
      If &bIsExtEmail Then /* MD ext email */
         If Not %This.getExtEmailAddressArray() Then
            throw CreateException(235, 3350, "Failed in retrieving external email recipients list");
         End-If;
      End-If;
      
   End-If;
   
   /* cleanup process files 
   ICE 2037749000 - no longer need to remove individual temp files, instead we are deleting temp processing dir below */
   
   /* MD Signature */
   %This.cleanupProcessing( False);
   If &oSign <> Null Then
      &oSign.cleanupCertificate();
      &oSign = Null;
   End-If;
   
   /* finish logging */
   WriteToLog(%ApplicationLogFence_Level1, "BI Publisher ProcessReport Job End: " | String(%Datetime));
   
   /* Local time &endTime = %PerfTime;
   WriteToLog(%ApplicationLogFence_Level1, "Process Report Time: " | &endTime | " - " | &startTime | " = " | String(&endTime - &startTime)); */
   
end-method;

rem Translate user file name template into a physical file name;
method TranslateUserFileName
   /+ &sUserfilename as String, +/
   /+ &oBurstFileInfo as PSXP_RPTDEFNMANAGER:BurstFileInfo, +/
   /+ &LanguageCd as String, +/
   /+ &AsOfDate as Date +/
   /+ Returns String +/
   Local string &sOutputFileName;
   Local integer &pos = 1;
   Local string &sCurChar, &sCurTag, &sTagTranslation;
   Local boolean &bIsInTag = False;
   &sUserfilename = RTrim(LTrim(&sUserfilename));
   
   While &pos <= Len(&sUserfilename)
      &sCurChar = Substring(&sUserfilename, &pos, 1);
      If &sCurChar = "%" Then
         If &bIsInTag = False Then
            &bIsInTag = True;
            &sCurTag = "";
         Else
            &bIsInTag = False;
            rem translate tag;
            If &sCurTag = "BTV" And
                  &oBurstFileInfo <> Null Then
               &sTagTranslation = &oBurstFileInfo.BurstValue;
            Else
               If &sCurTag = "RID" Then
                  &sTagTranslation = &ID
               Else
                  If &sCurTag = "LAN" Then
                     &sTagTranslation = &LanguageCd
                  Else
                     If &sCurTag = "ASD" Then
                        &sTagTranslation = DateTimeToLocalizedString(&AsOfDate, "yyyy-MM-dd");
                     Else
                        Local string &sFieldValue = &oBurstFileInfo.getFieldValues(&sCurTag)[1];
                        If &sFieldValue <> "" Then
                           &sTagTranslation = &sFieldValue;
                        Else
                           &sTagTranslation = "";
                        End-If;
                     End-If;
                  End-If;
               End-If;
            End-If;
            
            rem Append Tag translation to OutOutFileName;
            &sOutputFileName = &sOutputFileName | &sTagTranslation;
         End-If;
      Else
         If &bIsInTag Then
            rem append character to build current tag;
            &sCurTag = &sCurTag | &sCurChar;
         Else
            rem append character directly to output file name;
            &sOutputFileName = &sOutputFileName | &sCurChar;
         End-If;
      End-If;
      
      &pos = &pos + 1;
   End-While;
   Return &sOutputFileName;
end-method;



rem rshw processETextReport needs to be deprcated. ProcessReport already handles ETEXT templates.;
/* ****************************************************** */
/* ProcessETextReport method                              */
/* ****************************************************** */
method ProcessETextReport
   /+ &TemplateID as String, +/
   /+ &LanguageCd as String, +/
   /+ &AsOfDate as Date +/
   /+ Returns String +/
   Local string &OutputFormat;
   Local string &sOutString;
   Local string &sServDir, &sProcessId, &sOutputDir;
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpl;
   Local PSXP_RPTDEFNMANAGER:TemplateFile &oTmplFile;
   Local string &sLocaleCd;
   Local string &sTmplFile, &sXliffFile;
   Local string &sXmlData;
   Local string &sErr;
   Local number &cnt;
   Local string &sOutTmplFile, &sOutXliffFile, &sOutLocaleCd; /* output specific instance of template related files */
   Local PSXP_ENGINE:XMLPUtil &oXMLPUtil;
   
   /* check report status */
   If &Report.Report_status <> "A" Then
      throw CreateException(235, 2300, "This report cannot run because it is not active");
   End-If;
   
   /* check data source status */
   If %This.GetDatasource().Active = False Then
      throw CreateException(235, 2312, "This report cannot run because data source is inactive");
   End-If;
   
   /* check output format  - must be text */
   rem rshw this is wrong &OutputFormat is never set;
   If All(&OutputFormat) And
         (&OutputFormat <> "TXT") Then
      throw CreateException(235, 2301, "Output format %1 not supported for this report", &OutputFormat);
   End-If;
   
   If All(&OutputFormat) And
         Not (%This.IsOutputFormatEnabled(&OutputFormat)) Then
      throw CreateException(235, 2301, "Output format %1 not supported for this report", &OutputFormat);
   End-If;
   
   If Not (%This.TemplateType = "ETX" Or
         %This.TemplateType = "RTF" Or
         %This.TemplateType = "XSL") Then
      throw CreateException(235, 2323, "Invalid template type %1", %This.TemplateType);
   End-If;
   
   /* template switching not supported */
   If &Report.Tmplctrl_fieldname <> "" Then
      throw CreateException(235, 2321, "Template Control Functionality not supported with ProcessETextReport API");
   End-If;
   
   /* bursting not supported */
   If &Report.Burst_fieldname <> "" Then
      throw CreateException(235, 2322, "Bursting functionality not supported for ProcessETextReport API");
   End-If;
   
   &sOutDestFormat = &OutputFormat;
   /* setup process env */
   &sProcessId = UuidGen();
   If %This.OutDestination <> "" Then
      &sOutputDir = Substitute(%This.OutDestination, "/", &sDirSep);
      If Substring(&sOutputDir, Len(&sOutputDir), 1) = &sDirSep Then
         &sOutputDir = Substring(&sOutputDir, 1, Len(&sOutputDir) - 1);
      End-If;
      CreateDirectory(&sOutputDir | "/RptInst", %FilePath_Absolute);
   Else
      &sServDir = &envServerDir;
      CreateDirectory(&sServDir | "/files/XMLP/" | &sProcessId, %FilePath_Absolute);
      CreateDirectory(&sServDir | "/files/XMLP/" | &sProcessId | "/RptInst", %FilePath_Absolute);
      &sOutputDir = &sServDir | &sDirSep | "files" | &sDirSep | "XMLP" | &sDirSep | &sProcessId;
      
      %This.OutDestination = &sOutputDir;
   End-If;
   
   
   /* Start logging */
   WriteToLog(%ApplicationLogFence_Level1, "BI Publisher ProcessETextReport Job Start: " | String(%Datetime));
   WriteToLog(%ApplicationLogFence_Level1, "Report Definition Name: " | &ID);
   WriteToLog(%ApplicationLogFence_Level1, "Template ID: " | &TemplateID);
   WriteToLog(%ApplicationLogFence_Level1, "Language CD: " | &LanguageCd);
   WriteToLog(%ApplicationLogFence_Level1, "As of date: " | &AsOfDate);
   WriteToLog(%ApplicationLogFence_Level1, "Output format: " | &OutputFormat);
   
   /* download template */
   &oTmpl = %This.GetTemplateRuntime(&TemplateID);
   &TemplateID = &oTmpl.ID;
   WriteToLog(%ApplicationLogFence_Level1, "Actual template ID: " | &TemplateID);
   
   If &AsOfDate = Date("") Then
      &AsOfDate = %Date;
   End-If;
   
   &oTmplFile = %This.GetTemplateFileRuntime(&oTmpl, &AsOfDate);
   WriteToLog(%ApplicationLogFence_Level1, "Actual template date: " | String(&oTmplFile.EffectiveDate));
   
   /* language */
   If Len(&LanguageCd) <> 3 Then
      &LanguageCd = %Language_User;
   Else
      &LanguageCd = Upper(&LanguageCd);
      SQLExec("SELECT COUNT(*) FROM PSLANGUAGES WHERE LANGUAGE_CD = :1 AND INSTALLED = 1", &LanguageCd, &cnt);
      If &cnt = 0 Then
         &LanguageCd = %Language_User;
      End-If;
   End-If;
   WriteToLog(%ApplicationLogFence_Level1, "Actual Language Code: " | &LanguageCd);
   
   
   /* get locale code based on language (for rendering only - not usable for datetime/number formatting */
   &sLocaleCd = GetLocaleCode(&LanguageCd);
   
   /* template conversion */
   Evaluate %This.TemplateType
   When = "ETX"
      /* convert eText template to XSL */
      WriteToLog(%ApplicationLogFence_Level1, "XSL template: " | &sTmplFile);
      Break;
   When = "RTF"
      /* convert RTF template to XSL */
      WriteToLog(%ApplicationLogFence_Level1, "XSL template: " | &sTmplFile);
      Break;
   When-Other; /* XSL*/
      &sTmplFile = &oTmplFile.GetFile();
      WriteToLog(%ApplicationLogFence_Level1, "Template file: " | &sTmplFile);
      Break;
   End-Evaluate;
   
   
   /* generate xml file */
   Evaluate &Report.Ds_type
   When = "QRY"
      &sXmlData = %This.GenerateXmlFromQuery();
      Break;
   When = "RST"
      &sXmlData = %This.GenerateXmlFromRowset();
      Break;
   When = "XMD"
      &sXmlData = %This.GenerateXmlFromXmlDoc();
      Break;
   When = "XML"
      &sXmlData = %This.ReadDataFile();
   When-Other
      Break;
   End-Evaluate;
   
   /* sub-template property */
   &oXMLPUtil = create PSXP_ENGINE:XMLPUtil();
   &oXMLPUtil.setGlobalProperty("subtempasofdate", DateTimeToLocalizedString(&AsOfDate, "yyyy-MM-dd"));
   &oXMLPUtil.setGlobalProperty("subtemplangcode", &LanguageCd);
   
   /* default templates */
   &sOutTmplFile = &sTmplFile;
   &sOutLocaleCd = &sLocaleCd;
   
   &sOutString = %This.GenerateStringOutput(&sOutTmplFile, &sXmlData, &sOutLocaleCd, &sErr);
   
   If &sOutString = "" Then
      throw CreateException(235, 2309, "Failure in generating report output: %1", &sErr);
   End-If;
   
   /* cleanup process files */
   If %This.TemplateType = "ETX" Or
         %This.TemplateType = "RTF" Then /* delete only geneated xsl template file */
      %This.DeleteFile(&sTmplFile);
   End-If;
   
   /* finish logging */
   WriteToLog(%ApplicationLogFence_Level1, "BI Publisher ProcessETextReport Job End: " | String(%Datetime));
   
   Return &sOutString;
   
end-method;

/* ****************************************************** */
/* GetOutDestFormat method                                */
/* ****************************************************** */
method GetOutDestFormatString
   /+ &OutDestFormat as Number +/
   /+ Returns String +/
   /* translates OutDestFormat to string representation used in XMLP */
   Evaluate &OutDestFormat
   When 2 /* PDF */
      Return "PDF";
   When 5 /* HTM */
      Return "HTM";
   When 8 /* XLS */
      Return "XLS";
   When 12 /* RTF */
      Return "RTF";
   When 14 /* TXT */
      Return "TXT";
   When 23 /* PCL */
      Return "PCL";
   When 24 /* PS */
      Return "PS";
   When-Other;
      throw CreateException(235, 2310, "Unsupported output format %1", String(&OutDestFormat));
   End-Evaluate;
end-method;

/* ****************************************************** */
/* DisplayOutput method                                   */
/* ****************************************************** */
method DisplayOutput
   Local string &sReportFile;
   Local string &sRptFilePath;
   Local string &sRptDir;
   Local boolean &bRtn;
   Local PSXP_RPTDEFNMANAGER:Utility &oUtil;
   
   If &Report.Burst_fieldname = "" Then /* display only when non-bursting */
      
      rem rsh ICE 1836783000;
      &sRptDir = %This.sSrvOutDir;
      
      /* MD Signature */
      If &IsPDFSignatureRequired Then
         If Not FileExists(&sRptDir, %FilePath_Absolute) Then
            throw CreateException(235, 220, "###Cannot create a BI Publisher Report due to getting Digital Certificate error");
         End-If;
      End-If;
      
      
      If %This.arOutput.Len > 0 Then
         &sReportFile = %This.arOutput [1].OutputFile;
         &sRptFilePath = &sRptDir | &sDirSep | &sReportFile;
      End-If;
      
      WriteToLog(%ApplicationLogFence_Level1, "Report file: " | &sRptFilePath);
      
      /* send the output to client */
      &oUtil = create PSXP_RPTDEFNMANAGER:Utility();
      
      /* MD Attach */
      If &IsPDFSubmitEnabled Then
         &oUtil.UpdatableReportName = %This.ID;
      End-If;
      /*ICE 1994520003*/
      &bRtn = &oUtil.ViewXMLPAttachment(&sRptFilePath);
      
   End-If;
   rem rsh ICE 1836783000;
   If %This.Debug = False Then
      %This.CleanOutput();
   End-If;
   
end-method;


/* ****************************************************** */
/* Publish method                                         */
/* ****************************************************** */
method Publish
   /+ &sServerName as String, +/
   /+ &reportPath as String, +/
   /+ &sFolderName as String, +/
   /+ &processInstanceId as Number +/
   
   
   Local date &dExpire;
   Local boolean &bBurst, &bRet;
   
   Local array of array of string &arPubAttributes = Null;
   Local string &sRptName;
   Local string &sXmlFile;
   Local string &sDbName;
   Local string &sReportDescr;
   Local string &sOutDestType, &sOutDest;
   Local string &sSourceReportPath;
   Local string &subdir;
   Local integer &cnt, &i;
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &oRptViewerArray;
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &oTempRptViewerArray;
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &oFinalRptViewerArray;
   Local PSXP_RPTDEFNMANAGER:ReportOutput &RptOutput;
   Local string &sBurstKey, &sBurstValue;
   Local array of string &aSearchKeys; /* mdu ICE 1548157000 */
   
   rem rshwe2 1891427000;
   Local string &subject, &burstSubj, &emlText, &burstText, &distPageEmailList;
   Local array of string &asDistPageEmailList;
   
   &subject = "";
   &emlText = "";
   &burstSubj = "";
   &burstText = "";
   &distPageEmailList = "";
   &asDistPageEmailList = CreateArrayRept("", 0);
   
   
   &bBurst = %This.isBurstingOn();
   &sReportDescr = %This.Description;
   &sOutDestType = %This.OutDestinationType;
   rem rsh ICE 1836783000;
   &sOutDest = %This.sSrvOutDir;
   &dExpire = %This.generateExpiryDate(&processInstanceId);
   
   /* MD Signature */
   If &IsPDFSignatureRequired Then
      If Not FileExists(&sOutDest, %FilePath_Absolute) Then
         throw CreateException(65, 76, "###Unable to transfer files to report repository because the output directory %1 is not found", &sOutDest);
      End-If;
   End-If;
   
   WriteToLog(%ApplicationLogFence_Level1, "___________Publishing Report____________"); /* mdu 1548157000  */
   WriteToLog(%ApplicationLogFence_Level1, "Report Descr  " | &sReportDescr);
   WriteToLog(%ApplicationLogFence_Level1, "Report OutDestType  " | &sOutDestType);
   WriteToLog(%ApplicationLogFence_Level1, "Report OutDest  " | &sOutDest);
   WriteToLog(%ApplicationLogFence_Level1, "Expiry date  " | &dExpire);
   
   If (&processInstanceId <> 0) Then
      /* get servername, foldername from scheduler request table */
      SQLExec("SELECT PSRF_FOLDER_NAME, SERVERNAMERUN FROM PSPRCSRQST WHERE PRCSINSTANCE = :1", &processInstanceId, &sFolderName, &sServerName);
   Else
      /* will use the input argument values */;
   End-If;
   
   If &sFolderName = "" Then
      &sFolderName = %This.getDefaultFolderName();
   End-If;
   
   /* get report definition level distribution options */
   &oRptViewerArray = %This.getRptDefnDistribution(&oRptViewerArray);
   
   /* get prcs scheduler runtime distribution options */
   If (%This.AllowViewerEntry = "Y" Or
         %This.AllowViewerEntry = "y") Then
      &oRptViewerArray = %This.getRuntimeDistribution(&processInstanceId, &oRptViewerArray);
      rem rshwe2 1891427000;
      &asDistPageEmailList = %This.getDistPageEmailList(&processInstanceId, &subject, &emlText);
      
      If &asDistPageEmailList <> Null Then
         For &i = 1 To &asDistPageEmailList.Len
            If &i = 1 Then
               &distPageEmailList = &asDistPageEmailList [&i];
            Else
               &distPageEmailList = &distPageEmailList | ";" | &asDistPageEmailList [&i];
            End-If;
         End-For;
      End-If;
   End-If;
   
   /* res 929638 - plug in default viewer UNLESS Bursting defined with Secure distribution*/
   If Not %This.isBurstSecurityOn() Then
      If (&oRptViewerArray = Null) Or
            (&oRptViewerArray.Len = 0) Then
         Local PSXP_RPTDEFNMANAGER:ReportViewer &oRptViewer;
         &oRptViewer = create PSXP_RPTDEFNMANAGER:ReportViewer("2", %UserId);
         &oRptViewerArray = CreateArray(&oRptViewer);
      End-If;
   End-If;
   
   If Not (&bBurst) Then
      rem rshwe2 1891427000;
      If &subject = "" Then
         &subject = MsgGet(&PSXP_MsgSet, 181, "BI Publisher [%1] Report", &ID);
      End-If;
      If &emlText = "" Then
         &emlText = MsgGet(&PSXP_MsgSet, 182, "BI Publisher Report %1 Process ID: %2", &ID, &processInstanceId);
      End-If;
      
      rem rshwe2 1891427000;
      &bRet = %This.PostReportDistribute(&processInstanceId, %DbName, &sOutDest, &sReportDescr, &sFolderName, &sServerName, &dExpire, Null, &oRptViewerArray, &distPageEmailList, &subject, &emlText, "", %This.arOutput [1].OutputFile, 1);
   Else /* burst */
      
      /* get array of output objects  and iterate over each subdirectory */
      For &i = 1 To %This.arOutput.Len;
         
         &RptOutput = %This.arOutput [&i];
         rem rsh ICE 1836783000;
         rem this is just precautionary, users should only use BurstValueAsOutSubDir when output type is File;
         If %This.BurstValueAsOutSubDir Then
            &subdir = &RptOutput.BurstFieldValue;
            &subdir = &MyUtil.ValidateFileName(&subdir);
         Else
            &subdir = String(&i);
         End-If;
         
         rem rsh ICE 1836783000;
         &sSourceReportPath = &sOutDest | &sDirSep | &subdir;
         
         &arPubAttributes = %This.getPubAttributes(&RptOutput.BurstFileInfo);
         &sBurstValue = &RptOutput.BurstFieldValue;
         
         
         &oTempRptViewerArray = Null;
         &oFinalRptViewerArray = Null;
         /* copy defaults from report and process definition into final array*/
         If (&oRptViewerArray <> Null) Then
            For &cnt = 1 To &oRptViewerArray.Len
               If (&oFinalRptViewerArray = Null) Then
                  &oFinalRptViewerArray = CreateArray(&oRptViewerArray [&cnt]);
               Else
                  &oFinalRptViewerArray.Push(&oRptViewerArray [&cnt]);
               End-If;
            End-For;
         End-If;
         
         rem RSH  replace oXMLDoc with BurstFileInfo;
         
         &oTempRptViewerArray = %This.getBurstDistribution(%This.arOutput [&i].BurstFileInfo, &oTempRptViewerArray);
         
         /* add &oTempRptViewerArray to report defnition level and process definition level dist list */
         If &oTempRptViewerArray <> Null Then
            For &cnt = 1 To &oTempRptViewerArray.Len
               If (&oFinalRptViewerArray <> Null) Then
                  &oFinalRptViewerArray.Push(&oTempRptViewerArray [&cnt]);
               Else
                  &oFinalRptViewerArray = CreateArray(&oTempRptViewerArray [&cnt]);
               End-If;
            End-For;
         End-If;
         
         WriteToLog(%ApplicationLogFence_Level2, "Final Distribution list ...");
         /* test - print the distrubution arrray */
         If (&oFinalRptViewerArray <> Null) Then
            For &cnt = 1 To &oFinalRptViewerArray.Len
               WriteToLog(%ApplicationLogFence_Level2, "Final [" | &oFinalRptViewerArray [&cnt].ID | "][" | &oFinalRptViewerArray [&cnt].Type | "]");
            End-For;
         End-If;
         
         
         rem rshwe2 1891427000;
         If &subject = "" Then
            &burstSubj = MsgGet(&PSXP_MsgSet, 183, "BI Publisher [%1] Report [%2]", &ID, &arOutput [&i].BurstFieldValue);
         Else
            &burstSubj = &subject;
         End-If;
         If &emlText = "" Then
            &burstText = MsgGet(&PSXP_MsgSet, 184, "BI Publisher %1 Report; Burst Value: %2 Process ID:%3", &ID, &arOutput [&i].BurstFieldValue, &processInstanceId);
         Else
            &burstText = &emlText;
         End-If;
         
         
         /* post and distribute report */
         
         
         rem rshwe2 1891427000;
         &bRet = %This.PostReportDistribute(&processInstanceId, %DbName, &sSourceReportPath, &sReportDescr, &sFolderName, &sServerName, &dExpire, &arPubAttributes, &oFinalRptViewerArray, &distPageEmailList, &burstSubj, &burstText, &sBurstValue, %This.arOutput [&i].OutputFile, 2);
         
      End-For;
      
   End-If; /* burst or non-burst */
   
   /* Local time &endTime = %PerfTime;
   WriteToLog(%ApplicationLogFence_Level1, "Publish Time: " | &endTime | " - " | &startTime | " = " | String(&endTime - &startTime)); */
end-method;



/* ****************************************************** */
/* PrintOutput method                                     */
/* ****************************************************** */
method PrintOutput
   /+ &DestPrinter as String +/
   Local number &i;
   Local string &sSubDir = "";
   Local string &sPclFile;
   Local string &sPsFile;
   Local boolean &bRes;
   Local string &sPropValue;
   Local string &sRptDir;
   
   
   WriteToLog(%ApplicationLogFence_Level2, "BI Publisher PrintOutput Job Start: " | String(%Datetime));
   
   
   For &i = 1 To %This.arOutput.Len
      rem rsh ICE 1836783000;
      /* This is just precautionary, since users are recommended to use BurstValueAsOutSubDir only wehn output 
		destination type is File */
      If %This.BurstFieldName <> "" Then
         If %This.BurstValueAsOutSubDir Then
            &sSubDir = %This.arOutput [&i].BurstFieldValue;
            &sSubDir = &MyUtil.ValidateFileName(&sSubDir);
         Else
            &sSubDir = String(&i);
         End-If;
      End-If;
      
      &sRptDir = %This.sSrvOutDir;
      If &sSubDir <> "" Then
         &sRptDir = &sRptDir | &sDirSep | &sSubDir;
      End-If;
      
      Evaluate (&sPrinterType)
      When = "PCL"
         &sPclFile = &sRptDir | %This.sDirSep | Substitute(%This.arOutput [&i].OutputFile, ".pdf", ".pcl");
         &MyUtil.ConvertPDFtoPCL(&sRptDir | %This.sDirSep | %This.arOutput [&i].OutputFile, &sPclFile, &oFinalProperties);
         %This.PrintReport(&DestPrinter, &sRptDir, Substitute(%This.arOutput [&i].OutputFile, ".pdf", ".pcl"));
         Break;
      When = "PS"
         &sPsFile = &sRptDir | %This.sDirSep | Substitute(%This.arOutput [&i].OutputFile, ".pdf", ".ps");
         &MyUtil.ConvertPDFtoPS(&sRptDir | %This.sDirSep | %This.arOutput [&i].OutputFile, &sPsFile, &oFinalProperties);
         %This.PrintReport(&DestPrinter, &sRptDir, Substitute(%This.arOutput [&i].OutputFile, ".pdf", ".ps"));
         Break;
      When-Other
         %This.PrintReport(&DestPrinter, &sRptDir, %This.arOutput [&i].OutputFile);
      End-Evaluate;
   End-For;
   
   rem rsh ICE 1836783000;
   If %This.Debug = False Then
      %This.CleanOutput();
   Else
      /*If there is a password to open PDF and debug is true, erase the PCL and PS files*/
      &bRes = &oFinalProperties.getProperty("pdf-open-password", &sPropValue);
      If (&bRes) Then
         If (&sPclFile <> "") Then
            %This.DeleteFile(&sPclFile);
         End-If;
         If (&sPsFile <> "") Then
            %This.DeleteFile(&sPsFile);
         End-If;
      End-If;
      
   End-If;
   WriteToLog(%ApplicationLogFence_Level2, "BI Publisher PrintOutput Job End: " | String(%Datetime));
   
end-method;


/* OIT MD */
/*****************************************************************************************
* Public method setPDFConversionFiles
* Sets ReportDefn property arrPDFConversion with an array of files to be converted to PDF 
* and merged to the report output
******************************************************************************************/

method setPDFConversionFiles
   /+ &convArray as Array of String +/
   If &convArray.Len <> 0 Then
      &arrPDFConversion = &convArray.Clone();
   End-If;
end-method;


/* OIT MD */
/***************************************************
* Public method setPDFConversionTimeOut
* Sets ReportDefn property &pdfConversionTimeOut 
****************************************************/
method setPDFConversionTimeOut
   /+ &interval as Number +/
   &pdfConversionTimeOut = &interval;
end-method;


/* ****************************************************** */
/* Public Help Methods                                    */
/* ****************************************************** */
method GetMetaData
   /+ Returns %Metadata:XMLPubRptMgr:XMLPubRptMgr +/
   Return &Report;
end-method;

method GetMetaDataTemplateControl
   /+ &sFieldValue as String +/
   /+ Returns %Metadata:XMLPubRptMgr:RptTmpltCntrl +/
   Local %metadata:XMLPubRptMgr:RptTmpltCntrl &oInfo;
   Local integer &i;
   
   For &i = 1 To &Report.Count_Xprpttmplctrl
      &oInfo = &Report.Get_Xprpttmplctrl(&i);
      If &oInfo.Xpfieldvalue = &sFieldValue Then
         Return &oInfo;
      End-If;
   End-For;
   
   Return Null;
end-method;

/* MD Submit*/
/*********************************************************
 Expose Report Final Properties as PSXP_ENGINE:Properties
**********************************************************/
method GetFinalProperties
   /+ Returns PSXP_ENGINE:Properties +/
   If &oFinalProperties = Null Then
      %This.processFinalProperties();
   End-If;
   Return &oFinalProperties;
end-method;

/* ****************************************************** */
/* Private Methods                                        */
/* ****************************************************** */
method GetTemplateRuntime
   /+ &TemplateId as String +/
   /+ Returns PSXP_RPTDEFNMANAGER:TemplateDefn +/
   Local PSXP_RPTDEFNMANAGER:TemplateDefn &oTmpl;
   If All(&TemplateId) Then
      &oTmpl = %This.GetTemplate(&TemplateId);
   Else
      &oTmpl = %This.GetDefaultTemplate();
   End-If;
   If &oTmpl = Null Then
      throw CreateException(235, 2302, "Template definition could not be loaded: Template ID = %1", &TemplateId);
   End-If;
   Return &oTmpl;
end-method;

method GetTemplateFileRuntime
   /+ &oTemplate as PSXP_RPTDEFNMANAGER:TemplateDefn, +/
   /+ &AsOfDate as Date +/
   /+ Returns PSXP_RPTDEFNMANAGER:TemplateFile +/
   Local PSXP_RPTDEFNMANAGER:TemplateFile &oTmplFile;
   
   If None(&AsOfDate) Then
      /* if AsOfDate is not specified use current date as AsOfDate */
      &AsOfDate = %AsOfDate;
   End-If;
   &oTmplFile = &oTemplate.GetActiveTemplateFile(&AsOfDate);
   If &oTmplFile = Null Then
      throw CreateException(235, 2303, "An active instance of template %1 could not be found for effective date %2", &oTemplate.ID, String(&AsOfDate));
   End-If;
   Return &oTmplFile;
end-method;

method GetPDFMapFile
   /+ &sMapFile as String, +/
   /+ &oTmplateFile as PSXP_RPTDEFNMANAGER:TemplateFile +/
   /+ Returns Boolean +/
   rem rsh ICE 1836783000;
   Local string &sMappedFile;
   Local boolean &bRtn = False;
   rem rshw ICE 1876037000;
   Local PSXP_ENGINE:PDFMapTool &oPDFMapTool;
   try
      
      rem rshw2 ICE 1766139000;
      &oTmplateFile.SetDir(%This.sSrvProcDir | &sDirSep);
      &sMappedFile = &oTmplateFile.GetMapFile();
      
      If &sMappedFile <> "" Then
         rem rsh ICE 1836783000;
         &oPDFMapTool = create PSXP_ENGINE:PDFMapTool();
         &oPDFMapTool.extractMap(&sMappedFile, &sMapFile);
         rem rshw ICE 1876037000;
         &bRtn = True;
      End-If;
   catch Exception &ex1
      rem rshw;
      WriteToLog(%ApplicationLogFence_Error, "GetPDFMapFile for map file: " | &sMapFile | " failed. " | &ex1.ToString());
   end-try;
   
   /* cleanup */
   rem rshw2 ICE 1766139000;
   %This.DeleteFile(&sMappedFile);
   
   Return &bRtn;
end-method;

method ConvEtxTemplateToXsl
   /+ &sTmplFile as String, +/
   /+ &oTemplateFile as PSXP_RPTDEFNMANAGER:TemplateFile +/
   /+ Returns Boolean +/
   
   Local string &sRTFFile, &sErr;
   Local PSXP_ENGINE:EFTProcessor &oEFTProcessor;
   Local PSXP_ENGINE:Properties &oProperties;
   
   rem rshw ICE 1836783000;
   &oEFTProcessor = create PSXP_ENGINE:EFTProcessor();
   
   &oEFTProcessor.ConfProp = %This.oFinalProperties;
   rem rshw2 ICE 1766139000;
   &oTemplateFile.SetDir(%This.sSrvProcDir | &sDirSep);
   &sRTFFile = &oTemplateFile.GetFile();
   If &oEFTProcessor.generateXSL(&sRTFFile, &sTmplFile, &sErr) = False Then
      throw CreateException(235, 2304, "Error converting RTF template to XSL: %1", &sErr);
   End-If;
   rem rshw ICE 1836783000;
   
   If %This.Debug = False Then
      %This.DeleteFile(&sRTFFile);
   End-If;
   rem rshw Return &sTmplFile;
   Return True;
end-method;

method ConvRtfTemplateToXsl
   /+ &sTmplFile as String, +/
   /+ &oTemplateFile as PSXP_RPTDEFNMANAGER:TemplateFile, +/
   /+ &LocaleCd as String +/
   /+ Returns Boolean +/
   Local string &sRTFFile, &sErr;
   Local PSXP_ENGINE:RTFProcessor &oRTFProcessor;
   Local PSXP_ENGINE:Properties &oProperties;
   
   
   rem rshw ICE 1836783000;
   rem &sTmplFile = %This.GetLocalOutputFile(&TemplateID | ".xsl", "", 1);
   
   WriteToLog(%ApplicationLogFence_Level1, "TMPLFILE: " | &sTmplFile);
   &oRTFProcessor = create PSXP_ENGINE:RTFProcessor();
   If All(&LocaleCd) Then
      &oRTFProcessor.Locale = &LocaleCd;
   End-If;
   
   &oRTFProcessor.ConfProp = %This.oFinalProperties;
   
   rem rshw2 ICE 1766139000;
   &oTemplateFile.SetDir(%This.sSrvProcDir | &sDirSep);
   &sRTFFile = &oTemplateFile.GetFile();
   WriteToLog(%ApplicationLogFence_Level1, "RTFFILE: " | &sRTFFile);
   If &oRTFProcessor.generateXSL(&sRTFFile, &sTmplFile, &sErr) = False Then
      throw CreateException(235, 2304, "Error converting RTF template to XSL: %1", &sErr);
   End-If;
   
   rem rshw ICE 1836783000;
   If %This.Debug = False Then
      %This.DeleteFile(&sRTFFile);
   End-If;
   
   Return True;
end-method;


method GetXliffFile
   /+ &oTmplDefn as PSXP_RPTDEFNMANAGER:TemplateDefn, +/
   /+ &oTemplateFile as PSXP_RPTDEFNMANAGER:TemplateFile, +/
   /+ &LanguageCd as String +/
   /+ Returns String +/
   Local PSXP_RPTDEFNMANAGER:TranslationFile &oXliff;
   Local string &sXliffFile;
   
   If %This.TemplateType = "RTF" Or
         %This.TemplateType = "XSL" Then
      If All(&LanguageCd) And
            &LanguageCd <> &oTmplDefn.LanguageCode Then
         &oXliff = &oTemplateFile.GetTranslationFile(&LanguageCd);
         If &oXliff <> Null And
               &oXliff.Status = "A" Then
            rem rshw2 ICE 1766139000;
            &oXliff.SetDir(%This.sSrvProcDir | &sDirSep);
            &sXliffFile = &oXliff.GetFile();
         End-If;
      End-If;
   End-If;
   
   Return &sXliffFile;
end-method;

rem start RSH ICE 1701671001;

method GenerateXmlFileFromQuery
   /+ &sDataFile as String +/
   
   Local number &i;
   
   If &Report.Ds_type = "QRY" And
         %This.OpenQueryDs() Then
      %This.SetQueryTrackingURL(); /* mdu XXX */
      If Not &oQuery.PromptRecord = Null And
            &recQryPrompt = Null Then
         throw CreateException(235, 2311, "Query prompt record is required.");
      End-If;
      
      &i = &oQuery.RunToFile(&recQryPrompt, &sDataFile, %Query_XML_XmlP, 0); /*Bug 17556660*/
      If (&i <> 0) Then
         throw CreateException(228, 118, "Query Engine returns error.");
      End-If;
      
   End-If;
end-method;

method GenerateXmlFileFromConnQuery
   /+ &sOutFile as String out, +/
   /+ &sProcessId as String +/
   Local boolean &res;
   Local string &str;
   
   If &Report.Ds_type <> "CQR" Then
      Return;
   End-If;
   
   Local PSXP_RPTDEFNMANAGER:DataSourceDefn &oDataSrcDefn;
   &oDataSrcDefn = %This.GetDatasource();
   &ConQryInst = &oDataSrcDefn.ConQryObj;
   If &ConQryInst = Null Then
      Return;
   End-If;
   
   If Not &ConQryInst.Validate() Then
      &str = &ConQryInst.ErrString;
      If &str <> "" Then
         Error &str;
      End-If;
   End-If;
   &ConQryInst.MaxRowsPerQuery = 0;
   If &RunControlId = "" Then /* for debudding AE */
      &RunControlId = &ConQryInst.Name;
   End-If;
   Local PT_CONQRS:SCHED_INFO &schedInfo;
   
   &schedInfo = &ConQryInst.SchedInfo;
   &schedInfo.OUTDESTTYPE = 2;
   &schedInfo.RUN_CNTL_ID = &RunControlId;
   &schedInfo.PROCESS_INSTANCE = &sProcessId;
   &schedInfo.OPRID = %OperatorId;
   &schedInfo.PRCSFILENAME = &ConQryInst.XMLDataFullName;
   &schedInfo.DIRLOCATION = &ConQryInst.GetOutDestinationDir(); /* MD 16757891 */
   &schedInfo.AE_ID = &ConQryInst.Const.SchedRequest_XMLP; /* mdu ICE 1870955000 */
   
   If &ConQryInst.Run( Null, &ConQryInst.SchedInfo) Then
      &sOutFile = &ConQryInst.OutProcessFileName;
   End-If;
   
end-method;

method GenerateXmlFromQuery
   /+ Returns String +/
   Local integer &querytype = %Query_XML_XmlP;
   Local string &sXmlData;
   If &Report.Ds_type = "QRY" And
         %This.OpenQueryDs() Then
      %This.SetQueryTrackingURL(); /* mdu XXX */
      If Not &oQuery.PromptRecord = Null And
            &recQryPrompt = Null Then
         throw CreateException(235, 2311, "Query prompt record is required.");
      End-If;
      &sXmlData = &oQuery.RunToString(&recQryPrompt, 0, &querytype, 0);
      Return &sXmlData;
   End-If;
   
   Return "";
end-method;

rem end rsh ICE 1701671001;

method GenerateXmlFromRowset
   /+ Returns String +/
   Local PSXP_XMLGEN:RowSetDS &oRowSetDS;
   
   If &Report.Ds_type = "RST" And
         &DataRowSet <> Null Then
      &oRowSetDS = create PSXP_XMLGEN:RowSetDS();
      
      Return &oRowSetDS.getXMLData(&DataRowSet, "");
   End-If;
   Return "";
end-method;

method GenerateXmlFromXmlDoc
   /+ Returns String +/
   If &Report.Ds_type = "XMD" And
         &DataXMLDoc <> Null Then
      
      Return &DataXMLDoc.GenXmlString();
   End-If;
   Return "";
end-method;


rem rsh TODO: function should be removed after deprecating ProcessEtextReport;
method ReadDataFile
   /+ Returns String +/
   
   If &DataXMLFile = "" Then
      throw CreateException(235, 2308, "Data file is required but not specified correctly");
   Else
      Return %This.ReadXMLFile(&DataXMLFile);
   End-If;
   
   Return "";
end-method;

/* mdu ICE 1528590000 */
method ReadXMLFile
   /+ &sFilePath as String +/
   /+ Returns String +/
   Local string &sData;
   Local XmlDoc &xmlDoc;
   Local boolean &bRet;
   
   &xmlDoc = CreateXmlDoc("");
   &bRet = &xmlDoc.ParseXmlFromURL(&sFilePath);
   If &bRet Then
      &sData = &xmlDoc.GenXmlString();
   End-If;
   Return &sData;
   
end-method;


rem rsh ICE 1836783000;
method WriteXmlDataFile
   /+ &sXmlData as String, +/
   /+ &sFileName as String +/
   Local string &sLocalDataFile;
   Local File &oXmlFile;
   
   &oXmlFile = GetTempFile(&sFileName, "W", "UTF8", %FilePath_Absolute);
   If &oXmlFile.IsOpen Then
      &oXmlFile.WriteString(&sXmlData);
      &oXmlFile.Close();
   End-If;
   WriteToLog(%ApplicationLogFence_Level1, "WriteXmlDataFile - Data file: " | &sFileName);
   
end-method;


rem rsh;
method GenerateOutput
   /+ &sTmplFile as String, +/
   /+ &sMapFile as String, +/
   /+ &sDataFile as String, +/
   /+ &sXliffFile as String, +/
   /+ &sLocaleCd as String, +/
   /+ &sOutputFile as String, +/
   /+ &iOutputFormat as Integer, +/
   /+ &sErr as String +/
   /+ Returns Boolean +/
   Local PSXP_ENGINE:FOProcessor &oFOProcessor;
   Local PSXP_ENGINE:PDFMapTool &oPDFMapTool;
   Local PSXP_ENGINE:EFTProcessor &oEFTProcessor;
   
   Local ApiObject &oRegionalSettings;
   Local string &sDtFmt, &sDtSep, &sDttmVal, &sDtVal, &sTmVal;
   Local datetime &CurDttm;
   
   rem rshwe;
   Local PSXP_ENGINE:Properties &oProperties = %This.oFinalProperties;
   
   Local string &strOITErr = "Cannot set data for PDF files conversion.";
   
   /* OIT merge */
   /* set Java debug to get Java extra logging */
   If %This.Debug Then
      Local JavaObject &oXMLPJavaUtil = CreateJavaObject("com.peoplesoft.pt.xmlpublisher.XMLPUtil");
      &oXMLPJavaUtil.setDebug( True);
   End-If;
   
   /* process based on template type */
   Evaluate %This.TemplateType
   When = "PDF"
      /* generate output from template, map, and data */
      &oPDFMapTool = create PSXP_ENGINE:PDFMapTool();
      If All(&sLocaleCd) Then
         &oPDFMapTool.Locale = &sLocaleCd;
      End-If;
      &oPDFMapTool.ConfProp = &oProperties;
      rem rshpdf;
      
      If &UsePDFOptimized = True Then
         &oPDFMapTool.setPDFOptimized( True);
      Else
         &oPDFMapTool.setPDFOptimized( False);
      End-If;
      
      /* OIT MD  */
      If &arrPDFConversion.Len > 0 Then
         %This.setPDFConversionData(&sOutputFile); /* OIT Merge */
         If %This.files2Convert = Null Then /* OIT Merge */
            If &sBurstFieldValue <> "" Then
               &strOITErr = &strOITErr | " Burst value is " | &sBurstFieldValue;
            End-If;
            WriteToLog(%ApplicationLogFence_Level1, &strOITErr);
         Else
            &oPDFMapTool.Files2Convert = %This.files2Convert; /* OIT Merge */
         End-If;
      End-If;
      
      &oPDFMapTool.processForm(&sTmplFile, &sDataFile, &sMapFile, &sOutputFile);
      
      If %This.files2Convert <> Null Then
         If Not %This.mergePDFReportWithAttachments(&sOutputFile) Then /* OIT Merge */
            Return False;
         End-If;
      End-If;
      
      Break;
   When = "ETX"
      /* XSL to output file */
      &oEFTProcessor = create PSXP_ENGINE:EFTProcessor();
      &oEFTProcessor.ConfProp = &oProperties;
      If Not &oEFTProcessor.generateOutput(&sTmplFile, &sDataFile, &sOutputFile, &sErr) Then
         
         Return False;
      End-If;
      
      Break;
   When = "RTF"
   When = "XSL"
      /* XSL to output file */
      &oFOProcessor = create PSXP_ENGINE:FOProcessor();
      If All(&sLocaleCd) Then
         &oFOProcessor.Locale = &sLocaleCd;
      End-If;
      
      
      /* set system properties */
      &oRegionalSettings = %Session.RegionalSettings;
      &sDtSep = &oRegionalSettings.DateSeparator;
      Evaluate &oRegionalSettings.DateFormat
      When 1 /* DMY */
         &sDtFmt = "dd" | &sDtSep | "MM" | &sDtSep | "yyyy";
         Break;
      When 2 /* YMD */
         &sDtFmt = "yyyy" | &sDtSep | "MM" | &sDtSep | "dd";
         Break;
      When-Other /* MDY */
         &sDtFmt = "MM" | &sDtSep | "dd" | &sDtSep | "yyyy";
         Break;
      End-Evaluate;
      
      /* time zone support */
      &CurDttm = %Datetime;
      &CurDttm = DateTimeToTimeZone(&CurDttm, "Base", &oRegionalSettings.ClientTimeZone);
      
      
      &sDttmVal = DateTimeToLocalizedString(&CurDttm, &sDtFmt | " HH:mm:ss");
      &sDtVal = Split(&sDttmVal, " ")[1];
      &sTmVal = Split(&sDttmVal, " ")[2];
      
      Local boolean &bRes;
      &bRes = &oProperties.setProperty("xslt._XDOTIMEZONE", "'" | &oRegionalSettings.ClientTimeZone | "'");
      &bRes = &oProperties.setProperty("xslt.ReportID", "'" | %This.ID | "'");
      &bRes = &oProperties.setProperty("xslt.ReportTitle", "'" | %This.Description | "'");
      &bRes = &oProperties.setProperty("xslt.RunDate", "'" | &sDtVal | "'");
      &bRes = &oProperties.setProperty("xslt.RunTime", "'" | &sTmVal | "'");
      
      
      rem image folders for xls and html reports;
      If &iOutputFormat = 3 Or
            &iOutputFormat = 4 Or
            &iOutputFormat = 6 Then /* bug 17938514 -  3=HTML, 4=XLS_MHTML, 6=XLS_HTML require this */
         &bRes = &oProperties.setProperty("html-image-dir", GetDirectoryFromPath(&sOutputFile));
         &bRes = &oProperties.setProperty("html-image-base-uri", &BaseImageURI);
         rem rsh ICE 1836754000;
         &bRes = &oProperties.setProperty("xslt._XDOCHARTTYPE", "'image/png'");
      End-If;
      
      Local string &sValue;
      &bRes = &oSystemProperties.getProperty("system-temp-dir", &sValue);
      If &bRes = False Or
            &sValue = "" Then
         rem rsh ICE 1766139000 set default engine tmp dir if not set in xdo.cfg;
         rem we can not use %This.sTmpSrvDir as tmp directory here, because of xdodebug.cfg is enabled we won't be able to delete this folder, engine will hold the tmp .fo file.
         rem &bRes = &oProperties.setProperty("system-temp-dir", GetEnv("PS_SERVDIR"));
         &bRes = &oProperties.setProperty("system-temp-dir", &envServerDir | &sDirSep | "files" | &sDirSep | "XMLP");
         
      End-If;
      
      &oFOProcessor.ConfProp = &oProperties;
      
      /* OIT MD  */
      If &arrPDFConversion.Len > 0 Then
         %This.setPDFConversionData(&sOutputFile); /* OIT Merge */
         If %This.files2Convert = Null Then /* OIT Merge */
            If &sBurstFieldValue <> "" Then
               &strOITErr = &strOITErr | " Burst value is " | &sBurstFieldValue;
            End-If;
            WriteToLog(%ApplicationLogFence_Level1, &strOITErr);
            &oFOProcessor.Files2Convert = Null;
         Else
            &oFOProcessor.Files2Convert = %This.files2Convert; /* OIT Merge */
         End-If;
      End-If;
      
      
      If Not &oFOProcessor.generateOutput(&sTmplFile, &sDataFile, &sXliffFile, &sOutputFile, &iOutputFormat, &sErr) Then
         Return False;
      End-If;
      
      If %This.files2Convert <> Null Then
         If Not %This.mergePDFReportWithAttachments(&sOutputFile) Then /* OIT Merge */
            Return False;
         End-If;
      End-If;
      
      Break;
   When-Other;
      /* nothing to do */
      Break;
   End-Evaluate;
   
   Return True;
end-method;



method GenerateStringOutput
   /+ &sTmplFile as String, +/
   /+ &sXmlData as String, +/
   /+ &sLocaleCd as String, +/
   /+ &sErr as String +/
   /+ Returns String +/
   Local PSXP_ENGINE:EFTProcessor &oEFTProcessor;
   Local ApiObject &oRegionalSettings;
   Local string &sDtFmt, &sDtSep, &sDttmVal, &sDtVal, &sTmVal;
   Local datetime &CurDttm;
   Local string &sEFTOutput;
   Local boolean &bRet;
   
   WriteToLog(%ApplicationLogFence_Level3, "GenerateStringOutput : " | "template file ... " | &sTmplFile | " LocaleCd ... " | &sLocaleCd);
   
   /* XSL to output file */
   &oEFTProcessor = create PSXP_ENGINE:EFTProcessor();
   
   &oEFTProcessor.ConfProp = %This.oFinalProperties;
   
   &bRet = &oEFTProcessor.generateStreamOutput(&sTmplFile, &sXmlData, &sEFTOutput, &sErr);
   If (&bRet) Then
      Return &sEFTOutput;
   Else
      throw CreateException(235, 2309, "Failure in generating report output: %1", &sErr);
   End-If;
   
   Return "";
end-method;


method OpenQueryDs
   /+ Returns Boolean +/
   Local boolean &bQryOpen;
   Local PSXP_RPTDEFNMANAGER:DataSourceDefn &oDataSrcDefn;
   
   &bQryOpen = False;
   
   If &Report.Ds_type = "QRY" Then
      /* query is already open */
      If Not &oQuery = Null Then
         Return True;
      End-If;
      
      &oDataSrcDefn = %This.GetDatasource();
      
      /* check query security - public only */
      If &oDataSrcDefn.DSPublic = True And
            %Session.CheckQueryObjectSecurity(&Report.Ds_id) = 2 Then
         throw CreateException(12, 2, "You are not authorized to access the definitin %1", &Report.Ds_id);
      End-If;
      
      &oQuery = %Session.GetQuery();
      /* Try public query first - if not found try private */
      If &oQuery.Open(&oDataSrcDefn.Name, &oDataSrcDefn.DSPublic, False) = 0 Then
         If &oQuery.GetTreePromptCount() <> 0 Then /* bug 12402786  */
            &oQuery.Close();
            throw CreateException(241, 93, "###Queries with InTree/Not InTree prompts are Not supported ", &oDataSrcDefn.Name);
         End-If;
         Return True;
      End-If;
   End-If;
   
   Return False;
end-method;

method DeleteFile
   /+ &sFilePath as String +/
   Local File &oFile;
   If All(&sFilePath) Then
      &oFile = GetFile(&sFilePath, "R", %FilePath_Absolute);
      If &oFile.IsOpen Then
         &oFile.Delete();
      End-If;
   End-If;
end-method;

method generateExpiryDate
   /+ &processInstanceId as Number +/
   /+ Returns Date +/
   Local date &dExpire;
   Local number &nPeriodValue;
   Local string &sPeriodUnit;
   Local date &givenDate;
   Local number &num_days, &num_months, &num_years;
   
   &givenDate = %This.ArchiveDate;
   &nPeriodValue = %This.ArchiveAfter;
   &sPeriodUnit = %This.ArchiveUnit;
   &dExpire = %Date;
   &num_days = 0;
   &num_months = 0;
   &num_years = 0;
   
   If All(&givenDate) Then
      &dExpire = &givenDate;
   End-If;
   
   If (&processInstanceId <> 0) Then
      SQLExec("SELECT PT_RETENTIONDAYS FROM PSPRCSRQST WHERE PRCSINSTANCE = :1", &processInstanceId, &num_days);
      If &num_days > 0 Then
         &dExpire = AddToDate(%Date, 0, 0, &num_days);
      Else
         &dExpire = AddToDate(%Date, 0, 0, %This.getDefaultArchiveDays());
      End-If;
   Else /* if unit filer supplied, override onDate */
      If (&nPeriodValue > 0) And
            (&sPeriodUnit <> "") Then
         /* TBD - need to validate this or take default as days? ( &sPeriodUnit > 0) */
         Evaluate &sPeriodUnit
         When "0" /* default = days */
         When "3" /* Days  */
            &num_days = &nPeriodValue;
            Break;
         When "2" /* Months */
            &num_months = &nPeriodValue;
            Break;
         When "1" /* years */
            &num_years = &nPeriodValue;
            Break;
         End-Evaluate;
         
         &dExpire = AddToDate(%Date, &num_years, &num_months, &num_days);
      Else
         /*ICE  1439591000 */
         If None(&givenDate) Then
            /* no date or number of days specified for expiration. Get the system setting */
            &num_days = %This.getDefaultArchiveDays();
            &dExpire = AddToDate(%Date, 0, 0, &num_days);
         End-If;
      End-If;
   End-If;
   Return &dExpire;
   
end-method;


method PrintReport
   /+ &sDestPrinter as String, +/
   /+ &sRptDir as String, +/
   /+ &sOutputFile as String +/
   Local string &sCmdFileExt;
   Local string &sPrintCmdDir;
   Local string &sCmdSrcFilePath;
   Local File &oCmdSrcFile;
   Local string &sCmdFilePath;
   Local File &oCmdFile;
   Local string &sRptFilePath;
   Local string &sLine;
   
   /* determine command file extension based on platform type */
   If &sDirSep = "\" Then /* Windows */
      &sCmdFileExt = ".bat";
   Else /* unix/uss */
      &sCmdFileExt = ".sh";
   End-If;
   
   /* remove trainling directory separator as it causes error */
   If Substring(&sDestPrinter, Len(&sDestPrinter), 1) = &sDirSep Then
      &sDestPrinter = Substring(&sDestPrinter, 1, Len(&sDestPrinter) - 1);
   End-If;
   WriteToLog(%ApplicationLogFence_Level2, "Printer: " | &sDestPrinter);
   
   /* MD Signature */
   If &IsPDFSignatureRequired Then
      If Not FileExists(&sRptDir, %FilePath_Absolute) Then
         throw CreateException(235, 220, "###Cannot create a BI Publisher Report due to getting Digital Certificate error");
      End-If;
   End-If;
   
   /* Bug 11739369 - Create psxprint bat file under its own unique temp dir 
	ONLY need to do this if not debug. If debug mode, we may use same temp dir*/
   If %This.Debug = False Then
      &sPrintCmdDir = &envServerDir | &sDirSep | "files" | &sDirSep | "XMLP" | &sDirSep | UuidGen();
      CreateDirectory(&sPrintCmdDir, %FilePath_Absolute);
   Else
      &sPrintCmdDir = %This.sSrvTmpDir;
   End-If;
   
   /* create command file */
   rem rsh ICE 1836783000;
   rem &sCmdFilePath = %This.OutDestination | &sDirSep | "psxprint" | &sCmdFileExt;
   &sCmdFilePath = &sPrintCmdDir | &sDirSep | "psxprint" | &sCmdFileExt;
   WriteToLog(%ApplicationLogFence_Level2, "Command file: " | &sCmdFilePath);
   
   &oCmdFile = GetFile(&sCmdFilePath, "W", %FilePath_Absolute);
   If Not &oCmdFile.IsOpen Then
      throw CreateException(235, 2311, "Failed to create print command file");
   End-If;
   
   /* report output file */
   &sRptFilePath = &sRptDir | &sDirSep | &sOutputFile;
   WriteToLog(%ApplicationLogFence_Level2, "Report file: " | &sRptFilePath);
   
   /* command template */
   &sCmdSrcFilePath = &envServerDir | &sDirSep | "psxprint" | &sCmdFileExt;
   
   Local string &sTest;
   If FileExists(&sCmdSrcFilePath, %FilePath_Absolute) Then
      /* if source file exist, create command file using source file as template */
      WriteToLog(%ApplicationLogFence_Level2, "Command template file: " | &sCmdSrcFilePath);
      &oCmdSrcFile = GetFile(&sCmdSrcFilePath, "R", %FilePath_Absolute);
      While &oCmdSrcFile.ReadLine(&sLine)
         /* substitute variables */
         &sLine = Substitute(&sLine, "%RPTOUTDIR%", &sRptDir);
         &sLine = Substitute(&sLine, "%REPORTFILE%", &sRptFilePath);
         &sLine = Substitute(&sLine, "%DESTPRINTER%", &sDestPrinter);
         &oCmdFile.WriteLine(&sLine);
      End-While;
      &oCmdSrcFile.Close();
   Else
      /* command source file cannot be opened - generate command file without template */
      If &sDirSep = "\" Then /* Windows */
         
         /* Bug 11739369 - surround &sRptFilePath in quotes in case it has spaces in it (and if not already quoted)*/
         If Substring(&sRptFilePath, 1, 1) <> """" Then
            &sRptFilePath = """" | &sRptFilePath | """";
         End-If;
         /* Bug 20391656 - surround &sDestPrinter in quotes in case it has spaces in it (and if not already quoted)*/
         If Substring(&sDestPrinter, 1, 1) <> """" Then
            &sDestPrinter = """" | &sDestPrinter | """";
         End-If;
         
         &oCmdFile.WriteLine("copy " | &sRptFilePath | " " | &sDestPrinter);
         
      Else /* unix/uss */
         rem bug 14534174 &oCmdFile.WriteLine("lp -d " | &sDestPrinter | " " | &sRptFilePath);
         &oCmdFile.WriteLine("lp -c -d " | &sDestPrinter | " " | &sRptFilePath);
      End-If;
   End-If;
   &oCmdFile.Close();
   
   /* execute the command file */
   If &sDirSep = "\" Then
      /* Bug 11739369 - surround &sCmdFilePath in quotes in case it has spaces in it (and if not already quoted)*/
      If Substring(&sCmdFilePath, 1, 1) = """" Then
         Exec(&sCmdFilePath, %Exec_Synchronous + %FilePath_Absolute);
      Else
         Exec("""" | &sCmdFilePath | """", %Exec_Synchronous + %FilePath_Absolute);
      End-If;
   Else
      Exec("sh " | &sCmdFilePath, %Exec_Synchronous + %FilePath_Absolute);
   End-If;
   rem rsh TODO: Need to verify success;
   
   If %This.Debug = False Then
      try
         RemoveDirectory(&sPrintCmdDir, %FilePath_Absolute + %Remove_Subtree);
      catch Exception &Exp
         WriteToLog(%ApplicationLogFence_Error, "Could not delete Directory:" | &sPrintCmdDir);
      end-try;
   End-If;
end-method;

rem rsh ICE 1836783000;
method CleanOutput
   
   If Not &bIsOutDestinationSet Then /* mdu outdestin */
      
      try
         RemoveDirectory(%This.sSrvOutDir, %FilePath_Absolute + %Remove_Subtree);
         RemoveDirectory(%This.OutDestination, %FilePath_Absolute + %Remove_Subtree); /* mdu outdestin */
         
      catch Exception &Exp1
         WriteToLog(%ApplicationLogFence_Error, "Could not delete Directory:" | %This.sSrvOutDir);
      end-try;
      
   End-If;
   try
      RemoveDirectory(%This.sSrvTmpDir, %FilePath_Absolute + %Remove_Subtree);
   catch Exception &Exp2
      WriteToLog(%ApplicationLogFence_Error, "Could not delete Directory:" | %This.sSrvTmpDir);
   end-try;
   
end-method;

method getDefaultFolderName
   /+ Returns String +/
   Local string &foldername;
   
   &foldername = %This.FolderName; /* mdu ICE 1520060000 */
   If None(&foldername) Then /* mdu ICE 1520060000 */
      SQLExec("SELECT PSRF_FOLDER_NAME FROM PSRF_FLIST_TBL WHERE PSRF_IS_DEFAULT = 'Y'", &foldername);
   End-If;
   
   Return &foldername;
end-method;

method Publish_Message_Attrib
   /+ &prcsinstId as Number, +/
   /+ &reportId as Number, +/
   /+ &sDbName as String, +/
   /+ &sFileURL as String, +/
   /+ &attrArray as Array2 of String +/
   /+ Returns Boolean +/
   
   Local Message &CURMSG;
   Local integer &i;
   Local Rowset &RS, &RATTR_ROWSET;
   Local Record &AttrRec;
   Local Record &fileURLRec;
   
   /* mdu 1548157000 returning if &attrArray = Null */
   If &attrArray = Null Then
      Return True;
   Else
      If &attrArray.Len = 0 Then
         Return True;
      End-If;
   End-If;
   
   &CURMSG = CreateMessage(Operation.PSXP_RATTR);
   If Not &CURMSG.IsActive Then
      WriteToLog(%ApplicationLogFence_Error, "Message PSXP_RATTR is not active ");
      Return False;
   Else
      /* fill up message rowset with attributeArray */
      &RS = &CURMSG.GetRowset();
      &fileURLRec = &RS.GetRow(1).GetRecord(Record.PSXP_FILEURL);
      &fileURLRec.PRCSINSTANCE.Value = &prcsinstId;
      &fileURLRec.CONTENTID.Value = &reportId;
      &fileURLRec.DBNAME.Value = &sDbName;
      &fileURLRec.DOC_URL.Value = &sFileURL;
      
      WriteToLog(%ApplicationLogFence_Level1, "PRCSINSTANCE : " | &fileURLRec.PRCSINSTANCE.Value | " CONTENTID : " | &fileURLRec.CONTENTID.Value | " DOC_URL : " | &fileURLRec.DOC_URL.Value);
      
      
      If (&attrArray <> Null) Then
         WriteToLog(%ApplicationLogFence_Level1, "Number of search attributes to insert " | &attrArray.Len);
      End-If;
      
      If &attrArray <> Null Then
         For &i = 1 To &attrArray.Len
            
            &RATTR_ROWSET = &RS.GetRow(&RS.ActiveRowCount).GetRowset(Scroll.PSXP_RATTR_TBL);
            &AttrRec = &RATTR_ROWSET.GetRow(1).GetRecord(Record.PSXP_RATTR_TBL);
            &AttrRec.PRCSINSTANCE.Value = &prcsinstId;
            &AttrRec.CONTENTID.Value = &reportId;
            &AttrRec.DBNAME.Value = &sDbName;
            &AttrRec.PSXP_ATTRIBUT_NAME.Value = &attrArray [&i][1];
            &AttrRec.PSXP_ATTRIBUT_VALU.Value = &attrArray [&i][2];
            &AttrRec.PSXP_IS_BURST_FLD.Value = &attrArray [&i][3];
            &RS.InsertRow(&RS.ActiveRowCount);
            
            WriteToLog(%ApplicationLogFence_Level2, "Attribute Name : " | &AttrRec.PSXP_ATTRIBUT_NAME.Value | " Attribute value : " | &AttrRec.PSXP_ATTRIBUT_VALU.Value | " Burst : " | &AttrRec.PSXP_IS_BURST_FLD.Value);
            
         End-For;
      End-If;
      
      %IntBroker.Publish(&CURMSG);
      Return True;
      
   End-If;
end-method;


rem build a publication attributes array from burst and search keys and values;
method getPubAttributes
   /+ &oBurstFileInfo as PSXP_RPTDEFNMANAGER:BurstFileInfo +/
   /+ Returns Array2 of String +/
   Local array of array of string &aSearchKeysAndValues = Null;
   Local array of string &aSearchKeys;
   Local string &sSearchString;
   Local integer &i, &j;
   
   rem RSH ICE 1837605000;
   &aSearchKeysAndValues = CreateArray(CreateArray(%This.BurstFieldName, &oBurstFileInfo.BurstValue, "Y"));
   &aSearchKeys = %This.GetSearchFields();
   If &aSearchKeys = Null Then
      Return &aSearchKeysAndValues;
   End-If;
   
   For &i = 1 To &aSearchKeys.Len
      rem RSH TODO: This is currently not working for non-unique burst fields since multiple search values for a signle search field are ignored;
      &sSearchString = &oBurstFileInfo.getFieldValues(&aSearchKeys [&i])[1];
      
      &aSearchKeysAndValues.Push(CreateArray(&aSearchKeys [&i], &sSearchString, "N"));
   End-For;
   
   Return &aSearchKeysAndValues;
end-method;



method isBurstingOn
   /+ Returns Boolean +/
   Local boolean &bursting;
   Local string &burstFldName;
   
   /* TBD - consider runtime flag */
   &bursting = False;
   &burstFldName = %This.BurstFieldName;
   If All(&burstFldName) Then
      &bursting = True;
   Else
      &bursting = False;
   End-If;
   Return &bursting;
   
end-method;


/* res 929638 - check if Security Join Table in use for Bursting*/
method isBurstSecurityOn
   /+ Returns Boolean +/
   Local string &SecJoinTbl = %This.SecurityJoinTable;
   
   If %This.isBurstingOn() And
         All(&SecJoinTbl) Then
      Return True;
   Else
      Return False;
   End-If;
end-method;


method getRptDefnDistribution
   /+ &oRptViewerArray as Array of PSXP_RPTDEFNMANAGER:ReportViewer +/
   /+ Returns Array of PSXP_RPTDEFNMANAGER:ReportViewer +/
   
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &oTempArray;
   Local PSXP_RPTDEFNMANAGER:ReportViewer &oRptViewer;
   Local integer &i;
   
   /* get distribution options from report viewer */
   &oTempArray = %This.GetReportViewers();
   If (&oTempArray = Null) Or
         (&oTempArray.Len = 0) Then
      Return &oRptViewerArray;
   End-If;
   
   For &i = 1 To &oTempArray.Len
      &oRptViewer = &oTempArray [&i];
      If (&oRptViewerArray = Null) Or
            (&oRptViewerArray.Len = 0) Then
         &oRptViewerArray = CreateArray(&oRptViewer);
      Else
         &oRptViewerArray.Push(&oRptViewer);
      End-If;
   End-For;
   
   Return &oRptViewerArray;
   
end-method;

method getRuntimeDistribution
   /+ &processInstanceId as Number, +/
   /+ &oRptViewerArray as Array of PSXP_RPTDEFNMANAGER:ReportViewer +/
   /+ Returns Array of PSXP_RPTDEFNMANAGER:ReportViewer +/
   Local PSXP_RPTDEFNMANAGER:ReportViewer &oRptViewer;
   Local SQL &sqlDist;
   Local string &distIdType, &distId, &sUserType;
   
   &sqlDist = CreateSQL("SELECT DISTIDTYPE, DISTID FROM PS_PRCSRQSTDIST WHERE PRCSINSTANCE = :1", &processInstanceId);
   While &sqlDist.Fetch(&distIdType, &distId);
      If &distIdType = "2" Then
         &sUserType = "USER";
      Else
         &sUserType = "ROLE";
      End-If;
      &oRptViewer = create PSXP_RPTDEFNMANAGER:ReportViewer(&sUserType, &distId);
      WriteToLog(%ApplicationLogFence_Level1, "Distribution : IdType = " | &sUserType | " Id = " | &distId);
      
      If (&oRptViewerArray = Null) Or
            (&oRptViewerArray.Len = 0) Then
         &oRptViewerArray = CreateArray(&oRptViewer);
      Else
         &oRptViewerArray.Push(&oRptViewer);
      End-If;
      
   End-While;
   &sqlDist.Close();
   
   Return &oRptViewerArray;
   
end-method;

method getRolesInPermList
   /+ &sPermList as String +/
   /+ Returns Array of String +/
   Local array of string &aRoles;
   Local SQL &oRolesSQL;
   Local string &sRoleId;
   
   &oRolesSQL = CreateSQL("SELECT B.ROLENAME FROM PSCLASSDEFN A, PSROLECLASS B WHERE A.CLASSID = B.CLASSID AND A.CLASSID = :1", &sPermList);
   While &oRolesSQL.Fetch(&sRoleId);
      If (&aRoles = Null) Then
         &aRoles = CreateArray(&sRoleId);
      Else
         &aRoles.Push(&sRoleId);
      End-If;
   End-While;
   
   Return &aRoles;
   
end-method;

method PostReportDistribute
   /+ &processInstanceId as Number, +/
   /+ &sDbName as String, +/
   /+ &outDest as String, +/
   /+ &sReportDescr as String, +/
   /+ &folderName as String, +/
   /+ &serverName as String, +/
   /+ &dExpire as Date, +/
   /+ &attrArray as Array2 of String, +/
   /+ &oRptViewerArray as Array of PSXP_RPTDEFNMANAGER:ReportViewer, +/
   /+ &distPageEmailList as String, +/
   /+ &emailSubject as String, +/
   /+ &emailText as String, +/
   /+ &sburstVal as String, +/
   /+ &sFileName as String, +/
   /+ &LogLevel as Number +/
   /+ Returns Boolean +/
   
   Local PostReport &Post;
   Local string &sUserType, &sUserId;
   Local boolean &bRet;
   Local integer &i;
   Local number &RptInstance;
   Local string &sDistNodeURL;
   Local string &sRptURL;
   
   If &LogLevel = 1 Then /* mdu 1548157000 */
      WriteToLog(%ApplicationLogFence_Level1, "PostReportDistribute : Process Instance : " | &processInstanceId | " DBName : " | &sDbName | "Destination: " | &outDest | " ReportDescr : " | &sReportDescr);
   Else
      WriteToLog(%ApplicationLogFence_Level2, "PostReportDistribute : Process Instance : " | &processInstanceId | " DBName : " | &sDbName | "Destination: " | &outDest | " ReportDescr : " | &sReportDescr);
      
   End-If;
   /* create postReportObject */
   &Post = SetPostReport();
   &Post.ProcessName = "XMLP"; /* do not change. used by Report Search view */
   &Post.ProcessType = "XML Publisher";
   &Post.SourceReportPath = &outDest;
   
   If (&sburstVal <> "") Then
      &sburstVal = " [" | &sburstVal | "] ";
   Else
      &sburstVal = " ";
   End-If;
   /* RSH Descriptive Names
   &Post.ReportDescr = %This.ID | &sburstVal | &sReportDescr;
   */
   &Post.ReportDescr = %This.ID | &sburstVal | "- " | &sFileName;
   
   &Post.ReportFolder = &folderName;
   &Post.ServerName = &serverName;
   &Post.ExpirationDate = &dExpire;
   &Post.IsBurstedReport = True;
   /* ICE 1467012000 */
   &Post.OutDestFormat = &sOutDestFormat;
   If (&processInstanceId <> 0) Then
      &Post.ProcessInstance = &processInstanceId;
   End-If;
   rem rshwe2 1891427000;
   
   
   If (%This.AllowViewerEntry = "Y" Or
         %This.AllowViewerEntry = "y") Then
      &Post.SetEmailOption(&emailSubject, &emailText, &distPageEmailList);
   End-If;
   
   /* set distribution options */
   If &oRptViewerArray <> Null Then
      For &i = 1 To &oRptViewerArray.Len
         &sUserType = &oRptViewerArray [&i].Type;
         &sUserId = &oRptViewerArray [&i].ID;
         If (&sUserType = "2") Then
            &sUserType = &sDistIdType_User;
         End-If;
         If (&sUserType = "3") Then
            &sUserType = &sDistIdType_Role;
         End-If;
         If &LogLevel = 1 Then /* mdu 1548157000 */
            WriteToLog(%ApplicationLogFence_Level1, "PostReportDistribute : usertype " | &sUserType | " userid " | &sUserId);
         Else
            WriteToLog(%ApplicationLogFence_Level2, "PostReportDistribute : usertype " | &sUserType | " userid " | &sUserId);
         End-If;
         &Post.AddDistributionOption(&sUserType, &sUserId);
         
      End-For;
   Else
      WriteToLog(%ApplicationLogFence_Warning, "*** Warning! Report access is not set.");
   End-If;
   
   
   /* do post */
   
   &Post.Put();
   &RptInstance = &Post.ReportId;
   &RptInstance = Truncate(&RptInstance, 0); /* mdu */
   If &RptInstance > 0 Then
      
      If &sDistributionNode_URL = "" Then
         If &processInstanceId <> 0 Then
            SQLExec("select C.URL from PSPRCSRQST A, PS_SERVERDEFN B, PS_CDM_DIST_NODE C WHERE A.PRCSINSTANCE =:1 AND A.SERVERNAMERUN = B.SERVERNAME AND B.DISTNODENAME = C.DISTNODENAME", &processInstanceId, &sDistNodeURL); /* mdu XXX */
         Else
            SQLExec("select C.URL from PSPRCSRQST A, PS_SERVERDEFN B, PS_CDM_DIST_NODE C WHERE A.SERVERNAMERUN = B.SERVERNAME AND B.DISTNODENAME = C.DISTNODENAME", &sDistNodeURL);
         End-If;
         
         If &sDistNodeURL <> "" Then
            &sDistributionNode_URL = &sDistNodeURL;
         End-If;
      End-If;
      &processInstanceId = &Post.ProcessInstance;
      rem RSH;
      &sRptURL = &sDistributionNode_URL | "/" | &RptInstance | "/" | &sFileName;
      If &LogLevel = 1 Then /* mdu 1548157000 */
         WriteToLog(%ApplicationLogFence_Level1, "Publish : Report Instance : " | &RptInstance | " Process Instance : " | &processInstanceId);
         WriteToLog(%ApplicationLogFence_Level1, "DistributionNode URL: " | &sDistributionNode_URL | "; Report URL: " | &sRptURL);
      Else
         WriteToLog(%ApplicationLogFence_Level2, "Publish : Report Instance : " | &RptInstance | " Process Instance : " | &processInstanceId);
         WriteToLog(%ApplicationLogFence_Level2, "DistributionNode URL: " | &sDistributionNode_URL | "; Report URL: " | &sRptURL);
      End-If;
      /* set search attribute data */
      &bRet = %This.Publish_Message_Attrib(&processInstanceId, &RptInstance, &sDbName, &sRptURL, &attrArray);
      
   Else
      WriteToLog(%ApplicationLogFence_Error, "*** Warning! Report could not be posted");
   End-If;
   
   Return &bRet;
   
end-method;


method getRecepientTagValue
   /+ &oBurstFileInfo as PSXP_RPTDEFNMANAGER:BurstFileInfo, +/
   /+ &sTagName as String +/
   /+ Returns String +/
   
   Local string &sTagValue;
   
   /* search TagName in xmldoc - get into array of nodes get value of first node =TagValue;
      get value of all other nodes and compare with first one
      if any of it does not match, we have bad data..warn the user...move on with value found in first one */
   
   Local integer &i;
   
   Local array of string &arRecieptValues;
   
   Local string &sTempTagValue;
   
   &sTempTagValue = "";
   
   WriteToLog(%ApplicationLogFence_Level2, "Searching xml for distribution tag  " | &sTagName);
   
   rem    RSH;
   &arRecieptValues = &oBurstFileInfo.getFieldValues(&sTagName);
   If &arRecieptValues.Len > 1 Then
      WriteToLog(%ApplicationLogFence_Level2, "Warning - suspicious xml data! one report cannot have multiple distribution sections. Found " | &sTagName | " " | &arRecieptValues.Len | " times ");
   End-If;
   
   &sTagValue = &arRecieptValues [1];
   WriteToLog(%ApplicationLogFence_Level2, "Search key " | &sTagName | " Value " | &sTagValue);
   
   For &i = 1 To &arRecieptValues.Len
      WriteToLog(%ApplicationLogFence_Level2, "Checking for conflicting values ");
      
      &sTempTagValue = &arRecieptValues [&i];
      If (&sTempTagValue <> &sTagValue) Then
         WriteToLog(%ApplicationLogFence_Level2, "Values don't match  " | &sTempTagValue);
         /* TBD - issue warning in session log */
         /* one warning is enough */
         Break;
      Else
         WriteToLog(%ApplicationLogFence_Level2, "values match for " | &i);
      End-If; /* test value match */
   End-For;
   Return &sTagValue;
   
end-method;


method getBurstDistribution
   /+ &oBurstFileInfo as PSXP_RPTDEFNMANAGER:BurstFileInfo, +/
   /+ &aRptViewers as Array of PSXP_RPTDEFNMANAGER:ReportViewer +/
   /+ Returns Array of PSXP_RPTDEFNMANAGER:ReportViewer +/
   
   Local string &sSJTableName, &sSJTRecepientFldName, &sSJTIDType;
   Local array of PSXP_RPTDEFNMANAGER:ScopeField &arrayScopeFlds;
   Local PSXP_RPTDEFNMANAGER:ScopeField &oScopeFld;
   Local string &sTagName, &sSJTFldName;
   Local string &sTagValue;
   Local integer &cnt;
   Local string &sSQLWhere;
   Local string &sSQL;
   Local string &sDistId;
   Local SQL &oSQL;
   Local PSXP_RPTDEFNMANAGER:ReportViewer &oRptViewer;
   Local array of string &aRoles;
   
   &sSJTableName = %This.SecurityJoinTable;
   &sSJTRecepientFldName = %This.SecurityFieldName;
   &sSJTIDType = %This.SecurityIDType;
   &arrayScopeFlds = %This.GetScopeFields();
   
   WriteToLog(%ApplicationLogFence_Level2, " SecurityJoinTable  ... " | &sSJTableName);
   WriteToLog(%ApplicationLogFence_Level2, " SecurityRecepientFld ... " | &sSJTRecepientFldName);
   WriteToLog(%ApplicationLogFence_Level2, " SecureIDType ... " | &sSJTIDType);
   
   If (&arrayScopeFlds = Null) Or
         (&arrayScopeFlds.Len = 0) Then
      /* report is bursted but not distributed? - may be this is fine..*/
      /* TBD handle error */
      Return &aRptViewers;
   End-If;
   
   &sSQLWhere = "";
   
   For &cnt = 1 To &arrayScopeFlds.Len
      &oScopeFld = &arrayScopeFlds [&cnt];
      &sTagName = &oScopeFld.DataSourceField;
      &sSJTFldName = &oScopeFld.SecurityField;
      
      If (&sTagName <> "") Then
         
         &sTagValue = %This.getRecepientTagValue(&oBurstFileInfo, &sTagName);
         
         If (&sTagValue <> "") Then
            If (&sSQLWhere <> "") Then
               &sSQLWhere = &sSQLWhere | " and " | &sSJTFldName | " = '" | &sTagValue | "'";
            Else
               &sSQLWhere = &sSJTFldName | " = '" | &sTagValue | "'";
            End-If;
         End-If;
      End-If;
   End-For;
   
   If (&sSQLWhere <> "") Then
      &sSQL = "SELECT " | &sSJTRecepientFldName | " FROM %Table(" | &sSJTableName | ") where " | &sSQLWhere;
   Else
      Return &aRptViewers;
   End-If;
   
   /* {select SJTID from SJTblname
       where MappedFldName1 = tagValue1
       and MappedFldName2 = tagValue2} 
   */
   
   WriteToLog(%ApplicationLogFence_Level2, " SQL ... " | &sSQL);
   
   &oSQL = CreateSQL(&sSQL);
   While &oSQL.Fetch(&sDistId)
      If (&sSJTIDType = "4") Then
         &aRoles = %This.getRolesInPermList(&sDistId);
         If (&aRoles <> Null) Then
            For &cnt = 1 To &aRoles.Len
               &sDistId = &aRoles [&cnt];
               &oRptViewer = create PSXP_RPTDEFNMANAGER:ReportViewer(&sDistIdType_Role, &sDistId);
               If (&aRptViewers = Null) Or
                     (&aRptViewers.Len = 0) Then
                  &aRptViewers = CreateArray(&oRptViewer);
               Else
                  &aRptViewers.Push(&oRptViewer);
               End-If;
            End-For;
         End-If;
      Else
         /* SJTIDType is either user or role */
         If (&sSJTIDType = "2") Then
            &sSJTIDType = &sDistIdType_User;
         End-If;
         If (&sSJTIDType = "3") Then
            &sSJTIDType = &sDistIdType_Role;
         End-If;
         
         &oRptViewer = create PSXP_RPTDEFNMANAGER:ReportViewer(&sSJTIDType, &sDistId);
         If (&aRptViewers = Null) Or
               (&aRptViewers.Len = 0) Then
            &aRptViewers = CreateArray(&oRptViewer);
         Else
            &aRptViewers.Push(&oRptViewer);
         End-If;
         
      End-If;
      
   End-While;
   
   Return &aRptViewers;
   
end-method;

method getDefaultArchiveDays
   /+ Returns Integer +/
   Local integer &archDays;
   
   SQLExec("SELECT PT_RETENTIONDAYS FROM PS_PRCSSYSTEM ", &archDays);
   Return &archDays;
   
end-method;


/* rem rshw ICE 1836783000;
 TODO: Remove this function, since xml files are now deleted 
inside processReport() */
method deleteDataXML
   
   Local string &sOutDest, &sXmlFile;
   Local integer &i;
   Local File &oFile;
   
   /* ICE 1490279000 : do not delete the original data file if datasource is xml file and the report is not bursted  */
   If &Report.Ds_type = "XML" And
         &Report.Burst_fieldname = "" Then
      Return;
   End-If;
   
   &sOutDest = %This.sSrvTmpDir | &sDirSep | "Data";
   For &i = 1 To %This.arOutput.Len;
      &sXmlFile = %This.arOutput [&i].XmlDataFile;
      If All(&sXmlFile) Then
         If FileExists(&sXmlFile, %FilePath_Absolute) Then /* mdu conn */
            
            &oFile = GetFile(&sXmlFile, "R", %FilePath_Absolute);
            If &oFile.IsOpen Then
               &oFile.Delete();
               WriteToLog(%ApplicationLogFence_Level2, "Deleted Data file: " | &sXmlFile);
            End-If;
            
         End-If;
      End-If;
   End-For;
   RemoveDirectory(&sOutDest, %FilePath_Absolute + %Remove_Subtree);
   
end-method;


/* ****************************************************** */
/* Managed Object Properties                              */
/* ****************************************************** */

get Description
   /+ Returns String +/
   Return (&Report.Descr);
end-get;

set Description
   /+ &NewValue as String +/
   If Not &Report.Descr = &NewValue Then
      &DefnChanged = True;
      &Report.Descr = &NewValue;
   End-If;
end-set;

get Status
   /+ Returns String +/
   Return (&Report.Report_status);
end-get;

set Status
   /+ &NewValue as String +/
   If Not &Report.Report_status = &NewValue Then
      &DefnChanged = True;
      &Report.Report_status = &NewValue;
   End-If;
end-set;

get CategoryID
   /+ Returns String +/
   Return (&Report.Report_category_id);
end-get;

set CategoryID
   /+ &NewValue as String +/
   If Not &Report.Report_category_id = &NewValue Then
      &DefnChanged = True;
      &Report.Report_category_id = &NewValue;
   End-If;
end-set;

get TemplateType
   /+ Returns String +/
   Return (&Report.Template_type);
end-get;

set TemplateType
   /+ &NewValue as String +/
   If Not &Report.Template_type = &NewValue Then
      &DefnChanged = True;
      &Report.Template_type = &NewValue;
   End-If;
end-set;

get OutputEditable
   /+ Returns Boolean +/
   If &Report.Is_editable = "Y" Or
         &Report.Is_editable = "y" Then
      Return ( True);
   Else
      Return ( False);
   End-If;
end-get;

set OutputEditable
   /+ &NewValue as Boolean +/
   If Not %This.OutputEditable = &NewValue Then
      &DefnChanged = True;
      If &NewValue = True Then
         &Report.Is_editable = "Y";
      Else
         &Report.Is_editable = "N";
      End-If;
   End-If;
end-set;


rem rsh;
get EnforceUniqueBurstValue
   /+ Returns Boolean +/
   If &Report.UniqueBurstValue = "Y" Or
         &Report.UniqueBurstValue = "y" Then
      Return ( True);
   Else
      Return ( False);
   End-If;
end-get;

rem rsh;
set EnforceUniqueBurstValue
   /+ &NewValue as Boolean +/
   If Not %This.EnforceUniqueBurstValue = &NewValue Then
      &DefnChanged = True;
      If &NewValue = True Then
         &Report.UniqueBurstValue = "Y";
      Else
         &Report.UniqueBurstValue = "N";
      End-If;
   End-If;
end-set;


get OutDestination
   /+ Returns String +/
   Return (&Report.Outdest);
end-get;

set OutDestination
   /+ &NewValue as String +/
   If Not &Report.Outdest = &NewValue Then
      &DefnChanged = True;
      &Report.Outdest = &NewValue;
   End-If;
end-set;

get OutDestinationType
   /+ Returns String +/
   Return (&Report.Outdesttype);
end-get;

set OutDestinationType
   /+ &NewValue as String +/
   If Not &Report.Outdesttype = &NewValue Then
      &DefnChanged = True;
      &Report.Outdesttype = &NewValue;
   End-If;
end-set;

get DestinationPrinter
   /+ Returns String +/
   Return (&Report.Destprinter);
end-get;

set DestinationPrinter
   /+ &NewValue as String +/
   If Not &Report.Destprinter = &NewValue Then
      &DefnChanged = True;
      &Report.Destprinter = &NewValue;
   End-If;
end-set;

get FolderName
   /+ Returns String +/
   Return (&Report.Psrf_folder_name);
end-get;

set FolderName
   /+ &NewValue as String +/
   If Not &Report.Psrf_folder_name = &NewValue Then
      &DefnChanged = True;
      &Report.Psrf_folder_name = &NewValue;
   End-If;
end-set;

get ArchiveDate
   /+ Returns Date +/
   Return (&Report.Archive_on);
end-get;

set ArchiveDate
   /+ &NewValue as Date +/
   If Not &Report.Archive_on = &NewValue Then
      &DefnChanged = True;
      &Report.Archive_on = &NewValue;
   End-If;
end-set;


get ArchiveAfter
   /+ Returns Number +/
   rem  Return (&Report.Psxp_archive_value);
   %This.SyncArchiveValueFields();
   Return (&Report.Psxp_archivevalue4);
end-get;

set ArchiveAfter
   /+ &NewValue as Number +/
   
   If Not &Report.Psxp_archivevalue4 = &NewValue Then
      &DefnChanged = True;
      &Report.Psxp_archivevalue4 = &NewValue;
   End-If;
   If &NewValue = 0 Then
      &IsNoArchiveValue = True;
   End-If;
end-set;

get ArchiveUnit
   /+ Returns String +/
   Return (&Report.Psxp_archive_unit);
end-get;

set ArchiveUnit
   /+ &NewValue as String +/
   If Not &Report.Psxp_archive_unit = &NewValue Then
      &DefnChanged = True;
      &Report.Psxp_archive_unit = &NewValue;
   End-If;
end-set;

get BurstFieldName
   /+ Returns String +/
   Return (&Report.Burst_fieldname);
end-get;

set BurstFieldName
   /+ &NewValue as String +/
   If Not &Report.Burst_fieldname = &NewValue Then
      &DefnChanged = True;
      &Report.Burst_fieldname = &NewValue;
   End-If;
end-set;

/* RSH Descriptive */
get ReportFileName
   /+ Returns String +/
   Return (&Report.Userfilename);
end-get;

set ReportFileName
   /+ &NewValue as String +/
   If Not &Report.Userfilename = &NewValue Then
      &DefnChanged = True;
      &Report.Userfilename = &NewValue;
   End-If;
end-set;


get SecurityJoinTable
   /+ Returns String +/
   Return (&Report.Sec_join_table);
end-get;

set SecurityJoinTable
   /+ &NewValue as String +/
   If Not &Report.Sec_join_table = &NewValue Then
      &DefnChanged = True;
      &Report.Sec_join_table = &NewValue;
   End-If;
end-set;

get SecurityFieldName
   /+ Returns String +/
   Return (&Report.Security_fieldname);
end-get;

set SecurityFieldName
   /+ &NewValue as String +/
   If Not &Report.Security_fieldname = &NewValue Then
      &DefnChanged = True;
      &Report.Security_fieldname = &NewValue;
   End-If;
end-set;

get SecurityIDType
   /+ Returns String +/
   Return (&Report.Secidtype);
end-get;

set SecurityIDType
   /+ &NewValue as String +/
   If Not &Report.Secidtype = &NewValue Then
      &DefnChanged = True;
      &Report.Secidtype = &NewValue;
   End-If;
end-set;

get TemplateControlFieldName
   /+ Returns String +/
   Return (&Report.Tmplctrl_fieldname);
end-get;

set TemplateControlFieldName
   /+ &NewValue as String +/
   If Not &Report.Tmplctrl_fieldname = &NewValue Then
      &DefnChanged = True;
      &Report.Tmplctrl_fieldname = &NewValue;
   End-If;
end-set;


get AllowRecipientEntry
   /+ Returns String +/
   Return (&Report.Rtemailmod);
end-get;

set AllowRecipientEntry
   /+ &NewValue as String +/
   If Not &Report.Rtemailmod = &NewValue Then
      &DefnChanged = True;
      &Report.Rtemailmod = &NewValue;
   End-If;
end-set;

get AllowViewerEntry
   /+ Returns String +/
   Return (&Report.Rtviewermod);
end-get;

set AllowViewerEntry
   /+ &NewValue as String +/
   If Not &Report.Rtviewermod = &NewValue Then
      &DefnChanged = True;
      &Report.Rtviewermod = &NewValue;
   End-If;
end-set;

get ObjectOwnerID
   /+ Returns String +/
   Return (&Report.ObjectOwnerId);
end-get;

set ObjectOwnerID
   /+ &NewValue as String +/
   If Not &Report.ObjectOwnerId = &NewValue Then
      &DefnChanged = True;
      &Report.ObjectOwnerId = &NewValue;
   End-If;
end-set;

get RegisteredBy
   /+ Returns String +/
   Return (&Report.Registered_by);
end-get;

get RegisteredDTTM
   /+ Returns DateTime +/
   Return (&Report.Registered_dttm);
end-get;


get LastUpdateOprID
   /+ Returns String +/
   Return (&Report.LastUpdOprId);
end-get;


get LastUpdateDTTM
   /+ Returns DateTime +/
   Return (&Report.LastUpdDttm);
end-get;


get IsReadOnly
   /+ Returns Boolean +/
   Return (&DefnPermission = &MyUtil.PSXP_PermReadOnly);
end-get;

rem rsh TODO: Remove this unused function;
/**************************Method getXMLDocFromDataFile*************************************
Parameters:      string that represents the XMLData file path
                 XMLDoc - an empty object to be populated from passed XMLData file 
Returns:         XMLDoc Object
*********************************************************************************************/

method getXMLDocFromDataFile /* mdu 1548157000  */
   /+ &sFilePath as String, +/
   /+ &oXmlDoc as XmlDoc +/
   /+ Returns Boolean +/
   Local boolean &bRet;
   If &sFilePath = "" Then
      WriteToLog(%ApplicationLogFence_Error, "ERROR! Invalid XML data file path - " | &sFilePath);
      Return &bRet;
   End-If;
   
   &bRet = &oXmlDoc.ParseXmlFromURL(&sFilePath);
   
   If Not &bRet Then
      WriteToLog(%ApplicationLogFence_Error, "ERROR! Invalid XML data file path - " | &sFilePath);
   End-If;
   
   Return &bRet;
end-method;




/************** EMAIL OUTPUT ENHANCEMENT FOR 8.50 - PKP ***********************/
/* EmailOutput:   Sends the output to EMAIL.
   Input Parameters: Process Instance Id
   Return Value: None
   Notes:  Gets report definition distribution users, Run Time Distribution Users,
           Run Time email addresses and Burst Distribution (for bursted reports)
           and sends email to them with the report as an attachment.
   Steps:
       1. Get Run time email information (User IDs, Subject, Text, additional email addresses).
       2. Get the output filenames and paths.
          If bursting, get the burst distribution.
       3. Call PrepareAndSendEmail.
       4. Update PSPRCSRQST table with the distribution info. 
 */

method EmailOutput
   /+ &processInstanceId as Number +/
   /+ Returns Boolean +/
   Local integer &n, &i, &burstCnt;
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &oRptViewerArray, &runTimeViewers;
   Local boolean &ret, &sqlRet;
   Local string &outputFile, &subject, &burstSubj, &emlText, &burstText, &outputPath;
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &distEmailInfo;
   Local array of string &rptDefnEmailIDs, &viewersEmails, &burstEmailIDs, &distPageEmailList, &tempEmailList;
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &burstViewers;
   Local string &destStr, &eflname;
   Local string &sqlStr;
   Local SQL &mySQL;
   Local array of string &Filenames, &Attachments, &eFilenames;
   Local integer &prcsCnt;
   
   /* Initialize */
   &destStr = "";
   &ret = False;
   &sqlRet = False;
   &subject = "";
   &emlText = "";
   &burstSubj = "";
   &burstText = "";
   &distPageEmailList = CreateArrayRept("", 0);
   
   /* MD ext email */
   /* EmailOutput method should only be used for scheduled reports - this is a reason for checking &processInstanceId for 0 */
   If &processInstanceId = 0 Then
      throw CreateException(235, 3351, "ERROR: EmailOutput method could only be used for scheduled reports");
   End-If;
   
   
   rem rshwe;
   If (%This.AllowViewerEntry = "Y" Or
         %This.AllowViewerEntry = "y") Then
      rem get prcs scheduler runtime distribution viewers list;
      &oRptViewerArray = %This.getRuntimeDistribution(&processInstanceId, &oRptViewerArray);
      rem get report definition viewers;
      &oRptViewerArray = %This.getRptDefnDistribution(&oRptViewerArray);
      rem retrieve Email lists, subject and text from Distribution page;
      &distPageEmailList = %This.getDistPageEmailList(&processInstanceId, &subject, &emlText);
   Else
      /* Ignore runtime distribution page info, only get report definition level distribution list */
      &oRptViewerArray = %This.getRptDefnDistribution(&oRptViewerArray);
   End-If;
   
   
   /* res 929638 - plug in default viewer UNLESS Bursting defined with Secure distribution OR External Email feature being used*/
   If Not (%This.isBurstSecurityOn() Or
         &bIsExtEmail) Then
      If (&oRptViewerArray = Null) Or
            (&oRptViewerArray.Len = 0) Then
         Local PSXP_RPTDEFNMANAGER:ReportViewer &oRptViewer;
         &oRptViewer = create PSXP_RPTDEFNMANAGER:ReportViewer("2", %UserId);
         &oRptViewerArray = CreateArray(&oRptViewer);
      End-If;
   End-If;
   
   rem Obtain email addresses for the viewers;
   If &oRptViewerArray <> Null Then
      &viewersEmails = %This.getEmailAddresses(&oRptViewerArray);
   End-If;
   
   rem combine viewer emails with distribution page emails (if available);
   If &distPageEmailList <> Null Then
      %This.CombineArrays(&viewersEmails, &distPageEmailList);
   End-If;
   
   /* MD ext email - combining email array from xml file with report definition email array for non-bursted reports */
   If &aExtUserEmailAddresses <> Null Then
      If &aExtUserEmailAddresses.Len > 0 Then
         %This.CombineArrays(&viewersEmails, &aExtUserEmailAddresses);
      End-If;
   End-If;
   
   rem Build a comma seprated string of all emails;
   If &viewersEmails <> Null Then
      For &n = 1 To &viewersEmails.Len
         If &n = 1 Then
            &destStr = &viewersEmails [&n];
         Else
            &destStr = &destStr | "," | &viewersEmails [&n];
         End-If;
      End-For;
   End-If;
   
   /* Steps 2 and 3 */
   If (%This.isBurstingOn()) Then
      rem rshw ICE 1836783000;
      Local string &sSubDir;
      For &burstCnt = 1 To &arOutput.Len
         
         rem rshw ICE 1836783000;
         rem this is just precautionary, users should only use BurstValueAsOutSubDir output type is File;
         If %This.BurstValueAsOutSubDir Then
            &sSubDir = &arOutput [&burstCnt].BurstFieldValue;
            &sSubDir = &MyUtil.ValidateFileName(&sSubDir);
         Else
            &sSubDir = String(&burstCnt);
         End-If;
         rem rshw ICE 1836783000;
         &outputPath = %This.sSrvOutDir | &sDirSep | &sSubDir | &sDirSep;
         &outputFile = &outputPath | &arOutput [&burstCnt].OutputFile;
         &Filenames = FindFiles(&outputPath | "*", %FilePath_Absolute);
         &Attachments = CreateArrayRept("", 0);
         &eFilenames = CreateArrayRept("", 0);
         rem rshwe this is all about reports with images;
         For &i = 1 To &Filenames.Len
            If &Filenames [&i] = &outputPath | "." Or
                  &Filenames [&i] = &outputPath | ".." Then
               Continue;
            Else
               &Attachments.Push(&Filenames [&i]);
               &eflname = Substring(&Filenames [&i], Len(&outputPath) + 1, Len(&Filenames [&i]) - Len(&outputPath));
               &eFilenames.Push(&eflname);
            End-If;
         End-For;
         
         &burstViewers = Null;
         &burstViewers = %This.getBurstDistribution(&arOutput [&burstCnt].BurstFileInfo, &burstViewers);
         
         If &subject = "" Then
            &burstSubj = MsgGet(&PSXP_MsgSet, 183, "BI Publisher [%1] Report [%2]", &ID, &arOutput [&burstCnt].BurstFieldValue);
         Else
            &burstSubj = &subject;
         End-If;
         If &emlText = "" Then
            &burstText = MsgGet(&PSXP_MsgSet, 184, "BI Publisher %1 Report; Burst Value: %2 Process ID:%3", &ID, &arOutput [&burstCnt].BurstFieldValue, &processInstanceId);
         Else
            &burstText = &emlText;
         End-If;
         
         /* MD ext email */
         If &bIsExtEmail Then
            &sBurstFieldValue = &arOutput [&burstCnt].BurstFieldValue;
            If &sBurstFieldValue <> "" Then
               If Not %This.getExtEmailAddressArray() Then
                  throw CreateException(235, 3350, "Failed in retrieving external email recipients list");
               End-If;
            End-If;
         End-If;
         
         If &burstViewers <> Null Then
            &burstEmailIDs = %This.getEmailAddresses(&burstViewers);
            rem combine our calculated viewer emails with burst emails;
            %This.CombineArrays(&burstEmailIDs, &viewersEmails);
            If &burstEmailIDs <> Null Then
               %This.CombineArrays(&burstEmailIDs, &aExtUserEmailAddresses); /* MD ext email */
               &ret = %This.PrepareAndSendEmail(&burstEmailIDs, &Attachments, &eFilenames, &burstSubj, &burstText);
            End-If;
         Else
            rem if no burst emails are available, email to our viewers;
            
            Local array of string &aExtUserEmailAddressesCopy = &aExtUserEmailAddresses;
            If &aExtUserEmailAddresses <> Null Then
               If &aExtUserEmailAddresses.Len > 0 Then
                  If &viewersEmails <> Null Then
                     %This.CombineArrays(&aExtUserEmailAddressesCopy, &viewersEmails); /* MD ext email */
                  End-If;
                  &ret = %This.PrepareAndSendEmail(&aExtUserEmailAddressesCopy, &Attachments, &eFilenames, &burstSubj, &burstText);
               Else
                  If &viewersEmails <> Null Then
                     &ret = %This.PrepareAndSendEmail(&viewersEmails, &Attachments, &eFilenames, &burstSubj, &burstText);
                  End-If;
               End-If;
               
            Else
               If &viewersEmails <> Null Then
                  &ret = %This.PrepareAndSendEmail(&viewersEmails, &Attachments, &eFilenames, &burstSubj, &burstText);
               End-If;
            End-If;
         End-If;
      End-For;
      
      
   Else
      rem rshw ICE 1836783000;
      &outputPath = %This.sSrvOutDir | &sDirSep;
      &outputFile = &outputPath | &arOutput [1].OutputFile;
      &Filenames = FindFiles(&outputPath | "*", %FilePath_Absolute);
      &Attachments = CreateArrayRept("", 0);
      &eFilenames = CreateArrayRept("", 0);
      For &n = 1 To &Filenames.Len
         If &Filenames [&n] = &outputPath | "." Or
               &Filenames [&n] = &outputPath | ".." Then
            Continue;
         Else
            &Attachments.Push(&Filenames [&n]);
            &eflname = Substring(&Filenames [&n], Len(&outputPath) + 1, Len(&Filenames [&n]) - Len(&outputPath));
            &eFilenames.Push(&eflname);
         End-If;
         WriteToLog(%ApplicationLogFence_Level2, "Attachment:" | &n | ":" | &Filenames [&n]);
      End-For;
      WriteToLog(%ApplicationLogFence_Level2, "OutputFile:" | &outputFile | " File# " | &Attachments.Len);
      If &subject = "" Then
         &subject = MsgGet(&PSXP_MsgSet, 181, "BI Publisher [%1] Report", &ID);
      End-If;
      If &emlText = "" Then
         &emlText = MsgGet(&PSXP_MsgSet, 182, "BI Publisher Report %1 Process ID: %2", &ID, &processInstanceId);
      End-If;
      
      If &viewersEmails <> Null Then
         &ret = %This.PrepareAndSendEmail(&viewersEmails, &Attachments, &eFilenames, &subject, &emlText);
      End-If;
   End-If;
   
   /* Step 4 
   rem rshw ICE 1849904000; */
   &sqlStr = "select count(*) from PSPRCSRQSTTEXT where PRCSINSTANCE = " | &processInstanceId | " and RQSTTEXTTYPE ='4'";
   &mySQL = CreateSQL(&sqlStr);
   &sqlRet = &mySQL.Fetch(&prcsCnt);
   If &prcsCnt = 0 Then
      SQLExec("INSERT INTO PSPRCSRQSTTEXT VALUES (:1, '4', %TextIn(:2))", &processInstanceId, &destStr);
   Else
      SQLExec("UPDATE PSPRCSRQSTTEXT SET RQST_TEXT = :1 WHERE PRCSINSTANCE = :2 AND RQSTTEXTTYPE ='4'", &destStr, &processInstanceId);
   End-If;
   
   If %This.Debug = False Then
      %This.CleanOutput();
   End-If;
   Return &ret;
   
end-method;


/* MD CPY */
/***********************************************************************************************************
* Public method CopyDefn
* Copies Report definition with all related objects
* Returns boolean
***********************************************************************************************************/
method CopyDefn
   /+ &sTargID as String +/
   /+ Returns Boolean +/
   Local %metadata:XMLPubRptMgr:XMLPubRptMgr &mgrCloneDefn;
   Local %metadata:Key &key;
   Local number &i, &k, &j;
   
   
   try
      If Not &DefnPermission = &MyUtil.PSXP_PermFullAccess Then
         throw CreateException(&PSXP_MsgSet, 2023, "User %1 does not have permission to update report definition %2.", %OperatorId, &ID);
      End-If;
      
      If %This.Exists(&sTargID) Then
         throw CreateException(&PSXP_MsgSet, 2007, "Report definition %1 already exists.", &sTargID);
      End-If;
      
      &mgrCloneDefn = &Report.CopyDefn(); /* creating a copy of Report Definition Manager -  %metadata:XMLPubRptMgr:XMLPubRptMgr */
      If &mgrCloneDefn = Null Then
         Return False;
      End-If;
      &mgrCloneDefn.Report_defn_id = &sTargID;
      &mgrCloneDefn.Registered_by = %OperatorId;
      &mgrCloneDefn.Registered_dttm = %Datetime;
      &mgrCloneDefn.LastUpdOprId = %OperatorId;
      &mgrCloneDefn.LastUpdDttm = &mgrCloneDefn.Registered_dttm;
      
      /* getting a newly created clone report instance */
      Local PSXP_RPTDEFNMANAGER:ReportDefn &cloneRptDefn;
      &cloneRptDefn = create PSXP_RPTDEFNMANAGER:ReportDefn(&sTargID);
      
      If &mgrCloneDefn = Null Then
         throw CreateException(&PSXP_MsgSet, 2010, "Get of report definition %1 failed.", &sTargID);
      End-If;
      &cloneRptDefn.Report = &mgrCloneDefn; /* setting new metadata for cloned Report definition - %metadata:XMLPubRptMgr:XMLPubRptMg */
      &cloneRptDefn.DefnNew = True;
      
      
      /* copiing Template files */
      Local %metadata:XMLPubRptMgr:RptTmpl &oInfo, &oInfoTmplClone;
      Local PSXP_RPTDEFNMANAGER:TemplateDefn &oCloneTmplDefn;
      Local string &tmplNameClone, &oldTemplId;
      Local %metadata:XMLPubTmpltMgr:XMLPubTmpltMgr &tmplDefnMgr, &cloneTmplDefnMgr;
      Local %metadata:XMLPubTmpltMgr:XMLPubTmpltMgr_Manager &mgr;
      Local array of PSXP_RPTDEFNMANAGER:TemplateControl &aTmplControl;
      
      /* Getting TemplateControl List to update with new Template names */
      &aTmplControl = &cloneRptDefn.GetTemplateControlList();
      
      For &i = &cloneRptDefn.GetMetaData().Count_Xprpttmpl To 1 Step - 1
         &oInfo = &cloneRptDefn.GetMetaData().Get_Xprpttmpl(&i);
         
         &oldTemplId = &oInfo.Template_id;
         &tmplNameClone = &mgrCloneDefn.Report_defn_id | "_" | String(&i);
         
         &mgr = create %metadata:XMLPubTmpltMgr:XMLPubTmpltMgr_Manager();
         &key = create %metadata:Key(Key:Class_TemplateID, &oInfo.Template_id);
         &tmplDefnMgr = &mgr.GetDefn(&key);
         
         &cloneTmplDefnMgr = &tmplDefnMgr.CopyDefn(); /* created  a copy of old Template definition manager- %metadata:XMLPubTmpltMgr:XMLPubTmpltMgr */
         
         If &cloneTmplDefnMgr = Null Then
            Return False;
         End-If;
         &cloneTmplDefnMgr.Template_id = &tmplNameClone;
         &cloneTmplDefnMgr.Registered_by = %OperatorId;
         &cloneTmplDefnMgr.Registered_dttm = %Datetime;
         &oInfoTmplClone = &cloneRptDefn.GetMetaData().Get_Xprpttmpl(&i);
         &oInfoTmplClone.Template_id = &tmplNameClone;
         
         &oCloneTmplDefn = create PSXP_RPTDEFNMANAGER:TemplateDefn(&oInfo.Template_id);
         
         /* assigning new metadata to &oCloneTmplDefn */
         &oCloneTmplDefn.SetMetadata(&cloneTmplDefnMgr);
         
         /* Updating TemplateControl List with new Template names */
         If Not &cloneRptDefn.TmpCtrls = Null Then
            If Not &aTmplControl = Null Then
               For &k = 1 To &aTmplControl.Len
                  If &aTmplControl [&k].TemplateID = &oldTemplId Then
                     &aTmplControl [&k].TemplateID = &oInfoTmplClone.Template_id;
                  End-If;
               End-For;
            End-If;
         End-If;
         
         /* copying Template files and updating  PSXPTMPLFILEDEF,	PSXPTMPLTRINFO */
         Local %metadata:XMLPubTmpltMgr:FileDef &tmplFileInfo;
         Local %metadata:FileMgr:FileMgr &fileObj;
         Local %metadata:XMLPubTmpltMgr:TrInfo &tmplFileTrInfo;
         Local PSXP_RPTDEFNMANAGER:FileDefn &oFileDefn;
         Local string &mapFileId, &tmplFileId, &xsltFileId, &xsdFileId, &trnFileId;
         
         For &k = 1 To &cloneTmplDefnMgr.Count_Xptmplfiledef
            &tmplFileInfo = &cloneTmplDefnMgr.Get_Xptmplfiledef(&k);
            If &tmplFileInfo.Mapfile_fileid <> "" Then
               &oFileDefn = create PSXP_RPTDEFNMANAGER:FileDefn(&tmplFileInfo.Mapfile_fileid);
               &oFileDefn.Get();
               &fileObj = &oFileDefn.CopyDefn();
               &tmplFileInfo.Mapfile_fileid = &fileObj.FileId;
               &oFileDefn = Null;
               If Not &fileObj.SaveNewDefn() Then
                  throw CreateException(&PSXP_MsgSet, 9999, "CopyDefn new File Definition failed");
               End-If;
               &fileObj = Null;
            End-If;
            
            If &tmplFileInfo.Template_fileid <> "" Then
               &oFileDefn = create PSXP_RPTDEFNMANAGER:FileDefn(&tmplFileInfo.Template_fileid);
               &oFileDefn.Get();
               &fileObj = &oFileDefn.CopyDefn();
               &tmplFileInfo.Template_fileid = &fileObj.FileId;
               &oFileDefn = Null;
               If Not &fileObj.SaveNewDefn() Then
                  throw CreateException(&PSXP_MsgSet, 9999, "CopyDefn new File Definition failed");
               End-If;
               &fileObj = Null;
            End-If;
            
            If &tmplFileInfo.XSD_fileid <> "" Then
               &oFileDefn = create PSXP_RPTDEFNMANAGER:FileDefn(&tmplFileInfo.XSD_fileid);
               &oFileDefn.Get();
               &fileObj = &oFileDefn.CopyDefn();
               &tmplFileInfo.XSD_fileid = &fileObj.FileId;
               &oFileDefn = Null;
               &fileObj = Null;
            End-If;
            
            If &tmplFileInfo.XSLT_fileid <> "" Then
               &oFileDefn = create PSXP_RPTDEFNMANAGER:FileDefn(&tmplFileInfo.XSLT_fileid);
               &oFileDefn.Get();
               &fileObj = &oFileDefn.CopyDefn();
               &tmplFileInfo.XSLT_fileid = &fileObj.FileId;
               &oFileDefn = Null;
               If Not &fileObj.SaveNewDefn() Then
                  throw CreateException(&PSXP_MsgSet, 9999, "CopyDefn new File Definition failed");
               End-If;
               &fileObj = Null;
            End-If;
            
            For &j = 1 To &tmplFileInfo.Count_Xptmpltrinfo
               &tmplFileTrInfo = &tmplFileInfo.Get_Xptmpltrinfo(&j);
               If &tmplFileTrInfo.Xliff_fileid <> "" Then
                  &oFileDefn = create PSXP_RPTDEFNMANAGER:FileDefn(&tmplFileTrInfo.Xliff_fileid);
                  &oFileDefn.Get();
                  &fileObj = &oFileDefn.CopyDefn();
                  &tmplFileTrInfo.Xliff_fileid = &fileObj.FileId;
                  &oFileDefn = Null;
                  If Not &fileObj.SaveNewDefn() Then
                     throw CreateException(&PSXP_MsgSet, 9999, "CopyDefn new File Definition failed");
                  End-If;
                  &fileObj = Null;
               End-If;
            End-For;
            
         End-For;
         
         If Not &cloneTmplDefnMgr.SaveNewDefn() Then
            throw CreateException(&PSXP_MsgSet, 9999, "CopyDefn from " | %This.ID | " to " | &sTargID | " failed ");
         End-If;
         
      End-For;
      
      If &mgrCloneDefn.SaveNewDefn() Then
         Return True;
      Else
         throw CreateException(188, 2007, "Save of %1 failed.", &sTargID);
      End-If;
      
      
   catch Exception &e
      /* error */
      WriteToLog(%ApplicationLogFence_Error, "CopyDefn from " | %This.ID | " to " | &sTargID | " failed " | &e.ToString());
      Return False;
   end-try;
   
   Return True;
end-method;


/*************************************Public Help Methods************************************/
/* getEmailAddresses:   Gets email addresses for the given set of users from the database.
   Input Parameters: Viewers array (string)
   Return Value: Array of email addresses
   Notes:  
 */
method getEmailAddresses
   /+ &aViewers as Array of PSXP_RPTDEFNMANAGER:ReportViewer +/
   /+ Returns Array of String +/
   Local integer &i;
   Local string &vtype;
   Local SQL &mySQL;
   Local string &roles, &users, &tViewer;
   Local string &emailaddr, &sqlStr;
   Local array of string &emailIds;
   
   For &i = 1 To &aViewers.Len
      &tViewer = &aViewers [&i].ID;
      &vtype = &aViewers [&i].Type;
      WriteToLog(%ApplicationLogFence_Level2, "Viewer:" | &i | ": " | &tViewer | " Type:" | &vtype);
      If (&vtype = "USER" Or
            &vtype = "2") Then
         If (&users <> "") Then
            &users = &users | ",'" | &aViewers [&i].ID | "'";
         Else
            &users = "'" | &aViewers [&i].ID | "'";
         End-If
      Else
         If (&roles <> "") Then
            &roles = &roles | ",'" | &aViewers [&i].ID | "'";
         Else
            &roles = "'" | &aViewers [&i].ID | "'";
         End-If
      End-If;
   End-For;
   
   If (&users <> "") Or
         (&roles <> "") Then
      &sqlStr = "select distinct emailid from PS_ROLEUSER_VW where ";
      If (&users <> "") And
            (&roles <> "") Then
         &sqlStr = &sqlStr | "ROLEUSER in (" | &users | ") or ROLENAME in (" | &roles | ")";
      Else
         If (&users <> "") Then
            &sqlStr = &sqlStr | "ROLEUSER in (" | &users | ")"
         Else
            &sqlStr = &sqlStr | "ROLENAME in (" | &roles | ") ";
         End-If;
      End-If;
      WriteToLog(%ApplicationLogFence_Level2, "SqlStr : " | &sqlStr);
      
      &mySQL = CreateSQL(&sqlStr);
      &i = 0;
      While &mySQL.Fetch(&emailaddr);
         WriteToLog(%ApplicationLogFence_Level2, "Email Addr:" | &emailaddr);
         If (&i = 0) Then
            &emailIds = CreateArray(&emailaddr);
         Else
            &emailIds.Push(&emailaddr);
         End-If;
         &i = &i + 1;
      End-While;
      &mySQL.Close();
   End-If;
   
   Return &emailIds;
   
end-method;

/* PrepareAndSendEmail:   Sends the output to EMAIL.
   Input Parameters: 
         emailAddresses - Array of email addresses
         AttachFiles - XML Publisher report files that are to be sent as an attachment (full path with filename)
         efnames  - Names of the files (needed for AddAttachment() method of the email)
         Subject    - Email Subject
   Return Value: True or False
   Notes:  
 */
method PrepareAndSendEmail
   /+ &emailAddresses as Array of String, +/
   /+ &AttachFiles as Array of String, +/
   /+ &efnames as Array of String, +/
   /+ &subject as String, +/
   /+ &emailText as String +/
   /+ Returns Boolean +/
   Local boolean &bRet;
   Local integer &res, &i;
   
   
   /* MD ext email */
   WriteToLog(%ApplicationLogFence_Level2, MsgGetText(48, 420, "Email Addresses: ") | &emailAddresses.Join(", "));
   
   rem &emailAddresses = &MyUtil.ValidateEmailDomain(&emailAddresses); /* MD Res 935615 */
   If &emailAddresses.Len = 0 Then
      WriteToLog(%ApplicationLogFence_Error, MsgGet(263, 86, " Email Address is required "));
      Return &bRet;
   End-If;
   
   
   Local PT_MCF_MAIL:MCFOutboundEmail &email = create PT_MCF_MAIL:MCFOutboundEmail();
   
   &bRet = False;
   
   If &emailAddresses <> Null Then
      If &emailAddresses.Len = 0 Then /* MD ext email */
         WriteToLog(%ApplicationLogFence_Error, MsgGet(263, 86, " Email Address is required "));
         Return &bRet;
      End-If;
      
      For &i = 1 To &emailAddresses.Len
         WriteToLog(%ApplicationLogFence_Level2, "Email Address:" | &emailAddresses [&i]);
         If (&i = 1) Then
            &email.Recipients = &emailAddresses [1];
         Else
            &email.Recipients = &email.Recipients | "," | &emailAddresses [&i];
         End-If;
      End-For;
      
      If (&subject <> "") Then
         &email.Subject = &subject;
      End-If;
      If (&emailText <> "") Then
         &email.Text = &emailText;
      End-If;
      
      For &i = 1 To &AttachFiles.Len
         &email.AddAttachment(&AttachFiles [&i], %FilePath_Absolute, &efnames [&i], "BIP Attachment", "", "");
      End-For;
      
      Local string &err_string; /* MD ext email */
      try
         &res = &email.Send();
      catch Exception &exp1
         &err_string = "Exception in sending Email." | Char(10);
      end-try;
      
      /* MD ext email -start */
      Evaluate &res
      When %ObEmail_Delivered /* 1 */
         &bRet = True;
         WriteToLog(%ApplicationLogFence_Level1, MsgGetText(236, 3021, "Email sent to %1", &email.Recipients));
      When %ObEmail_FailedBeforeSending /* 0 */
         &err_string = "Email failed before sending." | Char(10);
         If &email.ErrorDescription <> "" Then
            &err_string = &err_string | "Email Error: " | &email.ErrorDescription | Char(10);
         End-If;
         If &email.ErrorDetails <> "" Then
            &err_string = &err_string | "Email Error Details: " | &email.ErrorDetails;
         End-If;
      When %ObEmail_NotDelivered /* 2 */
         &err_string = "Email was not delivered. ";
      When %ObEmail_PartiallyDelivered /* 3 */
         &bRet = True;
         &err_string = "Email was partially delivered. "
      When %ObEmail_NotDelivered /* 2 */
      When %ObEmail_PartiallyDelivered /* 3 */
         If &email.ValidUnsentAddresses <> "" Then
            &err_string = &err_string | "Email Valid Unsent Addresses: " | &email.ValidUnsentAddresses | Char(10);
         End-If;
         
         If &email.InvalidAddresses <> "" Then
            &err_string = &err_string | "Email Invalid Addresses: " | &email.InvalidAddresses;
         End-If;
      When %ObEmail_SentButResultUnknown /* -1 */
         &err_string = "Email was sent but whether it was successful or not is not known";
      End-Evaluate;
      
      If Not (&bRet) Then
         If &err_string = "" Then
            &err_string = MsgGet(235, 3264, "Failed to email BIP report: %1", %This.ID);
         End-If;
         
         If &res = %ObEmail_PartiallyDelivered Then
            WriteToLog(%ApplicationLogFence_Level1, &err_string);
         Else
            throw CreateException(235, 3264, "Failed to email BIP report: %1", %This.ID);
         End-If;
      End-If;
      /* MD ext email - end */
   Else
      WriteToLog(%ApplicationLogFence_Error, "No Email IDs provided");
   End-If;
   Return (&bRet);
end-method;

/* CombineArrays : 
      Appends the elements of 2nd array that are not exist in the first array to the first array.
      If first array is null and 2nd array is not null, it clones the 2nd array into first array.
      If both arrays are null, nothing is done and the arrays remain null.
 * Input parameters:  Array of string,  Array of string.
 */
method CombineArrays
   /+ &Array1 as Array of String out, +/
   /+ &Array2 as Array of String +/
   Local number &cnt;
   
   If &Array1 <> Null Then
      If &Array2 <> Null Then
         For &cnt = 1 To &Array2.Len
            If &Array1.Find(&Array2 [&cnt]) = 0 Then
               &Array1.Push(&Array2 [&cnt]);
               
            End-If;
         End-For;
      End-If;
   Else
      If &Array2 <> Null Then
         &Array1 = CreateArrayRept("", 0);
         &Array1 = &Array2.Clone();
      End-If;
   End-If;
end-method;


method getDistPageEmailList
   /+ &processInstanceId as Number, +/
   /+ &subject as String out, +/
   /+ &emlText as String out +/
   /+ Returns Array of String +/
   Local integer &n;
   rem Local string &subject, &emlText;
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &distEmailInfo;
   Local array of string &distPageEmailList, &tempEmailList;
   
   &distPageEmailList = CreateArrayRept("", 0);
   &subject = "";
   &emlText = "";
   
   &distEmailInfo = %This.getDistEmailInfo(&processInstanceId);
   If &distEmailInfo <> Null Then
      For &n = 1 To &distEmailInfo.Len
         If &distEmailInfo [&n].Type = "2" Then
            &subject = &distEmailInfo [&n].ID;
         Else
            If &distEmailInfo [&n].Type = "3" Then
               &emlText = &distEmailInfo [&n].ID;
            Else
               If &distEmailInfo [&n].Type = "1" Or
                     &distEmailInfo [&n].Type = "4" Then
                  
                  /*ICE 1860349000 - split email addresses into different array elements*/
                  If &distPageEmailList.Len = 0 Then
                     &distPageEmailList = Split(&distEmailInfo [&n].ID, ";");
                  Else
                     &tempEmailList = Split(&distEmailInfo [&n].ID, ";");
                     %This.CombineArrays(&distPageEmailList, &tempEmailList);
                  End-If;
               End-If;
            End-If;
         End-If;
      End-For;
   End-If;
   Return &distPageEmailList;
end-method;

/*
   GetDistEmailInfo: (Helper function for getDistPageEmailList)
      Gets the email info from the Distribution screen (from the PSPRCSRQST table for the 
      given processInstance id) and populates the emailInfo array (Request text and Request type)
      and returns this array.
*/
method getDistEmailInfo
   /+ &processInstanceId as Number +/
   /+ Returns Array of PSXP_RPTDEFNMANAGER:ReportViewer +/
   Local SQL &mySQL;
   Local string &rqsttxt, &rqstTypStr;
   Local number &rqsttyp, &n;
   Local string &sqlStr;
   Local PSXP_RPTDEFNMANAGER:ReportViewer &rqstInfo;
   Local array of PSXP_RPTDEFNMANAGER:ReportViewer &emailInfo;
   
   &sqlStr = "select RQST_TEXT,RQSTTEXTTYPE from PSPRCSRQSTTEXT where PRCSINSTANCE = " | &processInstanceId;
   &mySQL = CreateSQL(&sqlStr);
   
   &n = 1;
   While &mySQL.Fetch(&rqsttxt, &rqsttyp);
      WriteToLog(%ApplicationLogFence_Level1, "Request Text:" | &rqsttxt);
      WriteToLog(%ApplicationLogFence_Level1, "Request ID:" | &rqsttyp);
      
      &rqstTypStr = NumberToString("%1", &rqsttyp, 1);
      
      &rqstInfo = create PSXP_RPTDEFNMANAGER:ReportViewer(&rqstTypStr, &rqsttxt);
      If &n = 1 Then
         &emailInfo = CreateArray(&rqstInfo);
      Else
         &emailInfo.Push(&rqstInfo);
      End-If;
      &n = &n + 1;
   End-While;
   
   Return &emailInfo;
end-method;

method SetQueryTrackingURL /* mdu XXX */
   Local number &loc;
   Local string &sDistNode_URI;
   Local string &url;
   If &Report.Ds_type <> "QRY" Then
      Return;
   End-If;
   
   If &ProcessInstance > 0 Then
      /*build a query tracking URL */
      SQLExec("select C.URI_RPT from PSPRCSRQST A, PS_SERVERDEFN B, PS_CDM_DIST_NODE C WHERE A.PRCSINSTANCE =:1 AND A.SERVERNAMERUN = B.SERVERNAME AND B.DISTNODENAME = C.DISTNODENAME", &ProcessInstance, &sDistNode_URI);
      &loc = Find("/c/", &sDistNode_URI);
      &url = Substring(&sDistNode_URI, 1, &loc - 1);
   Else
      SQLExec("select C.URI_RPT from PSPRCSRQST A, PS_SERVERDEFN B, PS_CDM_DIST_NODE C WHERE A.SERVERNAMERUN = B.SERVERNAME AND B.DISTNODENAME = C.DISTNODENAME", &sDistNode_URI);
      &loc = Find("/c/", &sDistNode_URI);
      &url = Substring(&sDistNode_URI, 1, &loc - 1);
   End-If;
   
   If &url <> "" Then
      &oQuery.AddTrackingURL(&url);
      WriteToLog(%ApplicationLogFence_Level1, "Query Tracking URL: " | &url);
   End-If;
end-method;


/*ICE 2038507000*/
/************************************************************************************************
* Private method RemoveCDATAfromFieldList
* Used to remove CDATA section from a list of fields
* Some fields, probably fieds that use Rich Text Editor for user input (array &aNoCDATAFields),
* require do not use CDATA section, so removing CDATA sections from output File
* Method also substitutes white space char. "&nbsp;" with XML entity "&#160;" 
* Parameter: String &sDataFile - file name created by Query or Connected Query
************************************************************************************************/

method RemoveCDATAfromFieldList
   /+ &sDataFile as String +/
   
   Local File &MYFILE;
   Local string &tag, &tagEnd, &myTxt;
   Local string &tagCDATA = "<![CDATA[";
   Local string &tagEndCDATA = "]]>";
   Local integer &i;
   
   If Not %This.TemplateType = "RTF" Then
      Return;
   End-If;
   
   If Not FileExists(&sDataFile, %FilePath_Absolute) Then
      throw CreateException(235, 2305, "Failed to generate or read data source XML file");
   End-If;
   &MYFILE = GetFile(&sDataFile, "E", "UTF-8", %FilePath_Absolute);
   If &MYFILE.IsOpen Then
      &myTxt = &MYFILE.GetString( True);
      &MYFILE.Close();
   End-If;
   
   &myTxt = Substitute(&myTxt, "&nbsp;", "&#160;");
   If &aNoCDATAFields <> Null Then
      For &i = 1 To &aNoCDATAFields.Len
         &tag = "<" | &aNoCDATAFields [&i] | ">";
         &tagEnd = "</" | &aNoCDATAFields [&i] | ">";
         If All(&myTxt) Then
            &myTxt = Substitute(&myTxt, &tag | &tagCDATA, &tag);
            &myTxt = Substitute(&myTxt, &tagEndCDATA | &tagEnd, &tagEnd);
         End-If;
      End-For;
   End-If;
   
   &MYFILE = GetFile(&sDataFile, "W", "UTF-8", %FilePath_Absolute);
   If &MYFILE.IsOpen Then
      &MYFILE.WriteString(&myTxt);
      &MYFILE.Close();
   End-If;
   
end-method; /* RemoveCDATAfromFieldList */

/* MD RET4 */
/***************************************************************************************************
* Private method SyncArchiveValueFields
* Used to copy an old 3-digit number field Psxp_archive_value to the new one (Psxp_archivevalue4)-
* 4 digit number and sync their values
****************************************************************************************************/
method SyncArchiveValueFields
   If &Report.Psxp_archivevalue4 = 0 And
         ( Not &IsNoArchiveValue) Then
      If &Report.Psxp_archive_value > 0 Then
         &Report.Psxp_archivevalue4 = &Report.Psxp_archive_value;
         &DefnChanged = True;
      End-If;
   End-If;
   
   If &Report.Psxp_archivevalue4 <> &Report.Psxp_archive_value Then
      If &Report.Psxp_archivevalue4 > 999 Then
         &Report.Psxp_archive_value = 999;
      Else
         &Report.Psxp_archive_value = &Report.Psxp_archivevalue4;
      End-If;
      &DefnChanged = True;
      
   End-If;
   Return;
end-method; /* SyncArchiveValueFields */

/* MD res.888676  */
/****************************************************************************************************
* Private method SetBurstParsingOptions
* Method checks if ReportDefnManager needs to create a BurstFileInfo Object
* If YES an instance variable &IsBurstFileParsinqRequired is populated 
****************************************************************************************************/
method SetBurstParsingOptions
   /+ &oBurstFileInfo as PSXP_RPTDEFNMANAGER:BurstFileInfo +/
   Local number &cnt;
   Local string &fldName;
   
   If &FieldsToParse = Null Then
      &FieldsToParse = CreateArrayRept("", 0);
   Else
      If &IsBurstFileParsinqRequired <> - 1 Then
         &oBurstFileInfo.LimitedFieldsArr = &FieldsToParse;
         Return;
      End-If;
   End-If;
   
   &fldName = LTrim(RTrim(&Report.Burst_fieldname));
   
   If %This.UseBurstValueAsOutputFileName And
         &fldName <> "" Then
      &FieldsToParse.Push(&fldName);
   Else
      /* If field name contains burst value - BTV (set by Report Definition) */
      Local string &fName = LTrim(RTrim(&Report.Userfilename));
      If &fName <> "" Then
         If Find("BTV", &fName, 1) > 0 And
               &fldName <> "" Then
            &FieldsToParse.Push(&fldName);
         End-If;
      End-If;
   End-If;
   
   
   /* If Template switching is set */
   &fldName = LTrim(RTrim(&Report.Tmplctrl_fieldname));
   If &fldName <> "" Then
      If &FieldsToParse.Find(&fldName) = 0 Then
         &FieldsToParse.Push(&fldName);
      End-If;
   End-If;
   
   /* If Bursted Security is set */
   If %This.SecurityJoinTable <> "" Then
      Local array of PSXP_RPTDEFNMANAGER:ScopeField &arrayScopeFlds;
      &arrayScopeFlds = %This.GetScopeFields();
      If (&arrayScopeFlds <> Null) Then
         For &cnt = 1 To &arrayScopeFlds.Len
            &fldName = LTrim(RTrim(&arrayScopeFlds [&cnt].DataSourceField));
            If &FieldsToParse.Find(&fldName) = 0 Then
               &FieldsToParse.Push(&fldName);
            End-If;
         End-For;
      End-If;
   End-If;
   
   /* If Report Search keys are set */
   Local array of string &aSearchKeys;
   &aSearchKeys = %This.GetSearchFields();
   If &aSearchKeys <> Null Then
      For &cnt = 1 To &aSearchKeys.Len
         &fldName = LTrim(RTrim(&aSearchKeys [&cnt]));
         If &FieldsToParse.Find(&fldName) = 0 Then
            &FieldsToParse.Push(&fldName);
         End-If;
      End-For;
   End-If;
   
   
   /* If Report File Name set in the Report Definition and Field names are used for Bursted report*/
   If &Report.Burst_fieldname <> "" And
         &Report.Userfilename <> "" Then
      Local string &tempfilename;
      &tempfilename = LTrim(RTrim(&Report.Userfilename));
      /* first, remove all file name variables from the string */
      &tempfilename = Substitute(&tempfilename, "%BTV%", "");
      &tempfilename = Substitute(&tempfilename, "%RID%", "");
      &tempfilename = Substitute(&tempfilename, "%LAN%", "");
      &tempfilename = Substitute(&tempfilename, "%ASD%", "");
      
      /* second, everything that left is either constant text or field names. 
         Get field names by looking for '%' start and end tags */
      Local number &start = Find("%", &tempfilename);
      Local number &end;
      While &start > 0
         &end = Find("%", &tempfilename, &start + 1);
         If &end = 0 Then
            Break;
         End-If;
         
         /* get the field name without '%' char*/
         &fldName = Substring(&tempfilename, &start + 1, &end - &start - 1);
         &FieldsToParse.Push(&fldName);
         &start = Find("%", &tempfilename, &end + 1);
      End-While;
   End-If;
   
   
   /* MD Signature */
   If &aSignatureFields <> Null Then
      For &cnt = 1 To &aSignatureFields.Len
         &fldName = LTrim(RTrim(&aSignatureFields [&cnt]));
         If &FieldsToParse.Find(&fldName) = 0 Then
            &FieldsToParse.Push(&fldName);
         End-If;
      End-For;
   End-If;
   
   
   If &FieldsToParse.Len > 0 Then
      &IsBurstFileParsinqRequired = 1;
      &oBurstFileInfo.LimitedFieldsArr = &FieldsToParse;
   Else
      &IsBurstFileParsinqRequired = 0; /* MD res 889197 */
   End-If;
   Return;
end-method; /* SetBurstParsingOptions */



/* MD Signature */
/****************************************************************************************************
* Private method ParseDataValues
* Method is parsing data file if needed and if Didital Signature is required
* it sets a &aSignatureValues array using BurstFileInfo Object  
****************************************************************************************************/
method ParseDataValues
   /+ &oBurstFileInfo as PSXP_RPTDEFNMANAGER:BurstFileInfo, +/
   /+ &oDigSign as PSXP_RPTDEFNMANAGER:DigitalSignature, +/
   /+ &isBursted as Boolean +/
   Local number &ii;
   Local string &fldName;
   
   If &oBurstFileInfo = Null Then
      WriteToLog(%ApplicationLogFence_Level1, "SetSignatureDataFieldsValues: &oBurstFileInfo object is Null ");
      Return;
   End-If;
   
   /************ if no needs PDF signature ************/
   If Not &IsPDFSignatureRequired Then
      %This.SetBurstParsingOptions(&oBurstFileInfo);
      If &IsBurstFileParsinqRequired = 1 Then
         &oBurstFileInfo.ParseData();
      End-If;
      Return;
   End-If;
   
   /*********** if PDF signature required ************/
   If &aSignatureFields = Null Then
      Return;
   End-If;
   
   If &oDigSign = Null Then
      Return;
   End-If;
   
   If Not &isBursted Then
      /***************** PDF signature for Not bursted report ************/
      %This.SetBurstParsingOptions(&oBurstFileInfo);
      If &IsBurstFileParsinqRequired = 1 Then
         &oBurstFileInfo.ParseData();
      End-If;
      
      If &aSignatureFields.Len = 0 Then
         Return;
      End-If;
      &aSignatureValues = CreateArrayRept("", 0);
      
      For &ii = 1 To &aSignatureFields.Len
         &fldName = LTrim(RTrim(&aSignatureFields [&ii]));
         &oBurstFileInfo.LimitedFieldsArr.Push(Upper(&fldName));
         &aSignatureValues.Push(&oBurstFileInfo.getFieldValues(Upper(&fldName)));
      End-For;
      
      If &aSignatureValues <> Null Then
         If &aSignatureValues.Len > 0 Then
            &oDigSign.SignatureFields = &aSignatureFields;
            &oDigSign.SignatureValues = &aSignatureValues;
         End-If;
      End-If;
      
   Else
      /***** bursted report with Signature required but signature does not depend on data *****/
      If &ReusePDFSignatureForBursInst Then
         %This.SetBurstParsingOptions(&oBurstFileInfo);
         If &IsBurstFileParsinqRequired = 1 Then
            &oBurstFileInfo.ParseData();
            Return;
         End-If;
      Else
         /***** bursted report with Signature required and signature depends on data *****/
         
         rem res 910302  ;
         %This.SetBurstParsingOptions(&oBurstFileInfo);
         If &IsBurstFileParsinqRequired = 1 Then
            &oBurstFileInfo.ParseData();
         End-If;
         
         If &aSignatureFields.Len = 0 Then
            Return;
         End-If;
         &aSignatureValues = CreateArrayRept("", 0);
         
         For &ii = 1 To &aSignatureFields.Len
            &fldName = LTrim(RTrim(&aSignatureFields [&ii]));
            &oBurstFileInfo.LimitedFieldsArr.Push(Upper(&fldName));
            &aSignatureValues.Push(&oBurstFileInfo.getFieldValues(Upper(&fldName)));
         End-For;
         
         If &aSignatureValues.Len > 0 Then
            &oDigSign.SignatureFields = &aSignatureFields;
            &oDigSign.SignatureValues = &aSignatureValues;
         End-If;
         
      End-If;
      Return;
   End-If;
end-method; /* ParseDataValues */

/* MD Signature */
/***********************************************************************************************************
* Private method cleanupProcessing
* Clean up processing files and directories
* Could be called after report processing is done  or as result of errors (Signing PDF report)
* If deleting on errors - set boolean parameter to true
* Does not delete anything but a report file if Debug property is set
* If PDF Report is secured with a password and report uses PDF digital signature all data will be deleted 
* even in the debug mode
***********************************************************************************************************/
method cleanupProcessing
   /+ &bDeleteRoot as Boolean +/
   
   Local string &str;
   try
      If %This.Debug Then
         If Not &bReportWasSecured Then
            Return;
         End-If;
      End-If;
      
      /* deleting on errors */
      If &bDeleteRoot Then
         &str = %This.sSrvOutDir;
         If FileExists(&str, %FilePath_Absolute) Then
            RemoveDirectory(&str, %FilePath_Absolute + %Remove_Subtree);
            If &ConQryInst <> Null Then
               &ConQryInst.CleanOutputFile();
               &str = &ConQryInst.GetOutDestinationDir();
               RemoveDirectory(&str, %FilePath_Absolute + %Remove_Subtree);
            End-If;
         End-If;
      End-If;
      
      /* regular cleaning up */
      &str = %This.sSrvTmpDir | &sDirSep | "Data";
      If FileExists(&str, %FilePath_Absolute) Then
         RemoveDirectory(&str, %FilePath_Absolute + %Remove_Subtree);
      End-If;
      
      /* 2037749000 - cleanup temp processing dir*/
      &str = %This.sSrvProcDir;
      
      If FileExists(&str, %FilePath_Absolute) Then
         RemoveDirectory(&str, %FilePath_Absolute + %Remove_Subtree);
      End-If;
      
      /* cleanup Connected Query processing */
      If &ConQryInst <> Null Then
         &ConQryInst.CleanOutputFile();
         RemoveDirectory(&ConQryInst.GetOutDestinationDir(), %FilePath_Absolute + %Remove_Subtree);
      End-If;
      
      If %This.OutDestination <> "" Then
         &str = %This.sSrvTmpDir;
         If FileExists(&str, %FilePath_Absolute) Then
            RemoveDirectory(&str, %FilePath_Absolute + %Remove_Subtree);
         End-If;
      End-If;
      Return;
      
   catch Exception &Exp2
      WriteToLog(%ApplicationLogFence_Error, "Could not delete Directory:" | &str);
   end-try;
end-method;

/* MD ext email */
/***************************************************************************************************************
* Private method getExtEmailAddressArray
* Retrieves an array of email addresses from user defined Application class
****************************************************************************************************************/
method getExtEmailAddressArray
   /+ Returns Boolean +/
   Local string &sErrorStr;
   Local object &objAppClass;
   Local number &i;
   
   If Not &bIsExtEmail Then
      Return False;
   End-If;
   
   For &i = 1 To 1
      try
         /* App delivered App class initialization. Calling Apps delivered class to get recipients email addresses. */
         &objAppClass = CreateObject(&extEmailAppclass);
         WriteToLog(%ApplicationLogFence_Level2, "&Report.&objAppClass: " | &objAppClass);
         
         If &objAppClass = Null Then
            &sErrorStr = MsgGetText(235, 3352, "Cannot create an instance of %1", &extEmailAppclass);
            Break;
         End-If;
         
         &objAppClass.ReportName = %This.ID;
         
         WriteToLog(%ApplicationLogFence_Level2, "&Report.Burst_fieldname: " | &Report.Burst_fieldname);
         WriteToLog(%ApplicationLogFence_Level2, "&Report.BurstFieldValue: " | &sBurstFieldValue);
         
         
         If &Report.Burst_fieldname <> "" And
               &sBurstFieldValue <> "" Then
            &objAppClass.BurstFieldName = &Report.Burst_fieldname;
            &objAppClass.BurstFieldValue = &sBurstFieldValue;
         End-If;
         
         &aExtUserEmailAddresses = &objAppClass.getEmailAddressArray();
         &sErrorStr = &objAppClass.getErrorString();
         
      catch Exception &Exc
         WriteToLog(%ApplicationLogFence_Error, "Exception in getExtEmailAddressArray(): " | &sErrorStr);
         Return False;
      end-try;
   End-For;
   
   If All(&sErrorStr) Then
      WriteToLog(%ApplicationLogFence_Error, &sErrorStr);
      Return False;
   End-If;
   
   Return True;
end-method;


/* OIT 901R1*/
/****************************************************************************************************
* Private method setPDFConversionData
* Sets Java properties and generates input array for PDF conversion Java program
* Input: String, output: Array of Strings
*
* NOTE: 
* There are 3 placeholder variables that could be used for PDF conversion implementations
* %BTV% - to be replaced with a burst value. It could be used only for bursted report.
* If %BTV% is used for not bursted report the array member is ignored.
* Example (Win) - C:\Temp\<UUID>\%BTV% will be replaced with C:\Temp\<UUID>\<BurstValue>
*
*
* %ALLFILES% - to be replaced with *.*  NOTE: it will process only files in the directory. 
* If the directory has child directory entries they will be ignored. Converted files  appear 
* in alphabetical order. This placeholder could be used either for butsted or non bursted reports.
* Example (Win) -  C:\Temp\<UUID>\%ALLFILES% resolved to C:\Temp\<UUID>\*.*
*
* %REPORTFILE% - to be replaces with a fully qualified report name. %REPORTFILE% could be added as 
* the first array member or the last array member.
* If this placeholder is added by user in the middle of the &arrPDFConversion  array it will be positioned at the beginning of the array.
* If this placeholder is missing  from the array it will be added as the first array member during the processing.
*
* For bursted and not-bursted reports user should provide an array, where each array member specifies 
* an absolute path to the single file or an absolute path to the directory that contains files to be 
* converted. 
* In the last case an array member should use the placeholder variables 
* (%BTV% - for bursted reports only and   %ALLFILES% -see above).
* All specified files will be converted and merged to the each report instance in the same order 
* as they appear in the array.  
****************************************************************************************************/
method setPDFConversionData
   /+ &sOutputFile as String +/
   
   /* sets file input array for PDF conversion */
   Local array of string &inputFiles;
   Local array of string &arrFromDir;
   Local array of string &rawArr;
   Local number &i, &iter;
   Local string &temp;
   
   &rawArr = CreateArrayRept("", 0);
   
   If &arrPDFConversion.Len = 0 Then
      WriteToLog(%ApplicationLogFence_Error, "setPDFConversionData: PDF Conversion array is empty.");
      Return; /* OIT Merge */
   End-If;
   
   /* Set java properties for calling pspdfexport */
   Local string &PSTOOLSBINSVR;
   Local string &exeFile;
   Local array of string &resArr;
   
   If &sDirSep = "\" Then
      &PSTOOLSBINSVR = GetEnv("PS_HOME") | &sDirSep | "bin" | &sDirSep | "server" | &sDirSep | "winx86" | &sDirSep;
      &exeFile = &PSTOOLSBINSVR | "pspdfexport.exe";
   Else
      &PSTOOLSBINSVR = GetEnv("PS_HOME") | &sDirSep | "bin" | &sDirSep;
      &exeFile = &PSTOOLSBINSVR | "pspdfexport";
   End-If;
   
   Local PSXP_ENGINE:XMLPUtil &oXMLPUtil = create PSXP_ENGINE:XMLPUtil();
   Local string &sOutputDir = GetDirectoryFromPath(&sOutputFile);
   &sOutputDir = Substitute(&sOutputDir, "//", "/"); /* MD res 937260 */
   
   &oXMLPUtil.setGlobalProperty("rptoutputdir", &sOutputDir);
   
   &oXMLPUtil.setGlobalProperty("pspdfexport_exe", &exeFile);
   
   /* MD res 937260  
     FOR PEOPLETOOLS DEVELOPMENT TROUBLSHOOTING ONLY !!!  
     For C++ debugging purposes set the property  "delayfordebugger" to use as a number of iteration inside the 
      array with a sleep() function. Setting value = 60 means 60sec delay. This delay is needed for attaching C++ debugger
      to the ptpdfexport.exe process after it has been invoked. Dafault value = 0 - that means no delay. 
      You need to uncomment code in C++ pspdfexport.cpp at the beginning of the function main(...). Recompile the pspdfexport.cpp
      and you will be able to turn on/off the execution delay.
   */
   Local number &nDebugDelay = 300;
   &oXMLPUtil.setGlobalProperty("delayfordebugger", String(&nDebugDelay));
   /* end FOR PEOPLETOOLS DEVELOPMENT */
   
   
   /* MD  We need to set either runtime timeout or global timeout property (in sec) for OIT */
   Local string &sPDFExportTimeOut;
   
   If &pdfConversionTimeOut <> 0 Then
      &sPDFExportTimeOut = String(&pdfConversionTimeOut); /* should be read from the global properties */
   End-If;
   
   &oXMLPUtil.setGlobalProperty("pspdfexport_timeout", &sPDFExportTimeOut);
   
   If &Report.Burst_fieldname <> "" And
         &sBurstFieldValue = "" Then
      WriteToLog(%ApplicationLogFence_Error, "setPDFConversionData: &sBurstFieldValue is not set");
      Return; /* OIT Merge */
   End-If;
   
   /* Find a placeholder for a report file */
   Local number &rptInd = &arrPDFConversion.Find("%REPORTFILE%");
   If &rptInd = 0 Then
      /* if %REPORTFILE% is not specified make report the first item in the array */
      &rawArr.Push(&sOutputFile);
   Else /* OIT Merge */
      If &rptInd < &arrPDFConversion.Len Then
         /* if %REPORTFILE% is specified in the middle of the array, position it on the top */
         &rawArr.Push(&sOutputFile);
      End-If;
   End-If;
   
   For &iter = 1 To &arrPDFConversion.Len
      Evaluate &arrPDFConversion [&iter]
      When "%REPORTFILE%"
         If &iter = &arrPDFConversion.Len Then /* OIT Merge */
            &rawArr.Push(&sOutputFile);
         End-If;
      When-Other
         If &Report.Burst_fieldname <> "" Then
            If Find(&sDirSep | "%BTV%", &arrPDFConversion [&iter]) > 0 Then /* replace with &sBurstFieldValue */
               &temp = Substitute(&arrPDFConversion [&iter], "%BTV%", &sBurstFieldValue);
               
               <* MD OIT PDF We need to exclude .pdf files from the attachments array.
                  This is a reason we are expanding %ALLFILES% to proper handling in the Java layer *>
               If Find(&sDirSep | "%ALLFILES%", &temp) > 0 Then
                  &temp = Substitute(&temp, "%ALLFILES%", "*.*");
                  &arrFromDir = FindFiles(&temp, %FilePath_Absolute);
                  For &i = 1 To &arrFromDir.Len
                     &rawArr.Push(&arrFromDir [&i]);
                  End-For;
                  
               Else /* %BTV% is specified without  %ALLFILES%, so still looking for all files in the %BTV% directory */
                  &temp = &temp | &sDirSep | "*.*";
                  &arrFromDir = FindFiles(&temp, %FilePath_Absolute);
                  For &i = 1 To &arrFromDir.Len
                     &rawArr.Push(&arrFromDir [&i]);
                  End-For;
               End-If;
               
            Else
               <* MD OIT PDF - expanding %ALLFILES%  *>
               /* no %BTV% but there is %ALLFILES%, so adding all files from the passed directory to the each bursted instance */
               
               If Find(&sDirSep | "%ALLFILES%", &arrPDFConversion [&iter]) > 0 Then
                  &temp = Substitute(&arrPDFConversion [&iter], "%ALLFILES%", "*.*");
                  
                  &arrFromDir = FindFiles(&temp, %FilePath_Absolute);
                  For &i = 1 To &arrFromDir.Len
                     &rawArr.Push(&arrFromDir [&i]);
                  End-For;
               Else /* no substitution variables were found so adding passed file to the each bursted instance */
                  &rawArr.Push(&arrPDFConversion [&iter]);
               End-If;
               
            End-If; /* %BTV% */
            
         Else /* not bursted report */
            <* MD OIT PDF - expanding %ALLFILES%  *>
            If Find(&sDirSep | "%ALLFILES%", &arrPDFConversion [&iter]) > 0 Then
               &temp = Substitute(&arrPDFConversion [&iter], "%ALLFILES%", "*.*");
               &arrFromDir = FindFiles(&temp, %FilePath_Absolute);
               For &i = 1 To &arrFromDir.Len
                  &rawArr.Push(&arrFromDir [&i]);
               End-For;
            Else
               &rawArr.Push(&arrPDFConversion [&iter]);
            End-If;
            
         End-If; /* bursted or not bursted report */
         
      End-Evaluate;
      
   End-For;
   
   If &rawArr.Len > 0 Then
      &files2Convert = %This.cleanupConversionArray(&rawArr); /* MD OIT PDF */
      rem  &files2Convert = &rawArr; /*MD OIT PDF */
      
      /* Array &files2Convert should include the report file itself as well as files for PDF convertion. 
         If array length is = 1 there is no files to convert, so in this case we set &files2Convert to NULL */
      If &files2Convert <> Null Then
         If &files2Convert.Len < 2 Then
            &files2Convert = Null;
         End-If;
      End-If;
   Else
      WriteToLog(%ApplicationLogFence_Error, "setPDFConversionData: failed to set &inputFiles array from the following values: ");
      For &i = 1 To &rawArr.Len
         WriteToLog(%ApplicationLogFence_Error, &rawArr [&i] | ";");
      End-For;
      &files2Convert = Null;
   End-If;
   
   /* MD res 937260 */
   If %This.Debug Then
      For &i = 1 To &files2Convert.Len
         WriteToLog(%ApplicationLogFence_Error, "Passed to Java for conversion: " | &files2Convert [&i] | ";");
      End-For;
   End-If;
   
   
end-method; /* setPDFConversionData */


/* OIT 901R1 */
/**********************************************************************************************
* Private function cleanupConversionArray
* It is a help function for setPDFConversionData
* It returns file array without directory names returned by FindFile function
************************************************************************************************/

method cleanupConversionArray
   /+ &filesArr as Array of String +/
   /+ Returns Array of String +/
   Local number &i;
   Local array of string &retFiles = CreateArrayRept("", 0);
   Local number &len = &filesArr.Len;
   Local JavaObject &fl;
   
   If &len = 0 Then
      Return &retFiles;
   End-If;
   
   For &i = 1 To &len
      &fl = CreateJavaObject("java.io.File", &filesArr [&i]);
      If &fl.isDirectory() Then /* We expect having only files in the substituted directory */
         Continue;
      End-If;
      If Substring(&filesArr [&i], Len(&filesArr [&i]), 1) = "." Then
         Continue;
      End-If;
      
      /* For Windows - ignore system generated files like Thumbs.db */ /* MD **/
      If &sDirSep = "\" Then
         Local string &tst = Lower(&filesArr [&i]);
         If Find(".db", &tst, Len(&tst) - 4) > 0 Then
            Continue;
         End-If;
      End-If;
      
      &retFiles.Push(&filesArr [&i]);
   End-For;
   
   Return &retFiles;
   
end-method;


/* OIT Merge */
/**********************************************************************************************
* Private function mergePDFReportWithAttachments
* It is merging generated PDF Report with exported to PDF attachments
* It returns boolean TRUE/FALSE
************************************************************************************************/

method mergePDFReportWithAttachments
   /+ &sOutputFile as String +/
   /+ Returns Boolean +/
   
   Local string &sTemp, &sPDFAttachments, &sErr;;
   Local array of string &asNames;
   
   try
      Local PSXP_ENGINE:PDFMerger &oMerger = create PSXP_ENGINE:PDFMerger();
      
      If &IsPDFExportSecurityDisabled Then
         &oMerger.ConfProp = create PSXP_ENGINE:Properties(); /* OIT Merge */
         Local boolean &res = &oMerger.ConfProp.setProperty("pdf-security", "True");
         rem &IsPDFExportSecurityDisabled = False; /* MD OIT PDF */
      End-If;
      
      If None(&sOutputFile) Then
         Return False;
      End-If;
      If %This.files2Convert.Len = 0 Then
         Return True;
      End-If;
      
      /* Set page Numbering for merged file */
      Local PSXP_ENGINE:PageNumber &oPageNumber = create PSXP_ENGINE:PageNumber();
      If &pageNumberPosX > 0 And
            &pageNumberPosY > 0 Then
         &oPageNumber.FontName = "Helvetica"; /* hardcoded default */
         &oPageNumber.FontSize = 10; /* hardcoded default */
         &oPageNumber.PositionX = &pageNumberPosX;
         &oPageNumber.PositionY = &pageNumberPosY;
         &oMerger.PageNumber = &oPageNumber;
      End-If;
      
      /* parsing the string to to get the name of attachments already merged together in C++ */
      rem &sPDFAttachments = Substitute(&sOutputFile, ".pdf", "_1.pdf"); /* MD OIT PDF */
      
      
      Local number &rptInd = %This.files2Convert.Find(&sOutputFile);
      If &rptInd = 0 Then
         WriteToLog(%ApplicationLogFence_Error, "Error: report file is not found in the files2Convert array");
         Return False;
      End-If;
      
      /*  MD OIT PDF */
      /* all output files are in the output directory - %This.sSrvOutDir. We need to assemble them in the correct order */
      
      /* temporary renaming the report file to exclude it from the array of merged files */
      Local JavaObject &joUtil = CreateJavaObject("com.peoplesoft.pt.xmlpublisher.XMLPUtil");
      Local string &rptFile = Substitute(&sOutputFile, ".pdf", ".out");
      Local array of string &arrRpt = FindFiles(&sOutputFile, %FilePath_Absolute);
      If &arrRpt <> Null And
            &arrRpt.Len = 1 Then
         If Not &joUtil.renameFile(&sOutputFile, &rptFile) Then
            WriteToLog(%ApplicationLogFence_Error, "Cannot temporary rename a file from " | &sOutputFile | " to " | &rptFile);
            Return False;
         End-If;
      End-If;
      
      Local string &sOutputDir = GetDirectoryFromPath(&sOutputFile);
      &sOutputDir = Substitute(&sOutputDir, "//", "/"); /* MD res 937260 */
      
      &asNames = FindFiles(&sOutputDir | &sDirSep | "*.pdf", %FilePath_Absolute);
      If &asNames = Null Then
         WriteToLog(%ApplicationLogFence_Error, "Cannot find converted files in the " | &sOutputDir | " directory.");
      End-If;
      
      If Not &joUtil.renameFile(&rptFile, &sOutputFile) Then
         WriteToLog(%ApplicationLogFence_Error, "Cannot rename a file back from " | &rptFile | " to " | &sOutputFile);
         Return False;
      End-If;
      
      If &rptInd = 1 Then
         &asNames.Unshift(&sOutputFile);
      Else
         &asNames.Push(&sOutputFile);
      End-If;
      
      /* MD OIT PDF */
      /* Arranging files to the user provided order */
      Local number &i, &ind;
      Local string &srcFilename, &trgFilename;
      Local array of string &srcFilenameArr, &trgFilenameArr, &sortedResultArr;
      &sortedResultArr = CreateArrayRept("", 0);
      &srcFilenameArr = %This.getfilenamesArr(&files2Convert);
      &trgFilenameArr = %This.getfilenamesArr(&asNames);
      
      For &i = 1 To &srcFilenameArr.Len
         &ind = &trgFilenameArr.Find(&srcFilenameArr [&i]);
         If &ind > 0 Then
            /* MD res 937260 */
            Local JavaObject &fl = CreateJavaObject("java.io.File", &asNames [&ind]);
            If &fl.isDirectory() Then
               Continue;
            Else
               If &fl.length() > 0 Then
                  &sortedResultArr.Push(&asNames [&ind]);
                  If %This.Debug Then
                     WriteToLog(%ApplicationLogFence_Error, "Passed to the PDFMerger: " | &asNames [&ind]);
                  End-If;
               Else
                  WriteToLog(%ApplicationLogFence_Error, "File " | &asNames [&ind] | " has a 0 length. Cannot merge.");
               End-If;
            End-If;
         End-If;
         
      End-For;
      
      /* Merge PDFs */
      Local string &mergedPDFPath = Substitute(&sOutputFile, ".pdf", "_out.pdf");
      Local boolean &bResult = &oMerger.mergePDFs(&sortedResultArr, &mergedPDFPath, &sErr);
      
      If Not &bResult Then
         WriteToLog(%ApplicationLogFence_Error, "Error while merging files: " | &sErr);
         
         /* MD **/
         /* Returning True to deliver the report file without attachments as attachments could be corrupt or 
         there could be some other reason for merging failure - security issues, etc. Do not cleaning up 
         files for further analysis */
         rem Return False;
         Return True;
      End-If;
      
      /* MD OIT PDF  */
      /* removing original (copied) PDF files */
      For &i = 1 To &sortedResultArr.Len
         Local File &oFile = GetTempFile(&sortedResultArr [&i], "W", "UTF8", %FilePath_Absolute);
         &oFile.Delete(); /* MD res 937260 */
         If %This.Debug Then
            WriteToLog(%ApplicationLogFence_Error, "Deleting PDF file:" | &sortedResultArr [&i]);
         End-If;
      End-For;
      
      /* renaming already merged file */
      If Not &joUtil.renameFile(&mergedPDFPath, &sOutputFile) Then
         WriteToLog(%ApplicationLogFence_Error, "Cannot rename a file from " | &mergedPDFPath | " to " | &sOutputFile);
         Return False;
      End-If;
      
      Return True;
      
   catch Exception &Err
      WriteToLog(%ApplicationLogFence_Error, &Err.ToString());
      Return False;
   end-try;
   
end-method;

/*********************************************************************************
* Public method setPDFConversionPageNumbering
* It allows report developer set page numbering for PDF report with 
* attachments.
* It should be done at run-time by calling the methos like the sample below:
* &RptObj.setPDFConversionPageNumberLocation(300,15).
* If method was not called at run-time no page numbering happen
*********************************************************************************/
method setPDFConversionPageNumbering
   /+ &x as Number, +/
   /+ &y as Number +/
   &pageNumberPosX = &x;
   &pageNumberPosY = &y;
   Return;
end-method;

/* MD OIT PDF */
method getfilenamesArr
   /+ &fulpathArr as Array of String +/
   /+ Returns Array of String +/
   Local array of string &arr = CreateArrayRept("", 0);
   Local array of string &tempArr = CreateArrayRept("", 0);
   Local number &i, &ind;;
   Local number &len = &fulpathArr.Len;
   Local string &fileName;
   If &len = 0 Then
      WriteToLog(%ApplicationLogFence_Error, "Error: array provided for getfilenamesArr method is empty ");
      Return Null;
   End-If;
   For &i = 1 To &len
      &fileName = GetFileNameFromPath(&fulpathArr [&i]);
      Local number &lastdot;
      If &fileName <> "" Then
         &tempArr = Split(&fileName, ".");
         If &tempArr.Len > 0 Then
            &ind = Len(&fileName) - Len(&tempArr [&tempArr.Len]);
         Else
            &ind = Find(".", &fileName, 1);
         End-If;
      End-If;
      
      &fileName = Substring(&fileName, 1, &ind - 1);
      &arr.Push(&fileName);
   End-For;
   Return &arr;
end-method;

