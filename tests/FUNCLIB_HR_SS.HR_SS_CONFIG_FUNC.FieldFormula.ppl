import HR_MO_COMMON:SETUP:APP_SETUP;

Declare Function DeleteExceptions PeopleCode FUNCLIB_WF.WF_CI_FUNCTIONS FieldFormula;
Declare Function InsertExceptions PeopleCode FUNCLIB_WF.WF_CI_FUNCTIONS FieldFormula;
Declare Function ApproverNotFound PeopleCode FUNCLIB_WF.WF_RUN_SAVE_OPTION FieldFormula;
Declare Function InRoleUser PeopleCode FUNCLIB_CO.REPORTS_TO FieldFormula;
Declare Function DisplayErrorConfirm PeopleCode FUNCLIB_HR.HR_SS_FUNCTIONS FieldFormula;
Declare Function DisplaySubmitConfirm PeopleCode FUNCLIB_HR.HR_SS_FUNCTIONS FieldFormula;
Declare Function DisplaySaveConfirm PeopleCode FUNCLIB_HR.HR_SS_FUNCTIONS FieldFormula;
Declare Function TransSpecificProcess PeopleCode SS_SPECIFIC_PRC.SS_SPECIFIC_PRC FieldFormula;
Declare Function GetApprovers PeopleCode APPR_VA0_WRK.APPR_RULE_SET FieldFormula;
Declare Function get_person_name PeopleCode FUNCLIB_NAME.PERSON_NAME FieldFormula;
Declare Function GetWFProfile PeopleCode FUNCLIB_ETEO.WF_FUNCTIONS FieldFormula;
Declare Function EmailOriginator PeopleCode FUNCLIB_ETEO.WF_FUNCTIONS FieldFormula;
Declare Function CreateSSExceptionArray PeopleCode FUNCLIB_WF.WF_CI_FUNCTIONS FieldFormula;

Global string &TransactionName;
Global Record &TransferKeyRec;
Global boolean &FromSelectPage;
Global date &WFASOFDATE;
Global number &SSGrp_ID_1; /* BS 13067604 */
Component Rowset &RSTransConfig;
Component Rowset &RSHdr;
Component Rowset &RSEdit;
Component Rowset &RSApprTmp;
Component Rowset &RSDenyTmp;
Component Rowset &RSProcDtl;
Component Rowset &RSProcCmnts;
Component Rowset &RSProcFolks;
Component Rowset &RSCIAdminProcDtl;
Component string &ExceptionTableName;
Component string &SSIndicator;
Component string &ComponentUse;
Component string &ConfigOption;
Component string &RSHdrRec;
Component string &RSHdrRecStr;
Component string &RSEditScroll;
Component string &RSEditRec;
Component string &RSEditRecStr;
Component string &RSApprTmpScroll;
Component string &RSApprTmpRec;
Component string &RSApprRecStr;
Component string &RSDenyTmpScroll;
Component string &RSDenyTmpRec;
Component string &RSDenyTmpRecStr;
Component string &RSProcDtlScroll;
Component string &RSProcDtlRec;
Component string &RSProcDtlRecStr;
Component string &RSTransDtlScroll;
Component string &RSTransDtlRec;
Component string &TransactionDescr;
Component string &NotifyOnSuccess;
Component string &NotifyOnWarnings;
Component string &BPRuleset;
Component string &CIRuleset;
Component string &ProcessAction;
Component number &CurrStep;
Component number &SubmitMsgSetNbr;
Component number &SubmitMsgNbr;
Component number &ApprMsgSetNbr;
Component number &ApprMsgNbr;
Component number &DenyMsgSetNbr;
Component number &DenyMsgNbr;
Component number &BodyCloseMsgSetNbr;
Component number &BodyCloseMsgNbr;
Component number &BodyIntroMsgSetNbr;
Component number &BodyIntroMsgNbr;
Component number &SubjMsgSetNbr;
Component number &SubjMsgNbr;
Component number &WarningMsgSetNbr;
Component number &WarningMsgNbr;
Component number &ErrorMsgSetNbr;
Component number &ErrorMsgNbr;
Component number &ErrWrnMsgSetNbr;
Component number &ErrWrnMsgNbr;
Component number &FutureMsgSetNbr;
Component number &FutureMsgNbr;
Component number &SuccessMsgSetNbr;
Component number &SuccessMsgNbr;
Component number &URLMsgSetNbr;
Component number &URLMsgNbr;
Component number &StepWereOn;
Component string &AllowDBUpdt;
Component string &ReturnPage;
Component string &UserId;
Component string &ReturnPanel;
Component string &TransactionType;
Component number &SSGrpID;
Component number &SSTransID;
Component boolean &EditRowFound;
Component boolean &ApprRowFound;
Component boolean &DenyRowFound;
Component boolean &NoRowsFoundAtAll;
Component boolean &AdmDontCallCI;
Component boolean &CIStgDesign;
Component boolean &Call_CI;
Component boolean &CI_Called;
Component boolean &MoreProcFolksFound;
Component boolean &RoleUserAltFound;
Component boolean &ApprProcError;
Component boolean &AdminPerfOverride;
Component array of string &EmailDataFldsArray;
Component array of array of string &SharedBPCompsArray;
Component Rowset &EmployeeRS;
Component integer &CurrentRow;

Local Page &PageObj;
Local array of string &MsgLineSubmitArray;
Local array of string &MsgLineApprArray;
Local array of string &MsgLineDenyArray;
Local array of string &MsgDataArray;
Local array of string &MsgLineArray;
Local Record &RSTransDtlRecordObj;
Local Record &RecordObj;
Local Record &RSEditRecord;
Local Record &TransfRecordObj;
Local Record &RSNotifyProcFolksRecOBj;
Local Record &RSProcDtlRecDBObj;
Local Record &ProcFolksRecObj;
Local Record &RSProcDtlRecObj;
Local Record &RSTransDtlRecObj;
Local Record &RSTransDtlRecord;
Local Field &ControlFld;
Local Field &Title_3;
Local Field &Title_2;
Local Field &Title_1;
Local Field &Title;
Local Field &Field;
Local Row &RSEditRow;
Local Row &RSProcDtlRow;
Local Rowset &RSProcParticipants;
Local Rowset &RSCIAdministrators;
Local Rowset &RSNotifyProcFolks;
Local Rowset &RSNotifyProcFolksDB;
Local Rowset &RSAlternate;
Local Rowset &RSCIRulesetOverride;
Local Rowset &RSCIRuleset;
Local Rowset &RSEmailTextDefault;
Local Rowset &RSEmailTextConfig;
Local Rowset &RSEmailTextComponent;
Local Rowset &RSBPRuleset;
Local Rowset &RSEmailTextTrans;
Local Rowset &RSEmailTextStatus;
Local Rowset &RSEmailBinds;
Local Rowset &RSCompForURL;
Local Rowset &RSProcFolksDeny;
Local Rowset &RSProcFolksAppr;
Local Rowset &RSProcCmntsDeny;
Local Rowset &RSProcCmntsAppr;
Local Rowset &RSEditNotSorted;
Local Rowset &RS2;
Local Rowset &RS1;
Local Rowset &RSCoreKeyFields;
Local Rowset &RSCoreComponent;
Local Rowset &RSBPAdminStep;
Local Rowset &RSTransferToComp;
Local Rowset &RSTransIdDtl;
Local Rowset &RSBfrStlOverride;
Local Rowset &RSBufferStl;
Local Rowset &RSTransDtl;
Local Rowset &KeysScroll;
Local Rowset &RSPageTextOverride;
Local Rowset &RSPageText;
Local Rowset &RSBusProcComp;
Local Rowset &RSBfrOverride;
Local Rowset &RSBuffer;
Local Rowset &RSEOTransDescr;
Local Rowset &RSEOTrans;
Local Rowset &OldRS;
Local Rowset &RS;
Local Rowset &RSTransVisFlds;
Local Rowset &RSSect;
Local Rowset &RSProcFolksOccur1;
Local boolean &RoleUserAltFound;
Local boolean &RunNextFrameworkCode;
Local boolean &RunNotifyLogic;
Local boolean &Result;
Local boolean &DenyInsReq;
Local boolean &ApprInsReq;
Local boolean &bool;
Local boolean &visibleprop;
Local boolean &checkforexisting;
Local boolean &StepisCurrent;
Local boolean &ValRowFound;
Local boolean &LabelFound;
Local boolean &FieldExists_Return;
Local number &CurrProcStep;
Local number &StepCheck;
Local number &NextStep;
Local number &TriggerWLTilRow;
Local number &KeysRow;
Local number &StartWLRow;
Local number &ProcFolksInsRow;
Local number &InsertRow;
Local number &NumBinds;
Local number &InsRow;
Local number &MsgSetNbrBind;
Local number &MsgNbrBind;
Local number &ValChk;
Local number &RSProcDtlArc;
Local number &RSProcParticipantsARC;
Local number &RSProcFolksARC;
Local number &DenyTmpArc;
Local number &ApprTmpArc;
Local number &RSEditArc;
Local number &RSApprTmpArc;
Local number &RSDenyTmpArc;
Local number &RSProcCmntsARC;
Local number &DenyRow;
Local number &ApprRow;
Local number &BPAdminStep;
Local number &NewSSGrpID;
Local number &SSMaxID;
Local number &stepbind;
Local number &NoneFoundMsgNbr;
Local number &NoneFoundMsgSet;
Local number &MsgNbr;
Local number &MsgSetNbr;
Local number &row;
Local number &KeepPropTilRow;
Local number &RSArc;
Local number &Level;
Local number &sectcount;
Local number &numsectLoops;
Local number &CurrApprCycle;
Local number &NumEmailFldsRequested;
Local number &Pad;
Local number &FieldNameWidth;
Local number &LastStep;
Local string &RoleUserProcessed;
Local string &ProcActionProcessed;
Local string &RSSelectGroupIDRec;
Local string &EmailPart;
Local string &RoleUserAlt;
Local string &CIRulesetOverride;
Local string &BusProc;
Local string &Activity;
Local string &EmailEvent;
Local string &WLEvent;
Local string &ThisRoleUser;
Local string &NextRoleUser;
Local string &SamePerson;
Local string &NextSSRoleType;
Local string &SSStatIndicator;
Local string &LastProcAction;
Local string &FirstSubmitEmailLoop;
Local string &FirstApprEmailLoop;
Local string &FirstDenyEmailLoop;
Local string &SortRec;
Local string &Sortfield1;
Local string &Sortfield2;
Local string &CurrProcPath;
Local string &strRecord;
Local string &Menu;
Local string &Component;
Local string &MenuforURL;
Local string &CompforURL;
Local string &ModeforURL;
Local string &PageforURL;
Local string &MarketforURL;
Local string &EmailURL;
Local string &CurrentPage;
Local string &Pagename;
Local string &SSRoleType;
Local string &EmailComponentUse;
Local string &NotifyCompUse;
Local string &TransNameBind;
Local string &IsRelated;
Local string &RelatedRec;
Local string &RelatedFld;
Local string &CurFldName;
Local string &RelRecFld;
Local string &RecNameObj;
Local string &RecName;
Local string &RoleUser_Emplid;
Local string &RoleName;
Local string &Roleuser;
Local string &AdmPosnChoice;
Local string &AdmUpdChoice;
Local string &AdmOverride;
Local string &AdminAction;
Local string &BPAdminPath;
Local string &stat_check;
Local string &RS1Record;
Local string &RSCoreSrchRec;
Local string &TransferMode;
Local string &TransferPanel;
Local string &TransferMarket;
Local string &TransferPnlGrp;
Local string &TransferItem;
Local string &TransferBar;
Local string &TransferMenu;
Local string &SSTransIDSelected;
Local string &SSGrpIDSelected;
Local string &TransferFld;
Local string &UserType;
Local string &TransferToComp;
Local string &SQLApprScroll;
Local string &SQLDenyScroll;
Local string &SQLEditScroll;
Local string &SQLAPLScroll;
Local string &SQLSTLTransIdScroll;
Local string &SQLSTLScroll;
Local string &NoneFndInstr;
Local string &RSSelectTransIDRec;
Local string &RSSelectTransIDScroll;
Local string &SQLProcDtl;
Local string &SQLTransDtl;
Local string &RSrecnameObj;
Local string &RSRecName;
Local string &OverrideValChk;
Local string &RSSelectGrpIDRec;
Local string &Scroll_3;
Local string &Scroll_2;
Local string &Scroll_1;
Local string &ApprReqFlg;
Local string &DBUpdateFlg;
Local string &RSDenyRecStr;
Local string &BufferRecname;
Local string &BufferUse;
Local string &TransDescr;
Local string &CurComponent;
Local string &StatIndicator;
Local string &StartEnd;
Local string &TxtField;
Local string &TxtRecname;
Local string &TranSection;
Local string &Process;
Local string &strVisibleProp;
Local string &LastActionChk2;
Local string &LastActionChk1;
Local string &LastAction;
Local string &SearchType;
Local string &FldChk;
Local string &RSDbRecname;
Local string &FieldLabel;
Local string &FieldRequested;
Local string &FieldValue;
Local string &TransFieldLabel;
Local string &EmployeeName;
Local string &Emplid;
Local string &CRLF;
Local string &Quote;
Local string &EmailText;
Local string &ProcAction;
Local string &FieldNameObj;
Local string &FieldName;
Local string &UnAlias_Return;
Local string &Property;
Local SQL &SQL;
Local any &Bind;
Local any &Bind1;
Local any &Bind2;
Local any &Bind3;
Local any &Bind4;
Local any &Bind5;
Local any &TransferFldVal;
Local any &Value;
Local any &KeyValChk;

/************************************************************************************************
        Function: DefineTransactionType
         Returns: N/A
 Input Arguments: TransactionName, TransactionType
Output Arguments: <none>
      Processing: This function determines whether a transaction is employee or manager initiated.
                  Used to determine which menu should be used for worklist and emails to the 
                  originator.  This data should be stored in a configuration table in future
                  releases.  For now, intended transaction type be set by application developers via
                  this function
************************************************************************************************/
Function DefineTransactionType(&TransTypeStr As string);
   &TransactionType = &TransTypeStr;
End-Function;

/************************************************************************************************
        Function: AppendMsgDetail(&MsgLineArray, &ComponentField)
         Returns: Void
 Input Arguments: &MsgLineArray (array of string)
                  &ComponentField (Long field in the component buffer)
Output Arguments: <none>
      Processing: Appends all entries in the Message Line array to the indicated long field in 
                  the component buffer.
************************************************************************************************/
Function AppendMsgDetail(&MsgLineArray As array of string, &ComponentField);
   /* &ComponentField = ""; */
   For &I = 1 To &MsgLineArray.Len
      rem  &WhatsPrinting = &MsgLineArray [&I];
      &ComponentField = &ComponentField | &MsgLineArray [&I];
   End-For;
End-Function;

/************************************************************************************************
        Function: UnAlias(&FieldName)
         Returns: String (new field name)
 Input Arguments: &FieldName (string)
Output Arguments: <none>
      Processing: This function translates field names as required. In some cases, the staged 
                  data tables contain aliased field names. For example, the field HR_SS_ACTION_DT 
                  is an alias for EFFDT. This function contains hardcoding to map any aliased 
                  fieldnames to their proper fieldname.  If the fieldname is not an alias, the 
                  input value of &FieldName will be returned. It expected that the use of aliased
                  fieldnames will be very infrequent (probably less than 5), so hardcoding this 
                  should not be an issue.
************************************************************************************************/
Function UnAlias(&FieldName) Returns string;
   
   Evaluate &FieldName
   When = "ACTION_DT_SS"
      &UnAlias_Return = "EFFDT";
      Break;
   When = "ACTION_REASON_SS"
      &UnAlias_Return = "ACTION_REASON";
      Break;
      /* When = "HR_REPCHNG_REASON" */
      /* &UnAlias_Return = "ACTION_REASON"; */
      /* Break; */
   When = "MAR_STATUS_NEW"
      &UnAlias_Return = "MAR_STATUS";
      Break;
   When = "FULL_PART_TIME_NEW"
      &UnAlias_Return = "FULL_PART_TIME";
      Break;
   When-Other
      &UnAlias_Return = &FieldName;
      Break;
   End-Evaluate;
   Return &UnAlias_Return;
End-Function;

/************************************************************************************************
        Function: FieldExists(&FieldName, &Record)
         Returns: Boolean
 Input Arguments: &FieldName (string)
	           &Record (record object)
Output Arguments: <none>
      Processing: Searches the field list of &Record to see if it contains the field identified 
                  by &FieldName. 
************************************************************************************************/
Function FieldExists(&FieldName As string, &Record As Record) Returns boolean;
   
   &FieldExists_Return = False;
   For &Z = 1 To &Record.FieldCount
      If &Record.GetField(&Z).Name = &FieldName Then
         &FieldExists_Return = True;
         Break;
      End-If;
   End-For;
   Return &FieldExists_Return;
End-Function;

/************************************************************************************************
        Function: PopulateArrayFromRecord(&PropertyArray, &Record, &IncludeKeys) 
         Returns: Array of String (&Property Array)
 Input Arguments: &PropertyArray (array of string)
	           &Record (record object)
                  &IncludeKeys (boolean)
Output Arguments: <none>
      Processing: This function is nearly identical to ciPopulateArrayFromRecord(), in that it 
                  populates the indicated property array with name/value pairs for each 
                  field in &Record. If &IncludeKeys is False, then Key Fields are not
                  Included. There are three differences between this function and 
                  ciPopulateArrayFromRecord():  
                 (1) This function uses the UnAlias() function to derive the true field name from 
                     aliased field names in &Record. 
                 (2) Since not all fields in the source record may exist in the target Collection, 
                     we need to make sure we donâ€™t add the "extra" fields not belonging to the 
                     Collection to the property array. We do this by checking each unaliased 
                     fieldname against the list of fields contained in the Base Record Name (from 
                     the Transaction Configuration), using the FieldExists() function.
                 (3) Fields that are defined as Keys in the Base Record are optionally populated,
                     based upon an input parameter. Normally, keys are not populated in the 
                     property array, but this function can be called for the purpose of generating
                     an e-mail message listing all field values via the property array, so in this 
                     case, we would process the base table keys as well. 
************************************************************************************************/
Function PopulateArrayFromRecord(&inArray As array of string, &inRecord As Record, &IncludeKeys As boolean) Returns array of string;
   
   For &I = 1 To &inRecord.FieldCount
      &Field = &inRecord.GetField(&I);
      &FieldName = &Field.Name;
      
      
      &FieldNameObj = "FIELD." | &FieldName;
      &Property = "PROP_" | &FieldName;
      &Value = &Field.Value;
      If All(&Value) Then
         &inArray.Push(&Property);
         &inArray.Push(&Value);
      End-If;
      
   End-For;
   Return &inArray;
End-Function;

/************************************************************************************************
        Function: Call_CI()
         Returns: true or false
 Input Arguments: <none>
Output Arguments: <none>
      Processing: Evaluates the current component being used.  Then, based on current component, the
                  transaction configuration settings in WF_HR_TRANS, and page buffer data, determines
                  whether a function call to update the database via component interface should be 
                  initiated.
************************************************************************************************/

/************************************************************************************************
        Function: Call_CI()
         Returns: true or false
 Input Arguments: <none>
Output Arguments: <none>
      Processing: Evaluates the current component being used.  Then, based on current component, the
                  transaction configuration settings in WF_HR_TRANS, and page buffer data, determines
                  whether a function call to update the database via component interface should be 
                  initiated.
************************************************************************************************/

Function Call_CI(&row As number) Returns boolean;
   &Call_CI = True;
   If &ApprProcError = True Then;
      &Call_CI = False;
   End-If;
   If &AdmDontCallCI = True Then;
      &Call_CI = False;
   End-If;
   If &Call_CI = True Then;
      &ProcessAction = &RSEdit.GetRow(&row).GetRecord(@&RSEditRec).GetField(Field.LAST_PROC_ACTION).Value;
      &RSProcDtl = &RSEdit.GetRow(&row).GetRowset(@&RSProcDtlScroll);
      &LastStep = &RSProcDtl.GetRow(&RSProcDtl.ActiveRowCount).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value;
      If &CurrStep < &LastStep Then;
         /*more approval rows found.  Can't call CI*/
         &Call_CI = False;
      Else;
         If &ProcessAction = "D" Then;
            &Call_CI = False;
         Else;
            &Call_CI = True;
         End-If;
      End-If;
   End-If;
   Return &Call_CI;
End-Function;


/************************************************************************************************
        Function: BuildEmailBody(&KeysRecord, &KeysDtlRecord)
         Returns: array of string
 Input Arguments: &Transaction (Transaction Name)
                  &KeysRecord 
                  &KeysDtlRecord 
Output Arguments: <none>
      Processing: This function builds the portion of an E-mail message that lists
                  each transaction field and its value. It returns an array containing
                  one entry per message line. 
                  This is a "public" function.
                  There is code to enable HTML-based messages, but this is untested and
                  unsupported at this time.
                  A message line is of the form:
                            Field Name Label            : Field Value
************************************************************************************************/
Function BuildEmailBody(&Transaction, &KeysRecord As Record, &KeysDtlRecord As Record, &LastProcAction) Returns array of string;
   
   
   &MsgDataArray = CreateArrayRept("", 0);
   &MsgLineArray = CreateArrayRept("", 0);
   
   
   &MsgDataArray = PopulateArrayFromRecord(&MsgDataArray, &KeysRecord, True);
   &MsgDataArray = PopulateArrayFromRecord(&MsgDataArray, &KeysDtlRecord, True);
   
   
   &EmailText = "";
   &FieldNameWidth = 32;
   &Quote = Char(34);
   
   &CRLF = Char(13) | Char(10); /* Carriage Return / Line Feed */
   
   /* Get the Emplid and Employee Name */
   
   &Emplid = &KeysRecord.GetField(Field.EMPLID).Value;
   
   &EmployeeName = get_person_name(&Emplid, "", "", "");
   
   
   /* Add Employee Id, Employee Name and Transaction to the top of the "list". */
   
   /* Employee Id: */
   &TransFieldLabel = MsgGetText(6605, 558, "Message Not Found");
   &EmailText = &EmailText | &CRLF | &TransFieldLabel;
   &Pad = &FieldNameWidth - Len(&TransFieldLabel);
   If &Pad > 0 Then
      &EmailText = &EmailText | Rept(" ", &Pad);
   End-If;
   &EmailText = &EmailText | " : " | &Emplid;
   &MsgLineArray.Push(&EmailText);
   &EmailText = "";
   
   /* Employee Name: */
   &TransFieldLabel = MsgGetText(6605, 559, "Message Not Found");
   &EmailText = &EmailText | &CRLF | &TransFieldLabel;
   &Pad = &FieldNameWidth - Len(&TransFieldLabel);
   If &Pad > 0 Then
      &EmailText = &EmailText | Rept(" ", &Pad);
   End-If;
   &EmailText = &EmailText | " : " | &EmployeeName;
   &MsgLineArray.Push(&EmailText);
   &EmailText = "";
   
   /* Transaction Name: */
   &TransFieldLabel = MsgGetText(6605, 560, "Message Not Found");
   &EmailText = &EmailText | &CRLF | &TransFieldLabel;
   &Pad = &FieldNameWidth - Len(&TransFieldLabel);
   If &Pad > 0 Then
      &EmailText = &EmailText | Rept(" ", &Pad);
   End-If;
   &EmailText = &EmailText | " : " | &TransactionDescr;
   
   &MsgLineArray.Push(&EmailText);
   &EmailText = "";
   
   &I = 1;
   
   If None(&EmailDataFldsArray) Then;
      &EmailDataFldsArray = CreateArrayRept("", 0);
   End-If;
   
   &NumEmailFldsRequested = &EmailDataFldsArray.Len;
   While &I < &MsgDataArray.Len
      &FieldName = Substitute(&MsgDataArray [&I], "PROP_", "");
      &FieldValue = &MsgDataArray [&I + 1];
      
      For &e = 1 To &NumEmailFldsRequested;
         &FieldRequested = &EmailDataFldsArray [&e];
         If &FieldName = &FieldRequested Then;
            
            /* Don't duplicate the Emplid in the message - it's already in the header */
            If &FieldName <> "EMPLID" Then
               /* Get the translated field label */
               /* Look in &Keysecord first */
               &LabelFound = False;
               For &J = 1 To &KeysRecord.FieldCount
                  If UnAlias(&KeysRecord.GetField(&J).Name) = &FieldName Then
                     &FieldLabel = &KeysRecord.GetField(&J).GetLongLabel(&FieldName);
                     If None(&FieldLabel) Then
                        &FieldLabel = &KeysRecord.GetField(&J).GetShortLabel(&FieldName);
                     End-If;
                     If None(&FieldLabel) Then
                        &FieldLabel = &KeysRecord.GetField(&J).Label;
                     End-If;
                     &LabelFound = True;
                     Break;
                  End-If;
               End-For;
               If Not (&LabelFound) Or
                     None(&FieldLabel) Then
                  &FieldLabel = &FieldName;
               Else
                  /* Drop the leading "*" for required fields, or any leading spaces */
                  &FieldLabel = LTrim(&FieldLabel, "*");
                  &FieldLabel = LTrim(&FieldLabel);
               End-If;
               
               If All(&FieldValue) Then
                  &EmailText = &EmailText | &CRLF | &FieldLabel;
                  &Pad = &FieldNameWidth - Len(&FieldLabel);
                  If &Pad > 0 Then
                     &EmailText = &EmailText | Rept(" ", &Pad);
                  End-If;
                  &EmailText = &EmailText | " : " | &FieldValue;
                  &MsgLineArray.Push(&EmailText);
                  &EmailText = "";
               End-If;
            End-If;
         End-If;
      End-For;
      &I = &I + 2;
   End-While;
   
   &ProcActionProcessed = &LastProcAction;
   &RoleUserProcessed = &ThisRoleUser;
   Return &MsgLineArray;
End-Function;

/************************************************************************************************
        Function: RowsExist()
         Returns: boolean
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Evaluates the current component being used.  If the current component is <>
                  administrator "ADM" component, look for the existence of a value in a Keyfield on the 
                  dbrecord of the rowset passed into the function. If data exists, then set 
                  &ValRowFound = true. 

                  If the current component is = "ADM", the Keyfield value check won't work.  The 
                  detailed search record/level 0 for administrator components would always have a value
                  in the keyfield.  Another method for checking for data must be used.  
                  Check the "last action" field on level 0.  

                  returns &ValRowFound.
************************************************************************************************/

Function RowsExist(&RS As Rowset) Returns boolean;
   &RSDbRecname = "Record." | &RS.DBRecordName;
   Evaluate &ComponentUse
   When "APL"
   When "STL";
      &FldChk = "Field.SS_GRP_ID";
      &SearchType = "KeyValue";
   When "APR"
   When "STS";
      &FldChk = "Field.SS_TRANS_ID";
      &SearchType = "KeyValue";
   When "ADM";
      &SearchType = "LastAction";
   End-Evaluate;
   
   If &SearchType = "KeyValue" Then;
      &KeyValChk = &RS.GetRow(1).GetRecord(@&RSDbRecname).GetField(@&FldChk).Value;
      If None(&KeyValChk) Then
         &ValRowFound = False;
      Else;
         &ValRowFound = True;
      End-If;
   End-If;
   
   If &SearchType = "LastAction" Then;
      &LastAction = GetLevel0().GetRow(1).GetRecord(@&RSHdrRec).GetField(Field.LAST_PROC_ACTION).Value;
      Evaluate &RSDbRecname
      When &RSEditRec;
         &LastActionChk1 = "A";
         &LastActionChk2 = "S";
      When &RSApprTmpRec;
         &LastActionChk1 = "X";
         &LastActionChk2 = "X";
      When &RSDenyTmpRec;
         &LastActionChk1 = "D";
         &LastActionChk2 = "D";
      End-Evaluate;
      If &LastAction = &LastActionChk1 Or
            &LastAction = &LastActionChk2 Then;
         &ValRowFound = True;
      Else;
         &ValRowFound = False;
      End-If;
   End-If;
   Return &ValRowFound;
End-Function;

/************************************************************************************************
        Function: GetStepWereOn()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Look at the first rowset instance of SS_PROC_FOLKS in the Edit SBP scroll.
                  Other occurances of SS_PROC_FOLKS for other keys in the Edit SBP scroll will have the
                  same rows/data in SS_PROC_FOLKS, so searching other occurances is not necessary.
                  Loop through rowset to look for the rowset that has the value = 1 in the CURRENT_STEP
                  field.  When 1 is found, set component variable &StepWereOn = PROCESS_STEP.
 ************************************************************************************************/

Function GetStepWereOn(&RS As Rowset)
   
   &RSProcFolksOccur1 = &RS.GetRow(1).GetRowset(Scroll.SS_PROC_FOLKS);
   
   For &K = 1 To &RSProcFolksOccur1.ActiveRowCount
      &StepisCurrent = &RSProcFolksOccur1.GetRow(&K).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.CURRENT_STEP).Value;
      If &StepisCurrent Then
         &StepWereOn = &RSProcFolksOccur1.GetRow(&K).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.PROCESS_STEP).Value;
         &CurrApprCycle = &RSProcFolksOccur1.GetRow(&K).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.SS_PROCESS_CYCLE).Value;
         &AdminPerfOverride = False;
         Break;
      End-If;
   End-For;
   If None(&StepWereOn) Then;
      rem Admin is performing an override on an errored or warnings encountered CI call;
      rem Therfore, no step would be current;
      &StepWereOn = 0;
      &AdminPerfOverride = True;
   End-If;
End-Function;

/************************************************************************************************
        Function: SetSectionVisibleProp()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Main which sets the page to show the appropriate page functionality.
                  Read control data table SS_SECTION_VSBL for default requested page behavior.
                  Then, override control table defaults with transaction-specific requested 
                  page behavior (if any.)

                  This function expects appropriate page buffer references in SS_SECTION_VSBL.  
                  Page designs for framework transactions must have all the fields that are marked
                  "DEFAULT" in this control table available on the page... in the buffer references 
                  as described in control table.  Addtional transation-specific fields can be added 
                  to this table to control page behavior, beyond the default set.

                  If a Edit, Appr Tmp, or Deny Tmp SBP instance does not have any rows in it, 
                  the entire SBP section instance will be hidden.
************************************************************************************************/
Function SetSectionVisibleProp(&ProcessRequested As string);
   &num_loops = 6;
   &RSTransVisFlds = CreateRowset(Record.SS_SECTION_VSBL);
   
   For &l = 1 To &num_loops;
      
      If &l = 1 Then;
         &RSTransVisFlds.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_CONFIG_OPTION=:3 and SS_STAT_INDICATOR =:4", "DEFAULT", &ComponentUse, "", "");
      End-If;
      
      If &l = 2 Then;
         &RSTransVisFlds.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_CONFIG_OPTION=:3 and SS_STAT_INDICATOR =:4", "DEFAULT", &ComponentUse, &ConfigOption, "");
      End-If;
      
      rem 3 is "DEFAULT" + &ComponentUse + &ConfigOption + &SSStatIndicator and is done below;
      
      If &l = 4 Then;
         &RSTransVisFlds.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_CONFIG_OPTION=:3 and SS_STAT_INDICATOR =:4", &TransactionName, &ComponentUse, "", "");
      End-If;
      
      If &l = 5 Then;
         &RSTransVisFlds.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 AND SS_CONFIG_OPTION=:3 and SS_STAT_INDICATOR =:4", &TransactionName, &ComponentUse, &ConfigOption, "");
      End-If;
      
      rem 6 is &TransactionName + &ComponentUse + &ConfigOption + &SSStatIndicator and is done below;
      
      
      Evaluate &ComponentUse
      When "ORG"
         /***************************************************************************************/
         /*no need to check for existing values in the &RSDenyTmp or &RSApprTmp.  since it's an */
         /* originating component, no rows will ever exist in these 2 SBP instances.            */
         /***************************************************************************************/
         &numsectLoops = 1;
         &checkforexisting = False;
         &RSSect = GetLevel0().GetRow(1).GetRowset(@&RSEditScroll);
         &EditRowFound = True;
         &ValRowFound = True;
         &Scroll_1 = &RSEditScroll;
         &Scroll_2 = &RSApprTmpScroll;
         &Scroll_3 = &RSDenyTmpScroll;
         &Title_1 = GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_EDIT_INFO);
         &Title_2 = GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_APPR_INFO);
         &Title_3 = GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_DENY_INFO);
         &RSSect = GetLevel0().GetRow(1).GetRowset(@&Scroll_1);
         &Title = &Title_1;
      When "ADM"
      When "STS"
      When "APR";
         &numsectLoops = 3;
         &checkforexisting = True;
         &Scroll_1 = &RSEditScroll;
         &Scroll_2 = &RSApprTmpScroll;
         &Scroll_3 = &RSDenyTmpScroll;
         &Title_1 = GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_EDIT_INFO);
         &Title_2 = GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_APPR_INFO);
         &Title_3 = GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_DENY_INFO);
      End-Evaluate;
      
      If &NoRowsFoundAtAll = True Then;
         GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_PROC_BTNS).Visible = False;
         GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_RECYLE_BTN).Visible = False;
         GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_SAVE_BTN).Visible = False;
         GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_SUBMIT_BTN).Visible = False;
         GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_SAVLTR_BTN).Visible = False;
         GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_SUBLTR_BTN).Visible = False;
      End-If;
      
      
      For &sectcount = 1 To &numsectLoops;
         If &checkforexisting = True Then;
            &ValRowFound = False;
            If &sectcount = 1 Then;
               &RSSect = GetLevel0().GetRow(1).GetRowset(@&Scroll_1);
               &Title = &Title_1;
               &ValRowFound = RowsExist(&RSSect);
               &TitleVisProp = True;
            End-If;
            If &sectcount = 2 Then;
               &RSSect = GetLevel0().GetRow(1).GetRowset(@&Scroll_2);
               &Title = &Title_2;
               &ValRowFound = RowsExist(&RSSect);
               &TitleVisProp = True;
            End-If;
            If &sectcount = 3 Then;
               &RSSect = GetLevel0().GetRow(1).GetRowset(@&Scroll_3);
               &Title = &Title_3;
               &ValRowFound = RowsExist(&RSSect);
               &TitleVisProp = True;
            End-If;
         End-If;
         
         If &ValRowFound = True Then;
            
            If &l = 3 Or
                  &l = 6 Then;
               &DBRecord = "Record." | &RSSect.DBRecordName;
               &SSStatIndicator = &RSSect.GetRow(1).GetRecord(@&DBRecord).GetField(Field.SS_STAT_INDICATOR).Value;
               
               If &l = 3 Then;
                  &TransBind = "DEFAULT"
               End-If;
               
               If &l = 6 Then;
                  &TransBind = &TransactionName;
               End-If;
               
               &RSTransVisFlds.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 AND SS_CONFIG_OPTION=:3 and SS_STAT_INDICATOR=:4", &TransBind, &ComponentUse, &ConfigOption, &SSStatIndicator);
            End-If;
            
            For &I = 1 To &RSTransVisFlds.ActiveRowCount;
               &Process = &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.SS_COMP_PROCESS).Value;
               If &Process = &ProcessRequested Then;
                  &TranSection = &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.SS_PAGE_AREA).Value;
                  &Level = &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.LEVELNUM).Value;
                  &TxtRecname = "Record." | &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.RECNAME).Value;
                  &TxtFieldStr = &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.FIELDNAME).Value;
                  &TxtField = "Field." | &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.FIELDNAME).Value;
                  &StartEnd = &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.WHICH_ROW_OR_ROWS).Value;
                  &strVisibleProp = &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.VISIBLE_PROPERTY).Value;
                  
                  Evaluate &Level
                  When 0;
                     Evaluate &TranSection
                     When "H"
                     When "E"
                     When "D"
                     When "A"
                        &RS = GetLevel0();
                     End-Evaluate;
                  When 1
                     Evaluate &TranSection
                     When "H"
                        &RS = GetLevel0();
                     When "E"
                        &RS = GetLevel0().GetRow(1).GetRowset(@&Scroll_1);
                     When "A"
                        &RS = GetLevel0().GetRow(1).GetRowset(@&Scroll_2);
                     When "D"
                        &RS = GetLevel0().GetRow(1).GetRowset(@&Scroll_3);
                     End-Evaluate;
                  When 2
                     Evaluate &TranSection
                     When "H"
                        &RS = GetLevel0();
                     When "E"
                        &RS = GetLevel0().GetRow(1).GetRowset(@&Scroll_1);
                     When "A"
                        &RS = GetLevel0().GetRow(1).GetRowset(@&Scroll_2);
                     When "D"
                        &RS = GetLevel0().GetRow(1).GetRowset(@&Scroll_3);
                     End-Evaluate;
                  End-Evaluate;
                  
                  If &strVisibleProp = "F" Then;
                     &visibleprop = False;
                  Else;
                     &visibleprop = True;
                  End-If;
                  
                  &RSArc = &RS.ActiveRowCount;
                  
                  Evaluate &StartEnd
                  When "A";
                     &KeepPropTilRow = &RS.ActiveRowCount + 1;
                  When "F";
                     &KeepPropTilRow = 2;
                  When "L";
                     &KeepPropTilRow = &RS.ActiveRowCount;
                  End-Evaluate;
                  
                  If &TxtField = "Field.SECTION_SAVE_BTN" Then;
                     &visTrans = &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.TRANSACTION_NAME).Value;
                     &visConfig = &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.SS_CONFIG_OPTION).Value;
                     &visStatus = &RSTransVisFlds.GetRow(&I).GetRecord(Record.SS_SECTION_VSBL).GetField(Field.SS_STAT_INDICATOR).Value;
                     &Process = &Process;
                     &TranSection = &TranSection;
                     &Level = &Level;
                     &TxtRecname = &TxtRecname;
                     &TxtField = &TxtField;
                     &StartEnd = &StartEnd;
                     &strVisibleProp = &strVisibleProp;
                  End-If;
                  
                  For &J = 1 To &RSArc;
                     If &Level = 2 Then;
                        &OldRS = &RS;
                        Evaluate &TxtField
                        When "Field.SECTION_PROC_CMNTS";
                           &RS = &RS.GetRow(&J).GetRowset(Scroll.SS_PROC_FOLKS);
                        When "Field.SECTION_PROC_FOLKS";
                           &RS = &RS.GetRow(&J).GetRowset(Scroll.SS_PROC_FOLKS);
                        When-Other;
                           &RS = &RS.GetRow(&J).GetRowset(@&RSProcDtlScroll);
                        End-Evaluate;
                        &row = 1;
                     Else;
                        &row = &J;
                     End-If;
                     
                     If &J = &KeepPropTilRow Then;
                        If &visibleprop = False Then
                           &visibleprop = True
                        Else;
                           &visibleprop = False
                        End-If;
                     End-If;
                     
                     &RS.GetRow(&row).GetRecord(@&TxtRecname).GetField(@&TxtField).Visible = &visibleprop;
                     If &Level = 2 Then;
                        &RS = &OldRS;
                     End-If;
                  End-For;
               End-If;
               If &Title.Name = &TxtFieldStr Then;
                  &Title.Visible = &visibleprop;
               End-If;
            End-For;
            
            For &m = 1 To &RSSect.ActiveRowCount;
               &RSSect.GetRow(&m).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_HIDE_ALL).Visible = True;
            End-For;
         Else;
            
            &Title.Visible = False;
            For &m = 1 To &RSSect.ActiveRowCount;
               &RSSect.GetRow(&m).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_HIDE_ALL).Visible = False;
            End-For;
         End-If;
      End-For;
      /***********************************************************************************************
    hide the approval all and deny all buttons if there is only one key instance.  doesn't make sense 
    display them.   
   ************************************************************************************************/
      If &EditRowFound = True And
            &RSEdit.ActiveRowCount = 1 Then;
         GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_PROC_BTNS).Visible = False;
      End-If;
      /***********************************************************************************************
   if an admin views denied transaction, hide the save button
   ************************************************************************************************/
      If &DenyRowFound = True And
            &RSDenyTmp.ActiveRowCount = 1 And
            &ComponentUse = "ADM" Then;
         GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_SAVE_BTN).Visible = False;
      End-If;
      /***********************************************************************************************
   if ss_stat_indicator = successful, hide the save button from the admin.
   ************************************************************************************************/
      If &EditRowFound = True And
            &ComponentUse = "ADM" Then;
         &StatIndicator = &RSEdit.GetRow(1).GetRecord(@&RSEditRec).GetField(Field.SS_STAT_INDICATOR).Value;
         If &StatIndicator = "S" Then;
            GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_SAVE_BTN).Visible = False;
         End-If;
      End-If;
   End-For;
End-Function;

/************************************************************************************************
        Function: DefineBfrRowSets()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Defines Rowsets for each level of the page architecture.
 ************************************************************************************************/

Function DefineBfrRowSets();
   
   &CurComponent = %Component;
   
   
   If &CurComponent = Component.SS_COMMON_WRK Then;
      &ComponentUse = GetWLFieldValue(Field.SS_COMP_USE);
      If %Language_Base = %Language Then
         &TransDescr = GetWLFieldValue(Field.DESCR);
      Else
         /* Ice Incident 1333361000 - Added logic to account for transaction descriptions 
	     retrieved in a language different from the base language description */
         &RelLangDescr = GetWLFieldValue(Field.DESCR);
         SQLExec("SELECT TRANSACTION_NAME FROM PS_EO_TRANS_LNG WHERE LANGUAGE_CD = :1 AND DESCR = :2", %Language, &RelLangDescr, &TransName);
         SQLExec("SELECT DESCR FROM PS_EO_TRANSACTIONS WHERE TRANSACTION_NAME = :1", &TransName, &BaseDescr);
         &TransDescr = &BaseDescr;
         /* Ice Incident 1571327000 - If no description is found in a language different from the base language description, 
		then retrieve the description from base language */
         If None(&TransDescr) Then
            &TransDescr = GetWLFieldValue(Field.DESCR);
         End-If;
         
      End-If;
      &RSEOTrans = CreateRowset(Record.EO_TRANSACTIONS);
      &RSEOTrans.Fill("WHERE DESCR=:1", &TransDescr);
      &TransactionName = &RSEOTrans.GetRow(1).GetRecord(Record.EO_TRANSACTIONS).GetField(Field.TRANSACTION_NAME).Value;
   End-If;
   
   &RSEOTransDescr = CreateRowset(Record.EO_TRANSACTIONS);
   &RSEOTransDescr.Fill("WHERE TRANSACTION_NAME=:1", &TransactionName);
   &TransactionDescr = &RSEOTransDescr.GetRow(1).GetRecord(Record.EO_TRANSACTIONS).GetField(Field.DESCR).Value;
   
   &RSBuffer = CreateRowset(Record.SS_PAGE_BUFFER);
   &RSBuffer.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2", "DEFAULT", &ComponentUse);
   
   &RSBfrOverride = CreateRowset(Record.SS_PAGE_BUFFER);
   &RSBfrOverride.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2", &TransactionName, &ComponentUse);
   
   
   For &I = 1 To &RSBuffer.ActiveRowCount
      
      &BufferUse = &RSBuffer.GetRow(&I).GetRecord(Record.SS_PAGE_BUFFER).GetField(Field.SS_BUFFER_USE).Value;
      &BufferRecname = &RSBuffer.GetRow(&I).GetRecord(Record.SS_PAGE_BUFFER).GetField(Field.RECNAME).Value;
      
      Evaluate &BufferUse
      When "H";
         &RSHdrRecStr = &BufferRecname;
         &RSHdrRec = "Record." | &BufferRecname;
      When "E";
         &RSEditRecStr = &BufferRecname;
         &RSEditScroll = "Scroll." | &BufferRecname;
         &RSEditRec = "Record." | &BufferRecname;
      When "A";
         &RSApprRecStr = &BufferRecname;
         &RSApprTmpScroll = "Scroll." | &BufferRecname;
         &RSApprTmpRec = "Record." | &BufferRecname;
      When "D";
         &RSDenyRecStr = &BufferRecname;
         &RSDenyTmpScroll = "Scroll." | &BufferRecname;
         &RSDenyTmpRec = "Record." | &BufferRecname;
      When "P";
         &RSProcDtlRecStr = &BufferRecname;
         &RSProcDtlScroll = "Scroll." | &BufferRecname;
         &RSProcDtlRec = "Record." | &BufferRecname;
      End-Evaluate;
      
   End-For;
   
   For &I = 1 To &RSBfrOverride.ActiveRowCount
      
      &BufferUse = &RSBfrOverride.GetRow(&I).GetRecord(Record.SS_PAGE_BUFFER).GetField(Field.SS_BUFFER_USE).Value;
      &BufferRecname = &RSBfrOverride.GetRow(&I).GetRecord(Record.SS_PAGE_BUFFER).GetField(Field.RECNAME).Value;
      
      Evaluate &BufferUse
      When "H";
         &RSHdrRecStr = &BufferRecname;
         &RSHdrRec = "Record." | &BufferRecname;
      When "E";
         &RSEditRecStr = &BufferRecname;
         &RSEditScroll = "Scroll." | &BufferRecname;
         &RSEditRec = "Record." | &BufferRecname;
      When "A";
         &RSApprRecStr = &BufferRecname;
         &RSApprTmpScroll = "Scroll." | &BufferRecname;
         &RSApprTmpRec = "Record." | &BufferRecname;
      When "D";
         &RSDenyRecStr = &BufferRecname;
         &RSDenyTmpScroll = "Scroll." | &BufferRecname;
         &RSDenyTmpRec = "Record." | &BufferRecname;
      When "P";
         &RSProcDtlRecStr = &BufferRecname;
         &RSProcDtlScroll = "Scroll." | &BufferRecname;
         &RSProcDtlRec = "Record." | &BufferRecname;
      When "L";
         &RSTransDtlScroll = "Scroll." | &BufferRecname;
         &RSTransDtlRec = "Record." | &BufferRecname;
      End-Evaluate;
      
   End-For;
   
   &RSHdr = GetRowset();
   &RSEdit = &RSHdr.GetRow(1).GetRowset(@&RSEditScroll);
   
   If &ComponentUse <> "STL" And
         &ComponentUse <> "APL" Then
      &RSApprTmp = &RSHdr.GetRow(1).GetRowset(@&RSApprTmpScroll);
      &RSDenyTmp = &RSHdr.GetRow(1).GetRowset(@&RSDenyTmpScroll);
   End-If;
   
   If &CurComponent = Component.SS_COMMON_WRK Then;
      &ComponentUse = "WRK";
   End-If;
   
End-Function;

/************************************************************************************************
        Function: GetConfigOption()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Writes a literal value 1, 2, 3 or 4 to the &ConfigOption Component variable
************************************************************************************************/
Function GetConfigOption();
   &DBUpdateFlg = &RSTransConfig.GetRow(1).GetRecord(Record.WF_HR_TRANS).GetField(Field.ALLOW_DB_UPDT).Value;
   &ApprReqFlg = &RSTransConfig.GetRow(1).GetRecord(Record.WF_HR_TRANS).GetField(Field.APPROVAL_REQUIRED).Value;
   
   If All(&DBUpdateFlg) Then;
      Evaluate &DBUpdateFlg
      When "N"
         Evaluate &ApprReqFlg
         When "Y"
            &ConfigOption = "1";
         When "N"
            &ConfigOption = "2";
         End-Evaluate;
      When "Y"
         Evaluate &ApprReqFlg
         When "Y"
            &ConfigOption = "3";
         When "N"
            &ConfigOption = "4";
         End-Evaluate;
      End-Evaluate;
   Else;
      &ConfigOption = "";
   End-If;
End-Function;

/************************************************************************************************
        Function: GetTransConfig()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 02/27/2002
Output Arguments: <none>
      Processing: loads configuration options for the transaction type into component rowset.  
                  transaction type is established based upon the component object being used.
 ************************************************************************************************/

Function GetTransConfig(&MenuName, &Market, &Component);
   /*grab the component config info first.  it determines which transaction is currently being used*/
   &RSBusProcComp = CreateRowset(Record.SS_BP_COMPS);
   &RSBusProcComp.Fill("WHERE MENUNAME=:1 and MARKET= :2 and PNLGRPNAME=:3", &MenuName, &Market, &Component);
   If &FromSelectPage = False Then;
      &URL_TransactionName = %Request.GetParameter("TRANSACTION_NAME");
      If All(&URL_TransactionName) Then;
         &TransactionName = &URL_TransactionName;
      Else;
         &TransactionName = &RSBusProcComp.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.TRANSACTION_NAME).Value;
      End-If;
   Else
      &FromSelectPage = False;
   End-If;
   &ComponentUse = &RSBusProcComp.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.SS_COMP_USE).Value;
   
   If &ComponentUse = "ADM" Then
      &TransactionName = GetLevel0().GetRow(1).GetRecord(Record.EO_TRANSACTIONS).GetField(Field.TRANSACTION_NAME).Value;
   End-If;
   
   &RSTransConfig = CreateRowset(Record.WF_HR_TRANS);
   &RSTransConfig.Fill("WHERE TRANSACTION_NAME=:1", &TransactionName);
   
   &AllowDBUpdt = &RSTransConfig.GetRow(1).GetRecord(Record.WF_HR_TRANS).GetField(Field.ALLOW_DB_UPDT).Value;
   
   If All(&AllowDBUpdt) Then;
      &CIStgDesign = True;
   End-If;
   
   DefineBfrRowSets();
   
   GetConfigOption();
   
   DefineTransactionType("Manager");
   
End-Function;

/************************************************************************************************
        Function: PopulateHdrAndKeys(&Component)
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none - populates level 0, level 1 
                   and transaction-specific DTL record as defined in the SS Configuration Tbl>
      Processing: Uses the HR Self Service configuration table to lookup transaction-specific parms
                  Establishes level 0 and level 1 rowset by reading in the selected employees
                  from chosen from the common OPRROWS_MULTI Page.  Selected EEs are stored in
                  OPRROWS_TMP.

                  SS_GRP_NBR is initialized to 0, but will be assigned a unique value during
                  save processing.
************************************************************************************************/

Function PopulateHdrAndKeys(&Component);
   &RSEdit.SelectNew(Record.OPRROWS_TMP, "WHERE ITEMNAME = :1 and EMPLID >' ' and OPRID=:2", &Component, %UserId);
End-Function;


/************************************************************************************************
        Function: GetPageText()
         Returns: Void  
 Input Arguments: &WhichProcess -  "B" for Build or "P" for SavePostChange
    Version Date: 02/27/2002
Output Arguments: <none>
      Processing: Changes all text on the page as defined in the configuration table for the
                  appropriate process event:  either build or save post change.

                  This function expects appropriate page buffer references in SS_PAGE_TEXT.  
                  Page designs for framework transactions must have all the fields that are marked
                  "DEFAULT" in this control table available on the page... in the buffer references 
                  as described in control table.  Addtional transation-specific fields can be added 
                  to this table to control page behavior, beyond the default set.
 ************************************************************************************************/
Function GetPageText(&ProcessRequested As string);
   
   &num_page_loops = 6;
   
   For &l = 1 To &num_page_loops;
      
      If &l = 1 Then;
         &RSPageText = CreateRowset(Record.SS_PAGE_TEXT);
         &PageTextFound = &RSPageText.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_COMP_PROCESS=:3 and SS_CONFIG_OPTION=:4 and SS_STAT_INDICATOR=:5", "DEFAULT", &ComponentUse, &ProcessRequested, " ", " ");
      End-If;
      
      If &l = 2 Then;
         &RSPageText = CreateRowset(Record.SS_PAGE_TEXT);
         &PageTextFound = &RSPageText.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_COMP_PROCESS=:3 and SS_CONFIG_OPTION=:4 and SS_STAT_INDICATOR=:5", "DEFAULT", &ComponentUse, &ProcessRequested, &ConfigOption, " ");
      End-If;
      
      If &l = 3 Then;
         &RSPageText = CreateRowset(Record.SS_PAGE_TEXT);
         &PageTextFound = &RSPageText.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_COMP_PROCESS=:3 and SS_CONFIG_OPTION=:4 and SS_STAT_INDICATOR =:5", "DEFAULT", &ComponentUse, &ProcessRequested, &ConfigOption, &SSStatIndicator);
      End-If;
      
      If &l = 4 Then;
         &RSPageText = CreateRowset(Record.SS_PAGE_TEXT);
         &PageTextFound = &RSPageText.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_COMP_PROCESS=:3 and SS_CONFIG_OPTION=:4 and SS_STAT_INDICATOR=:5", &TransactionName, &ComponentUse, &ProcessRequested, " ", " ");
      End-If;
      
      If &l = 5 Then;
         &RSPageText = CreateRowset(Record.SS_PAGE_TEXT);
         &PageTextFound = &RSPageText.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_COMP_PROCESS=:3 and SS_CONFIG_OPTION=:4 and SS_STAT_INDICATOR=:5", &TransactionName, &ComponentUse, &ProcessRequested, &ConfigOption, " ");
      End-If;
      
      If &l = 6 Then;
         &RSPageText = CreateRowset(Record.SS_PAGE_TEXT);
         &PageTextFound = &RSPageText.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_COMP_PROCESS=:3 and SS_CONFIG_OPTION=:4 and SS_STAT_INDICATOR =:5", &TransactionName, &ComponentUse, &ProcessRequested, &ConfigOption, &SSStatIndicator);
      End-If;
      
      
      If All(&PageTextFound) Then;
         For &I = 1 To &RSPageText.ActiveRowCount;
            &Level = &RSPageText.GetRow(&I).GetRecord(Record.SS_PAGE_TEXT).GetField(Field.LEVELNUM).Value;
            &TxtRecname = "Record." | &RSPageText.GetRow(&I).GetRecord(Record.SS_PAGE_TEXT).GetField(Field.RECNAME).Value;
            &TxtField = "Field." | &RSPageText.GetRow(&I).GetRecord(Record.SS_PAGE_TEXT).GetField(Field.FIELDNAME).Value;
            
            &MsgSetNbr = &RSPageText.GetRow(&I).GetRecord(Record.SS_PAGE_TEXT).GetField(Field.MESSAGE_SET_NBR).Value;
            &MsgNbr = &RSPageText.GetRow(&I).GetRecord(Record.SS_PAGE_TEXT).GetField(Field.MESSAGE_NBR).Value;
            If &TxtField = "Field.PAGE_INSTR_NONEFND" Then;
               &NoneFoundMsgSet = &MsgSetNbr;
               &NoneFoundMsgNbr = &MsgNbr;
            End-If;
            Evaluate &Level
            When 0;
               &RS = GetLevel0();
            When 1
               &RS = GetLevel0().GetRow(1).GetRowset(&KeysScroll);
            End-Evaluate;
            For &J = 1 To &RS.ActiveRowCount;
               &RS.GetRow(&J).GetRecord(@&TxtRecname).GetField(@&TxtField).Value = MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr);
               
               /* Begin - Request Salary Change Page - Page Instructions requires formatting of HTML Area */
               If &TransactionName = "HR_SALCHANGE" And
                     &TxtField = "Field.PAGE_INSTRUCTIONS" Then
                  
                  &Msg = MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr);
                  
                  If %Page = "EO_SUBMIT_CONFIRM" Or
                        %Page = "EO_SAVE_CONFIRM" Then
                     DERIVED_MSS_WRK.INSTRUCTION_LBL.DataAreaCollapsed = False;
                     &RS.GetRow(&J).GetRecord(@&TxtRecname).GetField(@&TxtField).Value = GetHTMLText(HTML.HR_INSTRTEXT3_HTML, &Msg);
                  End-If;
                  If %Page = "HR_SALCHANGE_MGR" Then
                     &RS.GetRow(&J).GetRecord(@&TxtRecname).GetField(@&TxtField).Value = GetHTMLText(HTML.HR_INSTRTEXT6_HTML, &Msg);
                  End-If;
                  
               End-If;
               /* End   - Request Salary Change Page - Requires formatting of HTML Area */
               
            End-For;
         End-For;
      End-If;
   End-For;
   
   If &NoRowsFoundAtAll = True Then;
      GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.PAGE_INSTRUCTIONS).Value = MsgGetExplainText(&NoneFoundMsgSet, &NoneFoundMsgNbr, "Message Not Found: Message Set Number " | &NoneFoundMsgSet | ", Message Number " | &NoneFoundMsgNbr);
   End-If;
   
End-Function;


/************************************************************************************************
        Function: SetListKeyLabel(&Menu, &Market, &Component)
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Used on STL and APL components.  Sets the hyperlink at the group level to 
                  a transaction-specific description, concatenated with the SS_GRP_ID.
************************************************************************************************/

Function SetListKeyLabel();
   For &I = 1 To &RSEdit.ActiveRowCount
      &TransDescr = &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.TRANSACTION_NAME).GetRelated(EO_TRANSACTIONS.DESCR).Value;
      &SSGrpID = &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.SS_GRP_ID).Value;
      &RSEdit.GetRow(&I).GetRecord(Record.DERIVED_SS).GetField(Field.PROCESS_BTN).Label = LTrim(&TransDescr) | " " | &SSGrpID;
   End-For;
End-Function;

/************************************************************************************************
        Function: SelectSectionRS()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Function that is a secondary call to load child process-related information into 
                  SBP instances, but only if the parent SBP (Edit, ApprTmp, DenyTmp) rowsets contain 
                  data.
************************************************************************************************/

Function SelectSectionRS(&RS As Rowset);
   &RSRecName = &RS.DBRecordName;
   &RSrecnameObj = "Record." | &RSRecName;
   For &I = 1 To &RS.ActiveRowCount
      &RSTransDtl = &RS.GetRow(&I).GetRowset(@&RSTransDtlScroll);
      &RSProcFolks = &RS.GetRow(&I).GetRowset(Scroll.SS_PROC_FOLKS);
      &RSProcDtl = &RS.GetRow(&I).GetRowset(@&RSProcDtlScroll);
      &SSTransID = &RS.GetRow(&I).GetRecord(@&RSrecnameObj).GetField(Field.SS_TRANS_ID).Value;
      &SQLTransDtl = "A WHERE A.TRANSACTION_NAME= :1 and A.SS_GRP_ID=:2 AND A.SS_TRANS_ID=:3";
      &SQLProcFolksDtl = "A WHERE A.TRANSACTION_NAME= :1 and A.SS_GRP_ID=:2 AND A.SS_TRANS_ID=:3";
      &SQLProcDtl = "A WHERE A.TRANSACTION_NAME= :1 and A.SS_GRP_ID=:2 AND A.SS_TRANS_ID=:3 AND A.PROCESS_STEP >=:4";
      
      &RSProcFolks.Select(@&RSProcDtlRec, &SQLProcFolksDtl, &TransactionName, &SSGrpID, &SSTransID);
      
      GetStepWereOn(&RS);
      
      If None(&StepWereOn) Then;
         &stepbind = &RSProcFolks.ActiveRowCount + 1;
      Else;
         &stepbind = &StepWereOn;
      End-If;
      
      &RSTransDtl.Select(@&RSTransDtlRec, &SQLTransDtl, &TransactionName, &SSGrpID, &SSTransID);
      &RSProcDtl.Select(@&RSProcDtlRec, &SQLProcDtl, &TransactionName, &SSGrpID, &SSTransID, &stepbind);
   End-For;
   If &ComponentUse = "APR" Then;
      /*force a change on the page so that save edits will fire*/
      &RSProcDtl.GetRow(1).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION).Value = " ";
   End-If;
End-Function;

/************************************************************************************************
        Function: MakeDTLReadOnly()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing:  Common function to loop through fields.count on the Transaction-specific detail
                   record and make all fields read only.  
************************************************************************************************/
Function MakeDTLReadOnly(&RS As Rowset);
   For &I = 1 To &RS.ActiveRowCount;
      &RSTransDtl = &RS.GetRow(&I).GetRowset(@&RSTransDtlScroll);
      For &J = 1 To &RSTransDtl.ActiveRowCount;
         &RSTransDtlRow = &RSTransDtl.GetRow(&J);
         &NumTransDtlRecs = &RSTransDtlRow.RecordCount;
         For &r = 1 To &NumTransDtlRecs;
            &RSTransDtlRecObj = &RSTransDtlRow.GetRecord(&r);
            For &K = 1 To &RSTransDtlRecObj.FieldCount
               &Field = &RSTransDtlRecObj.GetField(&K);
               &Field.DisplayOnly = True;
            End-For;
         End-For;
      End-For;
   End-For;
   TransSpecificProcess(&TransactionName, "MakeDTLReadOnlyEnd", &ComponentUse, &RunNextFrameworkCode);
End-Function;

/************************************************************************************************
        Function: LookForAlternate()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Function looks at Tools-owned table to see if workflow user entered an alternate
                  Roleuser into their user profile.  If so, enter that alternate user as it's own row 
                  with the same Process Step and Process path as the workflow user.
************************************************************************************************/
Function LookForAlternate(&Roleuser As string, &RoleUserAlt As string, &RSAlternate As Rowset) Returns boolean;
   &RSAlternate = CreateRowset(Record.PSROLEXLATOPRVW);
   If All(&Roleuser) Then;
      &RSAlternate.Fill("WHERE ROLEUSER=:1 AND EFFDT_FROM <=%Datein(:2) AND EFFDT_TO >=%Datein(:3)", &Roleuser, %Date, %Date);
      &RoleUserAlt = &RSAlternate.GetRow(1).GetRecord(Record.PSROLEXLATOPRVW).GetField(Field.ROLEUSER_ALT).Value;
      If All(&RoleUserAlt) Then;
         Return True;
      Else;
         Return False;
      End-If;
   End-If;
   If All(&RoleUserAlt) Then;
      &RSAlternate.Fill("WHERE ROLEUSER_ALT = :1 AND EFFDT_FROM <=%Datein(:2) AND EFFDT_TO >=%Datein(:3)", &RoleUserAlt, %Date, %Date);
      &Roleuser = &RSAlternate.GetRow(1).GetRecord(Record.PSROLEXLATOPRVW).GetField(Field.ROLEUSER).Value;
      If All(&Roleuser) Then;
         Return True;
      Else;
         Return False;
      End-If;
   End-If;
End-Function;

/************************************************************************************************
        Function: SelectPageScrolls()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Main function to load parent SBP occurences into buffer.
                  Builds the appropriate SQL to be used to load data into scrolls based on the 
                  component use.  

                  This same function is used to load data into transaction-detail pages, as well as 
                  the view-status list and approval list pages.
************************************************************************************************/


Function SelectPageScrolls();
   
   &UserId = %UserId;
   
   &NoRowsFoundAtAll = False;
   /*****************************************************************************************/
   /*Load the STL page buffer info into rowset so that the &RSSelectTransIDScroll reference */
   /*can be used to select data for both List and transaction-detail pages                  */
   /*****************************************************************************************/
   &RSBufferStl = CreateRowset(Record.SS_PAGE_BUFFER);
   &RSBufferStl.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2", "DEFAULT", "STL");
   &RSBfrStlOverride = CreateRowset(Record.SS_PAGE_BUFFER);
   &RSBfrStlOverride.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2", &TransactionName, "STL");
   
   For &I = 1 To &RSBufferStl.ActiveRowCount
      &BufferUse = &RSBufferStl.GetRow(&I).GetRecord(Record.SS_PAGE_BUFFER).GetField(Field.SS_BUFFER_USE).Value;
      &BufferRecname = &RSBufferStl.GetRow(&I).GetRecord(Record.SS_PAGE_BUFFER).GetField(Field.RECNAME).Value;
      Evaluate &BufferUse
      When "E";
         &RSSelectGrpIDRec = "Record." | &BufferRecname;
      When "L";
         &RSSelectTransIDScroll = "Scroll." | &BufferRecname;
         &RSSelectTransIDRec = "Record." | &BufferRecname;
      End-Evaluate;
   End-For;
   
   For &I = 1 To &RSBfrStlOverride.ActiveRowCount
      &BufferUse = &RSBfrStlOverride.GetRow(&I).GetRecord(Record.SS_PAGE_BUFFER).GetField(Field.SS_BUFFER_USE).Value;
      &BufferRecname = &RSBfrStlOverride.GetRow(&I).GetRecord(Record.SS_PAGE_BUFFER).GetField(Field.RECNAME).Value;
      
      Evaluate &BufferUse
      When "E";
         &RSSelectGrpIDRec = "Record." | &BufferRecname;
      When "L";
         &RSSelectTransIDScroll = "Scroll." | &BufferRecname;
         &RSSelectTransIDRec = "Record." | &BufferRecname;
      End-Evaluate;
   End-For;
   
   
   /************************************************************************************************/
   &SQLSTLScroll = "A WHERE A.TRANSACTION_NAME= :1 AND A.ROLEUSER= :2 AND CURRENT_STEP<>1 AND (A.SS_ROLETYPE='ORG' OR A.SS_ROLETYPE='APR')";
   &SQLSTLTransIdScroll = "A WHERE A.TRANSACTION_NAME= :1 AND A.ROLEUSER= :2 AND A.SS_GRP_ID=:3 AND (A.SS_ROLETYPE='ORG' OR A.SS_ROLETYPE='APR') AND A.CURRENT_STEP<>1";
   &SQLAPLTransIdScroll = "A WHERE A.TRANSACTION_NAME= :1 AND A.ROLEUSER= :2 AND A.SS_GRP_ID=:3 AND (A.SS_ROLETYPE='ORG' OR A.SS_ROLETYPE='APR') AND A.CURRENT_STEP=1";
   &SQLAPLScroll = "A WHERE A.TRANSACTION_NAME= :1 AND A.ROLEUSER= :2 AND CURRENT_STEP=1 and SS_ROLETYPE='APR'";
   &SQLEditScroll = "A WHERE A.TRANSACTION_NAME= :1 and A.SS_GRP_ID=:2 AND A.LAST_PROC_ACTION <> 'D'";
   &SQLDenyScroll = "A WHERE A.TRANSACTION_NAME= :1 and A.SS_GRP_ID=:2 AND A.LAST_PROC_ACTION = 'D'";
   &SQLApprScroll = "A WHERE A.TRANSACTION_NAME= :1 and A.SS_GRP_ID=:2 AND A.LAST_PROC_ACTION = 'A'";
   
   &URL_TransactionName = %Request.GetParameter("TRANSACTION_NAME");
   &URL_SSGrpID = %Request.GetParameter("SS_GRP_ID");
   &URL_SSTransID = %Request.GetParameter("SS_TRANS_ID");
   
   If All(&URL_TransactionName) Then;
      &TransferKeyRec = CreateRecord(@&RSHdrRec);
      &TransferKeyRec.TRANSACTION_NAME.Value = &URL_TransactionName;
      &TransferKeyRec.SS_GRP_ID.Value = &URL_SSGrpID;
      If &TransferToComp = "ADM" Then;
         &TransferKeyRec.SS_TRANS_ID.Value = &URL_SSTransID;
      End-If;
   End-If;
   
   Evaluate &ComponentUse
   When "APR"
   When "STS"
      &SSGrpID = &TransferKeyRec.SS_GRP_ID.Value;
   When "ADM"
      &SSGrpID = &RSHdr.GetRow(1).GetRecord(@&RSHdrRec).GetField(Field.SS_GRP_ID).Value;
      &SSTransID = &RSHdr.GetRow(1).GetRecord(@&RSHdrRec).GetField(Field.SS_TRANS_ID).Value;
   When "APR"
      &SQLEditScroll = &SQLEditScroll | " AND A.ROLEUSER= :3 AND (A.LAST_PROC_ACTION= 'S' OR A.LAST_PROC_ACTION= 'A') AND A.CURRENT_STEP=1";
      &SQLDenyScroll = &SQLDenyScroll | " AND A.ROLEUSER= :3 AND CURRENT_STEP=1";
   When "STS";
      &SQLEditScroll = &SQLEditScroll | " AND A.ROLEUSER= :3 AND A.LAST_PROC_ACTION= 'S'";
      &SQLDenyScroll = &SQLDenyScroll | " AND A.ROLEUSER= :3";
      &SQLApprScroll = &SQLApprScroll | " AND A.ROLEUSER= :3";
   When "ADM";
      &SQLEditScroll = &SQLEditScroll | " AND A.SS_TRANS_ID=:3 AND (A.LAST_PROC_ACTION= 'A' or A.LAST_PROC_ACTION= 'S') AND A.SS_ROLETYPE='ORG' AND A.IS_ALTERNATE=0";
      &SQLDenyScroll = &SQLDenyScroll | " AND A.SS_TRANS_ID=:3 AND A.LAST_PROC_ACTION= 'D' AND A.SS_ROLETYPE='ORG' AND A.IS_ALTERNATE=0";
      &SQLApprScroll = &SQLApprScroll | " AND A.SS_TRANS_ID=:3 AND A.LAST_PROC_ACTION= 'X' AND A.SS_ROLETYPE='ORG' AND A.IS_ALTERNATE=0";
   End-Evaluate;
   
   Evaluate &ComponentUse
   When "APR"
      &RSEdit.Select(@&RSSelectTransIDRec, &SQLEditScroll, &TransactionName, &SSGrpID, &UserId);
      &RSDenyTmp.Select(@&RSSelectTransIDRec, &SQLDenyScroll, &TransactionName, &SSGrpID, &UserId);
   When "STS";
      &RSEdit.Select(@&RSSelectTransIDRec, &SQLEditScroll, &TransactionName, &SSGrpID, &UserId);
      &RSDenyTmp.Select(@&RSSelectTransIDRec, &SQLDenyScroll, &TransactionName, &SSGrpID, &UserId);
      &RSApprTmp.Select(@&RSSelectTransIDRec, &SQLApprScroll, &TransactionName, &SSGrpID, &UserId);
   When "ADM";
      &RSEdit.Select(@&RSSelectTransIDRec, &SQLEditScroll, &TransactionName, &SSGrpID, &SSTransID, &UserId);
      &RSDenyTmp.Select(@&RSSelectTransIDRec, &SQLDenyScroll, &TransactionName, &SSGrpID, &SSTransID);
      &RSApprTmp.Select(@&RSSelectTransIDRec, &SQLApprScroll, &TransactionName, &SSGrpID, &SSTransID);
   When "APL";
      &RSEdit.Select(@&RSSelectGrpIDRec, &SQLAPLScroll, &TransactionName, &UserId);
      If All(&SharedBPCompsArray) Then;
         &ArrayCompUse = &SharedBPCompsArray [1][2];
         If &ArrayCompUse = &ComponentUse Then;
            For &s = 1 To &SharedBPCompsArray.Len;
               &TransNameSel = &SharedBPCompsArray [&s][1];
               &RSEdit.Select(@&RSSelectGrpIDRec, &SQLAPLScroll, &TransNameSel, &UserId);
            End-For;
         End-If;
      End-If;
   When "STL";
      &RSEdit.Select(@&RSSelectGrpIDRec, &SQLSTLScroll, &TransactionName, &UserId);
      
      If All(&SharedBPCompsArray) Then;
         &ArrayCompUse = &SharedBPCompsArray [1][2];
         If &ArrayCompUse = &ComponentUse Then;
            For &s = 1 To &SharedBPCompsArray.Len;
               &TransNameSel = &SharedBPCompsArray [&s][1];
               &RSEdit.Select(@&RSSelectGrpIDRec, &SQLSTLScroll, &TransNameSel, &UserId);
            End-For;
         End-If;
      End-If;
   End-Evaluate;
   
   /*****************************************************************************************/
   /*Look for existence of rows in each of the SBP occurences                               */
   /*****************************************************************************************/
   
   &ValRowFound = RowsExist(&RSEdit);
   If &ValRowFound = True Then;
      &EditRowFound = True;
   Else;
      &EditRowFound = False;
   End-If;
   
   If &ComponentUse = "STS" Or
         &ComponentUse = "APR" Or
         &ComponentUse = "ADM" Then;
      &ValRowFound = RowsExist(&RSDenyTmp);
      If &ValRowFound = True Then;
         &DenyRowFound = True;
      Else;
         &DenyRowFound = False;
      End-If;
      
      &ValRowFound = RowsExist(&RSApprTmp);
      If &ValRowFound = True Then;
         &ApprRowFound = True;
      Else;
         &ApprRowFound = False;
      End-If;
      
      /*****************************************************************************************/
      /*If rows are found SBP occurence, select child process-related data                     */
      /*****************************************************************************************/
      
      If &EditRowFound = True Then
         SelectSectionRS(&RSEdit);
         If &RoleUserAltFound = True Then;
            &SortRec = &RSProcDtlRecStr;
            &Sortfield1 = &SortRec | ".IS_ALTERNATE";
            &RSProcDtl.Sort(@&Sortfield1, "D");
         End-If;
      End-If;
      
      If &ApprRowFound = True Then
         SelectSectionRS(&RSApprTmp);
      End-If;
      
      If &DenyRowFound = True Then
         SelectSectionRS(&RSDenyTmp);
      End-If;
   End-If;
   
   Evaluate &ComponentUse
   When "STL"
   When "APL";
      /***********************************************************************************************/
      /*subselect the ss_trans_id grid                                                               */
      /***********************************************************************************************/
      /*do subselect of the ss_trans_id grid*/
      If &EditRowFound = True Then;
         For &I = 1 To &RSEdit.ActiveRowCount
            &RSTransIdDtl = &RSEdit.GetRow(&I).GetRowset(@&RSSelectTransIDScroll);
            &TransNameSelect = &RSEdit.GetRow(&I).GetRecord(@&RSSelectGrpIDRec).GetField(Field.TRANSACTION_NAME).Value;
            &SSGrpID = &RSEdit.GetRow(&I).GetRecord(@&RSSelectGrpIDRec).GetField(Field.SS_GRP_ID).Value;
            If &ComponentUse = "STL" Then;
               &SQLTransIdScroll = &SQLSTLTransIdScroll;
            End-If;
            If &ComponentUse = "APL" Then;
               &SQLTransIdScroll = &SQLAPLTransIdScroll;
            End-If;
            &RSTransIdDtl.Select(@&RSSelectTransIDRec, &SQLTransIdScroll, &TransNameSelect, &UserId, &SSGrpID);
         End-For;
      Else;
         /********************************************************************************************/
         /*if no ss_grp_ids are found (the grid is empty), hide grid and present "no rows found" msg */
         /********************************************************************************************/
         &NoneFndInstr = &RSHdr.GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.PAGE_INSTR_NONEFND).Value;
         &RSEdit.GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.SECTION_HIDE_ALL).Visible = False;
         &RSHdr.GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.PAGE_INSTRUCTIONS).Value = &NoneFndInstr;
      End-If;
   When "STS"
   When "APR"
   When "ADM"
      If &EditRowFound = True Then;
         MakeDTLReadOnly(&RSEdit);
      End-If;
      If &DenyRowFound = True Then;
         MakeDTLReadOnly(&RSDenyTmp);
      End-If;
      If &ApprRowFound = True Then;
         MakeDTLReadOnly(&RSApprTmp);
      End-If;
      
      If &EditRowFound = False And
            &DenyRowFound = False And
            &ApprRowFound = False Then;
         &NoRowsFoundAtAll = True;
      End-If;
   End-Evaluate;
   
End-Function;

/************************************************************************************************
        Function: TransfertoTransPage()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Common function that transfers user from current component to requested component
                  that is part of the self service business process.
                  Menu reference parameters needed for transfer function are derived from the
                  SS_BP_COMPS control table.
************************************************************************************************/

Function TransfertoTransPage();
   &RSTransferToComp = CreateRowset(Record.SS_BP_COMPS);
   
   If &CurComponent <> Component.SS_COMMON_WRK Then;
      Evaluate &ComponentUse
      When "APL"
         &TransferToComp = "APR";
         &TransactionName = &RSEdit.GetRow(CurrentRowNumber()).GetRecord(@&RSEditRec).GetField(Field.TRANSACTION_NAME).Value;
      When "STL"
         &TransferToComp = "STS";
         &TransactionName = &RSEdit.GetRow(CurrentRowNumber()).GetRecord(@&RSEditRec).GetField(Field.TRANSACTION_NAME).Value;
      When "ADM"
         &TransferToComp = "COR";
      End-Evaluate;
   Else;
      &TransferToComp = &ComponentUse;
   End-If;
   
   &RSTransferToComp.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2", &TransactionName, &TransferToComp);
   
   If All(&UserType) Then;
      &RSTransferToComp.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE=:2 and SS_USER_TYPE =:3", &TransactionName, &TransferToComp, &UserType);
   End-If;
   
   &TransferMenu = &RSTransferToComp.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.MENUNAME).Value;
   &TransferBar = &RSTransferToComp.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.BARNAME).Value;
   &TransferItem = &RSTransferToComp.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.ITEMNAME).Value;
   &TransferPnlGrp = &RSTransferToComp.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.PNLGRPNAME).Value;
   &TransferMarket = &RSTransferToComp.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.MARKET).Value;
   &TransferPanel = &RSTransferToComp.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.PNLNAME).Value;
   &TransferMode = &RSTransferToComp.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.ACCESS_MODE).Value;
   
   
   If &CurComponent = Component.SS_COMMON_WRK Then;
      &TransferKeyRec = CreateRecord(@&RSHdrRec);
      &SSGrpIDSelected = GetWLFieldValue(Field.SS_GRP_ID);
      &SSTransIDSelected = GetWLFieldValue(Field.SS_TRANS_ID);
      &SSEmplidSelected = GetWLFieldValue(Field.EMPLID);
      &TransferKeyRec.TRANSACTION_NAME.Value = &TransactionName;
      &TransferKeyRec.SS_GRP_ID.Value = &SSGrpIDSelected;
      If &TransferToComp = "ADM" Then;
         &TransferKeyRec.SS_TRANS_ID.Value = &SSTransIDSelected;
         If &TransferPnlGrp = "TRN_REQUEST_ADM" Then
            &TransferKeyRec.EMPLID.Value = &SSEmplidSelected;
         End-If;
      End-If;
   Else;
      If &ComponentUse = "ADM" Then;
         /**************************************************************************************/
         /*Determine the appropriate KeyRecord structure to be used with the transfer function */
         /*Base the record structure on the search record of the core component.  Search record*/
         /*is a property of the component stored in Tools Table PSPNLGRPDEFN                   */
         /**************************************************************************************/
         &RSCoreComponent = CreateRowset(Record.PSPNLGRPDEFN);
         &RSCoreComponent.Fill("WHERE PNLGRPNAME= :1 and MARKET = :2", &TransferPnlGrp, &TransferMarket);
         &RSCoreSrchRec = "Record." | &RSCoreComponent.GetRow(1).GetRecord(Record.PSPNLGRPDEFN).GetField(Field.SEARCHRECNAME).Value;
         &TransferKeyRec = CreateRecord(@&RSCoreSrchRec);
         /**************************************************************************************/
         /*Read control table to determine which record in the buffer holds the values of keys */
         /*required by the core component...needed to do the transfer.                         */
         /**************************************************************************************/
         &RSCoreKeyFields = CreateRowset(Record.SS_KEYFIELDS);
         &RSCoreKeyFields.Fill("WHERE TRANSACTION_NAME = :1", &TransactionName);
         For &I = 1 To &RSCoreKeyFields.ActiveRowCount
            &BufferUse = &RSCoreKeyFields.GetRow(&I).GetRecord(Record.SS_KEYFIELDS).GetField(Field.SS_BUFFER_USE).Value;
            &TransferFld = "Field." | &RSCoreKeyFields.GetRow(&I).GetRecord(Record.SS_KEYFIELDS).GetField(Field.KEYNAME).Value;
            Evaluate &BufferUse
            When "E"
            When "L";
               If &EditRowFound = True Then;
                  &RS1 = &RSEdit;
                  &TransfRec = &RSEditRec;
               End-If;
               If &ApprRowFound = True Then;
                  &RS1 = &RSApprTmp;
                  &TransfRec = &RSApprTmpRec;
               End-If;
               If &DenyRowFound = True Then;
                  &RS1 = &RSDenyTmp;
                  &TransfRec = &RSDenyTmpRec;
               End-If;
               If &BufferUse <> "L" Then;
                  &TransferFldVal = &RS1.GetRow(1).GetRecord(@&TransfRec).GetField(@&TransferFld).Value;
               End-If;
            When "L"
               &RS2 = &RS1.GetRow(1).GetRowset(@&RSTransDtlScroll);
               &TransferFldVal = &RS2.GetRow(1).GetRecord(@&RSTransDtlRec).GetField(@&TransferFld).Value;
            End-Evaluate;
            &TransferKeyRec.GetField(@&TransferFld).Value = &TransferFldVal;
         End-For;
      Else;
         &SSGrpIDSelected = &RSEdit.GetRow(CurrentRowNumber()).GetRecord(@&RSEditRec).GetField(Field.SS_GRP_ID).Value;
         &SSGrp_ID_1 = &RSEdit.GetRow(CurrentRowNumber()).GetRecord(@&RSEditRec).GetField(Field.SS_GRP_ID).Value; /* BS 13067604 */
         rem  &SSTrans_ID_1 = &RSEdit.GetRow(CurrentRowNumber()).GetRecord(@&RSEditRec).GetField(Field.SS_TRANS_ID).Value; /* BS 13067604 */
         &TransferKeyRec = CreateRecord(@&RSEditRec);
         &TransferKeyRec.TRANSACTION_NAME.Value = &TransactionName;
         &TransferKeyRec.SS_GRP_ID.Value = &SSGrpIDSelected;
      End-If;
   End-If;
   
   /* Bug 14280681 -- Add if &TransferToComp <> "COR" so that emplid won't be wiped out in &TransferKeyRec to transfer to Job Data component */
   If &TransactionName = "HR_SALCHANGE" And
         &TransferToComp <> "COR" Then
      
      &TransferKeyRec = CreateRecord(@&RSEditRec);
      &TransferKeyRec.TRANSACTION_NAME.Value = &TransactionName;
      &TransferKeyRec.SS_GRP_ID.Value = &SSGrpIDSelected;
      /* Bug 14280681 -- Add key field value SS_TRANS_ID and Emplid to the search record to transfer to component HR_SALCHANGE_ADM */
      If &TransferPnlGrp = "HR_SALCHANGE_ADM" Then
         &TransferKeyRec.SS_TRANS_ID.Value = &SSTransIDSelected;
         SQLExec("SELECT EMPLID, EMPL_RCD FROM PS_SS_KEYS WHERE TRANSACTION_NAME = :1 AND SS_GRP_ID = :2 AND SS_TRANS_ID = :3", &TransferKeyRec.TRANSACTION_NAME.Value, &TransferKeyRec.SS_GRP_ID.Value, &TransferKeyRec.SS_TRANS_ID.Value, &TransferKeyRec.EMPLID.Value, &TransferKeyRec.EMPL_RCD.Value);
      End-If;
      SQLExec("Select %DateOut(EFFDT) from PS_SS_DTL_SALCHANG Where TRANSACTION_NAME = :1 and SS_GRP_ID = :2", &TransferKeyRec.TRANSACTION_NAME.Value, &TransferKeyRec.SS_GRP_ID.Value, &WFASOFDATE);
   End-If;
   
   If &TransferToComp = "COR" Then;
      
      Transfer( True, @("MenuName." | &TransferMenu), @("BarName." | &TransferBar), @("ItemName." | &TransferItem), @("Page." | &TransferPanel), &TransferMode, &TransferKeyRec);
   Else;
      Transfer( False, @("MenuName." | &TransferMenu), @("BarName." | &TransferBar), @("ItemName." | &TransferItem), @("Page." | &TransferPanel), &TransferMode, &TransferKeyRec);
   End-If;
End-Function;

/************************************************************************************************
        Function: TrafficCopTransfer()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: All worklists in the self service framework point to a dummy component and page.
                  Parse the SS_COMP_USE from the common worklist record definition.  This is the
                  ultimate target component for the worklist.
                  Read the menu/item/page/access for the current self service business process based
                  on SS_COMP_USE and transaction.  Transfer user to this component.
************************************************************************************************/
Function TrafficCopTransfer;
   &ComponentUse = GetWLFieldValue("SS_COMP_USE");
   &UserType = GetWLFieldValue("SS_USER_TYPE");
   TransfertoTransPage();
End-Function;

/************************************************************************************************
        Function: HideAltIfNotAlt()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Set visible property for SS_PROCESS_DTL row where user is an alternate..if the 
	           signed on user is not the alternate.
************************************************************************************************/
Function HideAltIfNotAlt;
   &num_loops = 3;
   For &l = 1 To &num_loops;
      If &l = 1 Then;
         &RS = &RSEdit;
         &RowFound = &EditRowFound;
      End-If;
      If &l = 2 Then;
         &RS = &RSApprTmp;
         &RowFound = &ApprRowFound;
      End-If;
      If &l = 3 Then;
         &RS = &RSDenyTmp;
         &RowFound = &DenyRowFound;
      End-If;
      If &RowFound = True Then;
         For &m = 1 To &RS.ActiveRowCount;
            &RSProcFolks = &RS.GetRow(&m).GetRowset(Scroll.SS_PROC_FOLKS);
            For &d = &RSProcFolks.ActiveRowCount To 1 Step - 1;
               If &RSProcFolks.GetRow(&d).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.IS_ALTERNATE).Value = 1 Then;
                  &AltUserID = &RSProcFolks.GetRow(&d).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.ROLEUSER).Value;
                  If &AltUserID <> %UserId Then;
                     &RSProcFolks.GetRow(&d).Visible = False;
                  End-If;
               End-If;
            End-For;
         End-For;
      End-If;
   End-For;
End-Function;

/************************************************************************************************
        Function: HideAdminsWithNoEmplid()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Set visible property for SS_PROCESS_DTL row where the administrator does not have an 
                  emplid in their user profile.  Addresses usability issue.
************************************************************************************************/
Function HideAdminsWithNoEmplid;
   &num_loops = 3;
   For &l = 1 To &num_loops;
      If &l = 1 Then;
         &RS = &RSEdit;
         &RowFound = &EditRowFound;
      End-If;
      If &l = 2 Then;
         &RS = &RSApprTmp;
         &RowFound = &ApprRowFound;
      End-If;
      If &l = 3 Then;
         &RS = &RSDenyTmp;
         &RowFound = &DenyRowFound;
      End-If;
      If &RowFound = True Then;
         &AtLeastOneVisible = False;
         For &m = 1 To &RS.ActiveRowCount;
            &RSProcFolks = &RS.GetRow(&m).GetRowset(Scroll.SS_PROC_FOLKS);
            For &d = &RSProcFolks.ActiveRowCount To 1 Step - 1;
               If &RSProcFolks.GetRow(&d).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.SS_ROLETYPE).Value = "ADM" Then;
                  /*Start Bug:11611104*/
                  rem &NextRoleType = &RSProcFolks.GetRow(&d - 1).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.SS_ROLETYPE).Value;
                  If &d > 1 Then
                     &NextRoleType = &RSProcFolks.GetRow(&d - 1).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.SS_ROLETYPE).Value;
                  Else
                     &NextRoleType = " ";
                  End-If;
                  /*End Bug:11611104*/
                  &RSProcFolksEmplid = &RSProcFolks.GetRow(&d).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.ROLEUSER_EMPLID).Value;
                  If None(&RSProcFolksEmplid) Then;
                     &AdminUserID = &RSProcFolks.GetRow(&d).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.ROLEUSER).Value;
                     If &AdminUserID <> %UserId Then;
                        If &NextRoleType = "ADM" Then;
                           &RSProcFolks.GetRow(&d).Visible = False;
                        End-If;
                        /****************************************************************************/
                        /*if loop is on last admin roletype and at least one admin row isn't showing*/
                        /*by this point, turn on one admin row                                      */
                        /****************************************************************************/
                        If &NextRoleType <> "ADM" And
                              &AtLeastOneVisible = False Then;
                           &RSProcFolks.GetRow(&d).Visible = True;
                           rem         &RSProcFolks.GetRow(&d).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.ROLEUSER_EMPLID).GetRelated(PERSON_NAME.NAME).Value = "Hello";
                        End-If;
                     Else;
                        &AtLeastOneVisible = True
                     End-If;
                  End-If;
               End-If;
            End-For;
         End-For;
      End-If;
   End-For;
End-Function;

/************************************************************************************************
        Function: SetAdminSBPFunctionality()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Preps the administrator processing subpage to show the appopriate processing
                  select options.  Specific to only those transactions that use a CI Staged Data
                  Design.
************************************************************************************************/

Function SetAdminSBPFunctionality();
   
   If &EditRowFound = True Then;
      &RS1 = &RSEdit;
      &RS1Record = &RSEditRec;
   End-If;
   If &ApprRowFound = True Then;
      &RS1 = &RSApprTmp;
      &RS1Record = &RSApprTmpRec;
   End-If;
   If &DenyRowFound = True Then;
      &RS1 = &RSDenyTmp;
      &RS1Record = &RSDenyTmpRec;
   End-If;
   /***** Begin bug 17894519  *****/
   /* Code Begin */
   If %Page = "HR_SALCHANGE_ADM" Or
         %Page = "TRN_REQUEST_ADM" Then
      Local Field &SC, &MC1, &MC2, &CC1, &CC2;
      
      &SC = GetPageField(%Page, "SUCCESSCHOICE");
      &SC.Label = MsgGetExplainText(6605, 109, "Message Not Found");
      
      &MC1 = GetPageField(%Page, "MANUALCHOICE1");
      &MC2 = GetPageField(%Page, "MANUALCHOICE2");
      &MC1.Label = MsgGetExplainText(6605, 110, "Message Not Found");
      &MC2.Label = MsgGetExplainText(6605, 110, "Message Not Found");
      
      &CC1 = GetPageField(%Page, "CANCELCHOICE1");
      &CC2 = GetPageField(%Page, "CANCELCHOICE2");
      &CC1.Label = MsgGetExplainText(6605, 111, "Message Not Found");
      &CC2.Label = MsgGetExplainText(6605, 111, "Message Not Found");
   End-If;
   /* Code End */
   /***** End bug 17894519 *****/
   
   &stat_check = &RS1.GetRow(1).GetRecord(@&RS1Record).GetField(Field.SS_STAT_INDICATOR).Value;
   
   &TransfRecordObj = GetLevel0().GetRow(1).GetRecord(Record.WF_TRANSF_KEYS);
   &TransfRecordObj.TRANSACTION_NAME.Value = &RSEdit.GetRow(1).GetRecord(@&RSEditRec).GetField(Field.TRANSACTION_NAME).Value;
   &TransfRecordObj.SS_GRP_ID.Value = &RSEdit.GetRow(1).GetRecord(@&RSEditRec).GetField(Field.SS_GRP_ID).Value;
   &TransfRecordObj.SS_TRANS_ID.Value = &RSEdit.GetRow(1).GetRecord(@&RSEditRec).GetField(Field.SS_TRANS_ID).Value;
   
   &RecordObj = GetLevel0().GetRow(1).GetRecord(Record.SS_ERR_WRK);
   
   &RecordObj.SECTION_HIDE_ALL.Label = MsgGetText(6605, 108, "Message Not Found");
   
   &RecordObj.SS_STAT_INDICATOR.Value = &stat_check;
   
   &RecordObj.SS_ADM_UPD_CHOICES.Visible = False;
   &RecordObj.SS_ADM_POS_CHOICES.Visible = False;
   &RecordObj.SS_ADM_OVERRIDE.Visible = False;
   &RecordObj.ERR_WRN_PB.Visible = False;
   
   /***** Begin bug 17894519  *****/
   /* Comment Begin */
   <* &RecordObj.GetField(Field.SECTION_ADM_CHC_S).Value = MsgGetExplainText(6605, 109, "Message Not Found");
   &RecordObj.GetField(Field.SECTION_ADM_CHC_M).Value = MsgGetExplainText(6605, 110, "Message Not Found");
   &RecordObj.GetField(Field.SECTION_ADM_CHC_C).Value = MsgGetExplainText(6605, 111, "Message Not Found");*>
   /* Comment Begin */
   /***** End bug 17894519 *****/
   
   
   &RecordObj.SS_ADM_UPD_CHOICES.Value = "";
   &RecordObj.SS_ADM_POS_CHOICES.Value = "";
   /*Bug 11592823 start */
   If &TransfRecordObj.TRANSACTION_NAME.Value = "HR_TRAIN_ENROLL" Or
         &TransfRecordObj.TRANSACTION_NAME.Value = "HR_TRAIN_ENROLL_MGR" Then
      &RecordObj.SS_ADM_UPD_CHOICES.Value = "S";
   End-If;
   /* Bug 11592823 End */
   Evaluate &stat_check
   When "E"
   When "B"
   When "W";
      &RecordObj.SS_ADM_OVERRIDE.Visible = True;
      &RecordObj.ERR_WRN_PB.Visible = True;
   When "E"
      &RecordObj.ERR_WRN_PB.Label = MsgGetExplainText(6605, 747, "Message Not Found 6605, 747");
   When "W"
      &RecordObj.ERR_WRN_PB.Label = MsgGetExplainText(6605, 748, "Message Not Found 6605, 748");
   When "B"
      &RecordObj.ERR_WRN_PB.Label = MsgGetExplainText(6605, 749, "Message Not Found 6605, 749");
   When "C"
   When "I"
   When "S";
   When "D";
      Break;
   When "M"
      &RecordObj.SS_ADM_UPD_CHOICES.Visible = True;
      Break;
   End-Evaluate;
End-Function;

/************************************************************************************************
        Function: BuildPage(&Menu, &Market, &Component)
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Main routine that builds pages in SS Framework.  Called from RowInit HR_SS_ACTIVATE.
                  Each subroutine under Build Page is described at the function level.
************************************************************************************************/

Function BuildPage(&Menu, &Market, &Component);
   GetTransConfig(&Menu, &Market, &Component);
   TransSpecificProcess(&TransactionName, "BuildPageStart", &ComponentUse, &RunNextFrameworkCode);
   If &RunNextFrameworkCode = True Then;
      Evaluate &ComponentUse
      When "ORG";
         If %Component <> "HR_SALCHANGE_ORG" Then /* new DR API doesn't use table OPRROWS_TMP */
            PopulateHdrAndKeys(&Component);
         End-If;
         TransSpecificProcess(&TransactionName, "DataSpecificConfigStart", &ComponentUse, &RunNextFrameworkCode);
         SetSectionVisibleProp("B");
         GetPageText("B");
      When "STS"
      When "APR"
      When "ADM";
         SelectPageScrolls();
         TransSpecificProcess(&TransactionName, "DataSpecificConfigStart", &ComponentUse, &RunNextFrameworkCode);
         SetSectionVisibleProp("B");
         GetPageText("B");
         HideAdminsWithNoEmplid();
         rem HideAltIfNotAlt();
      When "ADM"
         If &CIStgDesign = True Then;
            SetAdminSBPFunctionality();
         End-If;
      When "STL"
      When "APL";
         GetPageText("B");
         SetSectionVisibleProp("B");
         SelectPageScrolls();
         SetListKeyLabel();
      When "WRK";
         TrafficCopTransfer();
      End-Evaluate;
   End-If;
   If &NoRowsFoundAtAll = False Then;
      TransSpecificProcess(&TransactionName, "BuildPageEnd", &ComponentUse, &RunNextFrameworkCode);
   End-If;
End-Function;

/************************************************************************************************
        Function: AssignKeys()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Used on Originator Components Only.  Reads the max SS_GRP_ID currently assigned
                  from the SS_HDR record.  Adds 1 to this max SS_GRP_ID value.  
                  Cycles through all records/details involved with the process and assigns the key
                  TransactionName and SS_GRP_ID to be used throughout the life of the request.
************************************************************************************************/
Function AssignKeys();
   &NewSSGrpID = GetNextNumberWithGapsCommit(SS_TRANS_NBR.TRANSACTION_NBR, 99999999999, 1, "WHERE TRANSACTION_NAME = :1", &TransactionName);
   
   If &NewSSGrpID < 1 Then
      SQLExec("Select MAX(SS_GRP_ID) from PS_SS_HDR where TRANSACTION_NAME = :1", &TransactionName, &SSMaxID);
      &NewSSGrpID = &SSMaxID + 1;
   End-If;
   
   &RSHdr.GetRow(1).GetRecord(@&RSHdrRec).GetField(Field.TRANSACTION_NAME).Value = &TransactionName;
   &RSHdr.GetRow(1).GetRecord(@&RSHdrRec).GetField(Field.SS_GRP_ID).Value = &NewSSGrpID;
   
   For &I = 1 To &RSEdit.ActiveRowCount
      &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.TRANSACTION_NAME).Value = &TransactionName;
      &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.SS_GRP_ID).Value = &NewSSGrpID;
      &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.SS_TRANS_ID).Value = &I;
      &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.LAST_PROC_ACTION).Value = "S";
      
      If &ConfigOption = "2" Then;
         &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.SS_STAT_INDICATOR).Value = "M";
      End-If;
      
      &RSTransDtl = &RSEdit.GetRow(&I).GetRowset(@&RSTransDtlScroll);
      For &J = 1 To &RSTransDtl.ActiveRowCount
         &RSTransDtl.GetRow(&J).GetRecord(@&RSTransDtlRec).GetField(Field.TRANSACTION_NAME).Value = &TransactionName;
         &RSTransDtl.GetRow(&J).GetRecord(@&RSTransDtlRec).GetField(Field.SS_GRP_ID).Value = &NewSSGrpID;
         &RSTransDtl.GetRow(&J).GetRecord(@&RSTransDtlRec).GetField(Field.SS_TRANS_ID).Value = &I;
         &RSTransDtl.GetRow(&J).GetRecord(@&RSTransDtlRec).GetField(Field.SS_PROCESS_CYCLE).Value = 1;
      End-For;
   End-For;
   
End-Function;

/************************************************************************************************
        Function: GetBPAdminStep()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Reads SS_ADM_RULESTP control table to determine which step in an Approval Ruleset
                  object should be considered the administrator step.  The administrator step should 
                  always be the last step in the approval ruleset...but this control table serves
                  as a quality check to ensure that the "admin-is-last-step" rule is enforced.
************************************************************************************************/
Function GetBPAdminStep();
   
   &RSBPAdminStep = CreateRowset(Record.SS_ADM_RULESTP);
   &RSBPAdminStep.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION = :2 and APPR_RULE_SET = :3 and ADMIN_STEP_FLAG = 'Y'", &TransactionName, &ConfigOption, &BPRuleset);
   /* &BPAdminStep is the step that is represents the administrator in the approval rulestep object*/
   &BPAdminStep = &RSBPAdminStep.GetRow(1).GetRecord(Record.SS_ADM_RULESTP).GetField(Field.APPR_STEP).Value;
   &BPAdminPath = &RSBPAdminStep.GetRow(1).GetRecord(Record.SS_ADM_RULESTP).GetField(Field.APPR_PATH).Value;
End-Function;


/************************************************************************************************
        Function: GetBPRuleset()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Determine Approval ruleset object that should be used based on the configuration
                  settings for the transaction.  
                  
                  Those transactions that use a StagedData/CI design will have a value in the 
                  "ALLOW_DB_UPDT" field on WF_HR_TRANS.  Those that do not use Component Interfaces
                  should have a blank in this field. CI/Staged Data design is determined based on 
                  the existance of this value.
************************************************************************************************/
Function GetBPRuleset(&TransactionBind As string);
   GetConfigOption();
   
   
   &RSBPRuleset = CreateRowset(Record.SS_PROC_RULES);
   &RSBPRuleset.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION = :2", &TransactionBind, &ConfigOption);
   &BPRuleset = &RSBPRuleset.GetRow(1).GetRecord(Record.SS_PROC_RULES).GetField(Field.APPR_RULE_SET).Value;
   
   If All(&DBUpdateFlg) And
         &TransactionBind <> "DEFAULT" Then;
      If &ConfigOption = "1" Or
            &ConfigOption = "2" Then;
         GetBPAdminStep();
      End-If;
   End-If;
End-Function;

Function GetCIRuleset(&TransactionBind As string);
   
   &RSCIRuleset = CreateRowset(Record.SS_PROC_RULES);
   &RSCIRuleset.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION = :2", &TransactionBind, "5");
   &CIRuleset = &RSCIRuleset.GetRow(1).GetRecord(Record.SS_PROC_RULES).GetField(Field.APPR_RULE_SET).Value;
   
   &RSCIRulesetOverride = CreateRowset(Record.SS_PROC_RULES);
   &RSCIRulesetOverride.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION = :2", &TransactionName, "5");
   &CIRulesetOverride = &RSCIRulesetOverride.GetRow(1).GetRecord(Record.SS_PROC_RULES).GetField(Field.APPR_RULE_SET).Value;
   
   If All(&CIRulesetOverride) Then;
      &CIRuleset = &CIRulesetOverride;
   Else;
      &CIRuleset = &CIRuleset;
   End-If;
End-Function;


/************************************************************************************************
        Function: GetVAApprovers()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Determine Process Folks by reading the SQL objects/attributes found in the Approval
                  Ruleset configured for the transaction.   This is a wrapper to a Tools-owned 
                  function that builds the ProcessFolks Rowset.                
 ************************************************************************************************/
Function GetVAApprovers(&strApprRuleSet As string, &rsRuleContext As Rowset, &rsResultSet As Rowset) Returns boolean;
   
   &strRecord = "APPR_USERLIST";
   &rsResultSet = CreateRowset(Record.APPR_USERLIST);
   Return GetApprovers(&strApprRuleSet, &rsRuleContext, &rsResultSet, &strRecord);
   
End-Function;

/************************************************************************************************
        Function: AddAlternatesToProcess()
         Returns: Void  
 Input Arguments: &Rowset
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Inserts Alternates to the ProcessDtlRowset
************************************************************************************************/

Function AddAlternatesToProcess(&row As Row, &RowRecordName As string, &RS As Rowset);
   &RSRecName = "Record." | &RowRecordName;
   &LookForAlt = True;
   &InsertAlt = True;
   &ThisAltStep = &row.GetRecord(@&RSRecName).GetField(Field.PROCESS_STEP).Value;
   &is_alternate = &row.GetRecord(@&RSRecName).GetField(Field.IS_ALTERNATE).Value;
   If &ThisAltStep = &LastAltStep And
         &LastAltStepBoo = True Then;
      &LookForAlt = False;
   End-If;
   If &is_alternate = True Then;
      &LookForAlt = False;
   End-If;
   If &LookForAlt = True Then;
      &ThisRoleUser = &row.GetRecord(@&RSRecName).GetField(Field.ROLEUSER).Value;
      &RoleUserAltFound = LookForAlternate(&ThisRoleUser, "", &RSAlternate);
      If &RoleUserAltFound = True Then;
         /*see if alternate was already added at another point of notification process*/
         &AltRoleUserID = &RSAlternate.GetRow(1).GetRecord(Record.PSROLEXLATOPRVW).GetField(Field.ROLEUSER_ALT).Value;
         For &a = 1 To &RS.ActiveRowCount;
            &ProcDtlRoleUserID = &RS.GetRow(&a).GetRecord(@&RSRecName).GetField(Field.ROLEUSER).Value;
            If &ProcDtlRoleUserID = &AltRoleUserID Then;
               &ProcDtlStep = &RS.GetRow(&a).GetRecord(@&RSRecName).GetField(Field.PROCESS_STEP).Value;
               If &ThisAltStep = &ProcDtlStep Then;
                  &InsertAlt = False;
                  Break;
               End-If;
            End-If;
         End-For;
         If &InsertAlt = True Then;
            &RSProcDtlArc = &RSProcDtl.ActiveRowCount;
            &RSProcDtl.InsertRow(&RSProcDtlArc);
            &RSProcDtlRecObj = &row.GetRecord(@&RSRecName);
            &RSProcDtlRecObjAlt = &RSProcDtl.GetRow(&RSProcDtlArc + 1).GetRecord(@&RSProcDtlRec);
            &RSProcDtlRecObj.CopyFieldsTo(&RSProcDtlRecObjAlt);
            &RSProcDtlRecObjAlt.ROLEUSER.Value = &AltRoleUserID;
            &SQL = GetSQL(SQL.WF_GET_USER_EMPLID, &RSProcDtlRecObjAlt.ROLEUSER.Value);
            If &SQL.Status = 0 Then
               If &SQL.Fetch(&RoleUser_Emplid) Then
                  &SQL.Close();
               End-If;
            End-If;
            &RSProcDtlRecObjAlt.ROLEUSER_EMPLID.Value = &RoleUser_Emplid;
            &RSProcDtlRecObjAlt.COMMENTS.Value = "";
            &RSProcDtlRecObjAlt.PROCESS_ACTION.Value = " ";
            &RSProcDtlRecObjAlt.PROCESS_ACTION_DT.Value = "";
            &RSProcDtlRecObjAlt.is_alternate.Value = 1;
         End-If;
      End-If;
   End-If;
   &LastAltStep = &row.GetRecord(@&RSRecName).GetField(Field.PROCESS_STEP).Value;
   &LastAltStepBoo = &is_alternate;
End-Function;

/************************************************************************************************
        Function: InsertOriginator()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Loads current user into the first row of the process DTL rowset.
************************************************************************************************/

Function InsertOriginator();
   
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.TRANSACTION_NAME).Value = &TransactionName;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_GRP_ID).Value = &RSEditRow.GetRecord(@&RSEditRec).GetField(Field.SS_GRP_ID).Value;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_TRANS_ID).Value = &RSEditRow.GetRecord(@&RSEditRec).GetField(Field.SS_TRANS_ID).Value;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_PROCESS_CYCLE).Value = 1;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_PATH).Value = "A";
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value = 1;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION).Value = "S";
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_ROLETYPE).Value = "ORG";
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.ROLEUSER_EMPLID).Value = %EmployeeId;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.ROLEUSER).Value = %UserId;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION_DT).Value = %Date;
   /*Start Bug:14811973*/
   rem &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.ROLENAME).Value = "Originator";
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.ROLENAME).Value = MsgGetText(18032, 674, "Message Not Found");
   /*End Bug:14811973*/
   
   &RSProcDtlRow = &RSProcDtl.GetRow(&row);
   AddAlternatesToProcess(&RSProcDtlRow, &RSProcDtlRecStr, &RSProcDtl);
End-Function;

/************************************************************************************************
        Function: SetProcessFolksValues()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: ************************************************************************************************/
Function SetProcessFolksValues(&Roleuser As string, &IsAlternate As boolean)
   &CurrProcStep = &RSProcParticipants.GetRow(&I).GetRecord(Record.APPR_USERLIST).GetField(Field.APPR_STEP).Value;
   &CurrProcPath = &RSProcParticipants.GetRow(&I).GetRecord(Record.APPR_USERLIST).GetField(Field.APPR_PATH).Value;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.TRANSACTION_NAME).Value = &TransactionName;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_GRP_ID).Value = &RSEditRow.GetRecord(@&RSEditRec).GetField(Field.SS_GRP_ID).Value;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_TRANS_ID).Value = &RSEditRow.GetRecord(@&RSEditRec).GetField(Field.SS_TRANS_ID).Value;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_PROCESS_CYCLE).Value = 1;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_PATH).Value = &RSProcParticipants.GetRow(&I).GetRecord(Record.APPR_USERLIST).GetField(Field.APPR_PATH).Value;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value = &CurrProcStep + 1;
   If &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value = 2 Then;
      &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.CURRENT_STEP).Value = 1;
   End-If;
   If All(&BPAdminStep) Then;
      If (&CurrProcStep = &BPAdminStep And
            &CurrProcPath = &BPAdminPath) Then;
         &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_ROLETYPE).Value = "ADM";
      Else;
         If (&CurrProcStep > &BPAdminStep) Then;
            &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_ROLETYPE).Value = "INP";
         Else;
            &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_ROLETYPE).Value = "APR";
            
         End-If;
      End-If;
   Else;
      &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_ROLETYPE).Value = "APR";
   End-If;
   If &IsAlternate = True Then;
      &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.IS_ALTERNATE).Value = 1;
   Else;
      &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.IS_ALTERNATE).Value = 0;
   End-If;
   &RoleName = &RSProcParticipants.GetRow(&I).GetRecord(Record.APPR_USERLIST).GetField(Field.ROLENAME).Value;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.ROLEUSER).Value = &Roleuser;
   &SQL = GetSQL(SQL.WF_GET_USER_EMPLID, &Roleuser);
   If &SQL.Status = 0 Then
      If &SQL.Fetch(&RoleUser_Emplid) Then
         &SQL.Close();
      End-If;
   End-If;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.ROLEUSER_EMPLID).Value = &RoleUser_Emplid;
   &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.ROLENAME).Value = &RoleName;
End-Function;

/************************************************************************************************
        Function: GetOtherProcessFolks()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: ************************************************************************************************/
Function GetOtherProcessFolks();
   &RSProcParticipantsARC = &RSProcParticipants.ActiveRowCount;
   &row = &RSProcDtl.ActiveRowCount;
   For &I = 1 To &RSProcParticipantsARC;
      &RSProcDtl.InsertRow(&row);
      &row = &row + 1;
      &Roleuser = &RSProcParticipants.GetRow(&I).GetRecord(Record.APPR_USERLIST).GetField(Field.ROLEUSER).Value;
      SetProcessFolksValues(&Roleuser, False);
      /*******************************************************************/
      /*only find alternate roleuser for the 1st approver in process dtl.*/
      /*all other alternate roleusers should be identified incrementally,*/
      /*and only when one of the original process detail folks is the    */
      /*being notified in the process                                    */
      /*******************************************************************/
      If &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_ROLETYPE).Value = "APR" Then;
         AddAlternatesToProcess(&RSProcDtl.GetRow(&row), &RSProcDtl.DBRecordName, &RSProcDtl);
      End-If;
      
   End-For;
End-Function;

/************************************************************************************************
        Function: GetCIAdminFolks()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: ************************************************************************************************/
Function GetCIAdminFolks();
   
   &RSProcParticipantsARC = &RSProcParticipants.ActiveRowCount;
   &row = &RSProcDtl.ActiveRowCount;
   
   For &I = 1 To &RSProcParticipantsARC;
      &RSProcDtl.InsertRow(&row);
      &row = &row + 1;
      &Roleuser = &RSProcParticipants.GetRow(&I).GetRecord(Record.APPR_USERLIST).GetField(Field.ROLEUSER).Value;
      SetProcessFolksValues(&Roleuser, False);
      
      &RSProcDtl.GetRow(&row).GetRecord(@&RSProcDtlRec).GetField(Field.SS_ROLETYPE).Value = "ADM";
      
   End-For;
End-Function;

/************************************************************************************************
        Function: PopulateApprErrorFolks()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Function reads the approval ruleset configured for the transaction.  Then, run
                  Tools owned "GetVAApprovers" function to determine process participants.  Roleusers
                  involved in the process are inserted to &RSProcParticipants after the originator 
                  is entered in row 1.
************************************************************************************************/
Function PopulateApprErrorFolks();
   
   
   rem For &J = 1 To &RSEdit.ActiveRowCount;
   
   rem &row = 1;
   rem &RSEditRow = &RSEdit.GetRow(&J);
   rem &RSProcDtl = &RSEditRow.GetRowset(@&RSProcDtlScroll);
   
   rem      InsertOriginator();
   
   GetCIRuleset(&TransactionName);
   &bool = GetVAApprovers(&CIRuleset, GetLevel0(), &RSProcParticipants);
   
   GetCIAdminFolks();
   
   rem   End-For;
   
   &SortRec = "SS_PROCESS_DTL";
   &Sortfield1 = &SortRec | ".PROCESS_STEP";
   &Sortfield2 = &SortRec | ".ROLEUSER";
   &RSProcDtl.Sort(@&Sortfield1, "A", @&Sortfield2, "A");
End-Function;

/************************************************************************************************
        Function: PopulateProcessFolks()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Function reads the approval ruleset configured for the transaction.  Then, run
                  Tools owned "GetVAApprovers" function to determine process participants.  Roleusers
                  involved in the process are inserted to &RSProcParticipants after the originator 
                  is entered in row 1.
************************************************************************************************/
Function PopulateProcessFolks();
   TransSpecificProcess(&TransactionName, "GetBPRuleSetStart", &ComponentUse, &RunNextFrameworkCode);
   
   If &RunNextFrameworkCode = True Then;
      GetBPRuleset(&TransactionName);
   End-If;
   
   If None(&DBUpdateFlg) Then;
      GetBPAdminStep();
   End-If;
   
   For &J = 1 To &RSEdit.ActiveRowCount;
      &row = 1;
      &RSEditRow = &RSEdit.GetRow(&J);
      &RSProcDtl = &RSEditRow.GetRowset(@&RSProcDtlScroll);
      InsertOriginator();
      
      If &ApprProcError = False Then
         If All(&BPRuleset) Then;
            &bool = GetVAApprovers(&BPRuleset, GetLevel0(), &RSProcParticipants);
            If All(&BPRuleset) Then;
               GetOtherProcessFolks();
            End-If;
         End-If;
         
         &MoreProcFolksFound = False;
         
         If &RSProcDtl.ActiveRowCount > 1 Then
            &MoreProcFolksFound = True;
         End-If;
      Else;
         rem   PopulateApprErrorFolks();
         GetCIRuleset(&TransactionName);
         &bool = GetVAApprovers(&CIRuleset, GetLevel0(), &RSProcParticipants);
         
         GetCIAdminFolks();
      End-If;
   End-For;
   
   &SortRec = "SS_PROCESS_DTL";
   &Sortfield1 = &SortRec | ".PROCESS_STEP";
   &Sortfield2 = &SortRec | ".ROLEUSER";
   &RSProcDtl.Sort(@&Sortfield1, "A", @&Sortfield2, "A");
End-Function;

/************************************************************************************************
        Function: SaveProcessAction()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Save approve or deny "process action" entered by approver.  Make the next step 
                  current if any more process steps are found after the current step.
************************************************************************************************/
Function SaveProcessAction();
   For &I = 1 To &RSEdit.ActiveRowCount;
      /*****************************************************************************************/
      /*set the current step = 0, and the next step (if it's not the last step) =1             */
      /*****************************************************************************************/
      &RSProcDtl = &RSEdit.GetRow(&I).GetRowset(@&RSProcDtlScroll);
      &RSProcCmnts = &RSEdit.GetRow(&I).GetRowset(Scroll.SS_PROC_CMNTS);
      &RSProcFolks = &RSEdit.GetRow(&I).GetRowset(Scroll.SS_PROC_FOLKS);
      &RSProcCmntsARC = &RSProcCmnts.ActiveRowCount;
      &RSProcDtlRow = &RSProcDtl.GetRow(1);
      Evaluate &ComponentUse
      When "ADM"
         If &CIStgDesign = True Then;
            &AdmUpdChoice = GetLevel0().GetRow(1).GetRecord(Record.SS_ERR_WRK).GetField(Field.SS_ADM_UPD_CHOICES).Value;
            &AdmPosnChoice = GetLevel0().GetRow(1).GetRecord(Record.SS_ERR_WRK).GetField(Field.SS_ADM_POS_CHOICES).Value;
            &AdmOverride = GetLevel0().GetRow(1).GetRecord(Record.SS_ERR_WRK).GetField(Field.SS_ADM_OVERRIDE).Value;
            If All(&AdmUpdChoice) Then;
               &ProcessAction = &AdmUpdChoice;
               &AdminAction = &AdmUpdChoice;
               &AdmDontCallCI = False;
               If &AdminAction = "M" Then;
                  &AdmDontCallCI = True;
                  &AdminAction = "S";
                  &ProcessAction = "A";
               End-If;
            End-If;
            If All(&AdmPosnChoice) Then;
               &ProcessAction = &AdmPosnChoice;
               &AdminAction = &AdmPosnChoice;
               &AdmDontCallCI = True;
            End-If;
            If All(&AdmOverride) Then;
               &AdminAction = &AdmOverride;
               &ProcessAction = &AdmOverride;
               &AdmDontCallCI = True;
            End-If;
            If &ProcessAction = "S" Then;
               &ProcessAction = "A";
            End-If;
            If &ProcessAction = "M" Then;
               &ProcessAction = "A";
            End-If;
            If &ProcessAction = "C" Then;
               &ProcessAction = "D";
            End-If;
            &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.SS_STAT_INDICATOR).Value = &AdminAction;
         Else;
            &ProcessAction = &RSProcDtl.GetRow(1).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION).Value;
            &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.SS_STAT_INDICATOR).Value = &ProcessAction;
         End-If;
      When-Other;
         &ProcessAction = &RSProcDtl.GetRow(1).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION).Value;
      End-Evaluate;
      &UserComments = &RSProcDtl.GetRow(1).GetRecord(@&RSProcDtlRec).GetField(Field.COMMENTS).Value;
      &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.LAST_PROC_ACTION).Value = &ProcessAction;
      /******************************************************************************************/
      /*make next step current                                                                  */
      /******************************************************************************************/
      If &AdminPerfOverride = False Then;
         For &J = 1 To &RSProcDtl.ActiveRowCount;
            If &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value = &StepWereOn Then;
               &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.CURRENT_STEP).Value = 0;
               If &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.ROLEUSER).Value = %UserId Then;
                  &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION_DT).Value = %Date;
                  &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION).Value = &ProcessAction;
                  &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.COMMENTS).Value = &UserComments;
               Else;
                  &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION).Value = "";
                  &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION_DT).Value = "";
                  &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.COMMENTS).Value = "";
               End-If;
            Else;
               &LastRowStepWereOn = &J - 1;
               Break
            End-If;
         End-For;
         &CurrStep = &RSProcDtl.GetRow(1).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value;
         &LastStep = &RSProcDtl.GetRow(&RSProcDtl.ActiveRowCount).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value;
         &MoreProcFolksFound = False;
         If &LastStep > &CurrStep Then
            &NextSSRoleType = &RSProcDtl.GetRow(&LastRowStepWereOn + 1).GetRecord(@&RSProcDtlRec).GetField(Field.SS_ROLETYPE).Value;
            If &NextSSRoleType = "APR" Or
                  &NextSSRoleType = "ADM" Then;
               &MoreProcFolksFound = True;
               If &ProcessAction <> "D" Then;
                  For &K = &LastRowStepWereOn To &RSProcDtl.ActiveRowCount;
                     If &RSProcDtl.GetRow(&K).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value = &StepWereOn + 1 Then;
                        &RSProcDtl.GetRow(&K).GetRecord(@&RSProcDtlRec).GetField(Field.CURRENT_STEP).Value = 1;
                     End-If;
                  End-For;
                  If &NextSSRoleType = "ADM" Then;
                     &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.SS_STAT_INDICATOR).Value = "M";
                  End-If;
               End-If;
            End-If;
         End-If;
         /******************************************************************************************/
         /*update key status indicator                                                             */
         /******************************************************************************************/
         If &ProcessAction = "D" Then;
            &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.SS_STAT_INDICATOR).Value = &ProcessAction;
         End-If;
         /******************************************************************************************/
         /*check for alternates                                                                    */
         /******************************************************************************************/
         For &f = 1 To &RSProcFolks.ActiveRowCount;
            AddAlternatesToProcess(&RSProcFolks.GetRow(&f), &RSProcFolks.DBRecordName, &RSProcFolks);
         End-For;
      End-If;
   End-For;
   
   &SortRec = "SS_PROCESS_DTL";
   &Sortfield1 = &SortRec | ".PROCESS_STEP";
   &Sortfield2 = &SortRec | ".ROLEUSER";
   &RSProcDtl.Sort(@&Sortfield1, "A", @&Sortfield2, "A");
End-Function;

/************************************************************************************************
        Function: CheckApprover()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Checks if an approver has been assigned to the field DERIVED_SS.EMPLID_TO1.  
                  There is an extra check to see if the assigned approver is setup correctly 
                  in the table PSROLUSER.  If either of these checks is false we set the component
                  variable &AppPrcError = True.  This tells processing that an error has occured 
                  trying to establish an Approver.************************************************************************************************/
Function CheckApprover();
   
   &ApprProcError = False;
   
   If All(DERIVED_SS.EMPLID_TO1) Then
      InRoleUser(DERIVED_SS.EMPLID_TO1, "Manager", &ManagerPass);
      
      If &ManagerPass = False Then
         DERIVED_SS.EMPLID_TO1 = "";
      End-If;
   End-If;
   
   If None(DERIVED_SS.EMPLID_TO1) Then
      &ApprProcError = True;
      
   End-If;
   
End-Function;

/************************************************************************************************
        Function: EnforceProcessAction()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Checks if an approver entered a process action.  If no change is found, an error is issued.  ************************************************************************************************/
Function EnforceProcessAction();
   
   For &I = 1 To &RSEdit.ActiveRowCount;
      &RSProcDtl = &RSEdit.GetRow(&I).GetRowset(@&RSProcDtlScroll);
      &ProcDtlRows = &RSProcDtl.ActiveRowCount;
      
      &Action = &RSProcDtl(1).SS_PROCESS_DTL.PROCESS_ACTION.Value;
      
      If None(&Action) Then
         &Emplid = &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.EMPLID).Value;
         &CursorRec = &RSProcDtlRecStr;
         &CursorRecField = &CursorRec | ".COMMENTS";
         SetCursorPos(%Page, @&RSEditRec, &I, @&RSProcDtlRec, 1, @&CursorRecField);
         
         If %Component = "HR_SALCHANGE_APR" Then /* Need to refresh mouseover for Ad Hoc Salary Approval */
            
            DERIVED_WCS_POP.EMPLID = &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.EMPLID).Value;
            DERIVED_WCS_POP.EMPL_RCD = &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.EMPL_RCD).Value;
            DERIVED_WCS_POP.NAME_DISPLAY = get_person_name(DERIVED_WCS_POP.EMPLID, "", "", "");
            
            For &K = 1 To &EmployeeRS.ActiveRowCount;
               If &EmployeeRS(&K).DERIVED_ADHC_SS.EMPLID.Value = DERIVED_WCS_POP.EMPLID And
                     &EmployeeRS(&K).DERIVED_ADHC_SS.EMPL_RCD.Value = DERIVED_WCS_POP.EMPL_RCD Then
                  &CurrentRow = &K;
                  Break;
               End-If;
            End-For;
            
            DERIVED_SS.DESCR20 = MsgGetText(1120, 1480, "Message Not Found.", &CurrentRow, &RSEdit.ActiveRowCount);
            
            &POP_UP_PAGE = "HR_MO_DSP_P_2_POP";
            
            Local HR_MO_COMMON:SETUP:APP_SETUP &COMP_SETUP_DATA;
            &COMP_SETUP_DATA = create HR_MO_COMMON:SETUP:APP_SETUP(%Component, %Market);
         End-If;
         
         Error MsgGetText(1120, 1014, "Approval for Employee ID#" | &Emplid | " is missing.", &Emplid);
      End-If;
   End-For;
End-Function;

/************************************************************************************************
        Function: SavePage()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Main function called from SavePreChange event on HR_SS_ACTIVATE.  Subprocess called
                  from this main save routine are described at the function level.
********************************************************************************************/

Function SavePage();
   &Pagename = "Page." | %Page;
   &ReturnPanel = &Pagename;
   
   TransSpecificProcess(&TransactionName, "SavePageStart", &ComponentUse, &RunNextFrameworkCode);
   
   If &RunNextFrameworkCode = True Then;
      Evaluate &ComponentUse
      When "ORG";
         AssignKeys();
         
         If &ConfigOption = "1" Or
               &ConfigOption = "3" Then;
            CheckApprover();
         Else
            &ApprProcError = False;
         End-If;
         
         PopulateProcessFolks();
         &StepWereOn = 1;
         &CurrStep = 1;
         
      When "APR";
         EnforceProcessAction();
         SaveProcessAction();
         
      When "ADM";
         SaveProcessAction();
      End-Evaluate;
   End-If;
   
   TransSpecificProcess(&TransactionName, "SavePageEnd", &ComponentUse, &RunNextFrameworkCode);
   
End-Function;

/************************************************************************************************
        Function: MoveEditValsToTemp()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Copy data entered by user into temporary detail-related scrolls 
                  (e.g., process folks, process comments) that present summary-level process 
                  information to the user.
************************************************************************************************/
Function MoveEditValsToTemp();
   For &I = 1 To &RSEdit.ActiveRowCount
      &RSProcDtl = &RSEdit.GetRow(&I).GetRowset(@&RSProcDtlScroll);
      &RSProcFolks = &RSEdit.GetRow(&I).GetRowset(Scroll.SS_PROC_FOLKS);
      If &ComponentUse = "ORG" Then
         /*******************************************************************************/
         /*   on ORG component, need to evaluate each row in the process dtl and make   */
         /*   sure to only copy those rows that are not alternate role users up to temp */
         /*******************************************************************************/
         &Loop1 = "Y";
         &InsertRow = 1;
         &RSProcCmnts = &RSEdit.GetRow(&I).GetRowset(Scroll.SS_PROC_CMNTS);
         For &J = 1 To &RSProcDtl.ActiveRowCount;
            If &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.IS_ALTERNATE).Value = 0 Then;
               If All(&RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.ROLEUSER_EMPLID).Value) Then;
                  If &Loop1 <> "Y" Then;
                     &RSProcFolks.InsertRow(&InsertRow);
                     &InsertRow = &InsertRow + 1;
                  End-If;
                  &RSProcDtlRecObj = &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec);
                  &RSProcFolksRecOBj = &RSProcFolks.GetRow(&InsertRow).GetRecord(Record.SS_PROC_FOLKS);
                  &RSProcDtlRecObj.CopyFieldsTo(&RSProcFolksRecOBj);
                  &Loop1 = "N";
               End-If;
            End-If;
            
         End-For;
      Else;
         /*******************************************************************************/
         /*  on ADM and APR component, use record copy to update the specific row       */
         /*  changed to the comment temp scroll.                                        */
         /*******************************************************************************/
         For &J = 1 To &RSProcDtl.ActiveRowCount;
            &ProcDtlStep = &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value;
            &ProcDtlRoleUser = &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.ROLEUSER).Value;
            If &ProcDtlStep = &StepWereOn And
                  &ProcDtlRoleUser = %UserId Then;
               &ProcDtlAction = &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION).Value;
               &ProcDtlActionDt = &RSProcDtl.GetRow(&J).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION_DT).Value;
               Break;
            End-If;
         End-For;
         For &J = 1 To &RSProcFolks.ActiveRowCount;
            &ProcFolkStep = &RSProcFolks.GetRow(&J).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.PROCESS_STEP).Value;
            &ProcFolkRoleUser = &RSProcFolks.GetRow(&J).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.ROLEUSER).Value;
            If &ProcDtlStep = &StepWereOn And
                  &ProcFolkRoleUser = %UserId Then;
               &RSProcFolks.GetRow(&J).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.PROCESS_ACTION).Value = &ProcDtlAction;
               &RSProcFolks.GetRow(&J).GetRecord(Record.SS_PROC_FOLKS).GetField(Field.PROCESS_ACTION_DT).Value = &ProcDtlActionDt;
               Break;
            End-If;
         End-For;
         
      End-If;
   End-For;
   &RSProcFolks.Sort(SS_PROC_FOLKS.PROCESS_STEP, "A", SS_PROC_FOLKS.IS_ALTERNATE, "A");
End-Function;

/************************************************************************************************
        Function: RedistributeRows()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: After approval process action is saved, loop through all rows found in the RSEdit 
                  Rowset.  "Swap" each row (based on appr or deny process action entered by user) 
                  to the appropriate &RSTmp (SBP) scroll area.
**********************************************************************************************/

Function ReDistributeRows();
   
   &RSEditArc = &RSEdit.ActiveRowCount;
   &RSApprTmpArc = &RSApprTmp.ActiveRowCount;
   &RSDenyTmpArc = &RSDenyTmp.ActiveRowCount;
   
   If &ApprRowFound = False Then;
      &ApprInsReq = False;
      &ApprRow = 1;
   Else;
      &ApprInsReq = True;
      &ApprRow = &ApprTmpArc;
   End-If;
   
   If &DenyRowFound = False Then;
      &DenyInsReq = False;
      &DenyRow = 1;
   Else;
      &DenyInsReq = True;
      &DenyRow = &DenyTmpArc;
   End-If;
   
   &EditRowFound = False;
   
   
   For &I = 1 To &RSEdit.ActiveRowCount;
      &RSEditRow = &RSEdit.GetRow(&I);
      &RSProcDtl = &RSEdit.GetRow(&I).GetRowset(@&RSProcDtlScroll);
      &RSProcCmnts = &RSEdit.GetRow(&I).GetRowset(Scroll.SS_PROC_CMNTS);
      &RSProcFolks = &RSEdit.GetRow(&I).GetRowset(Scroll.SS_PROC_FOLKS);
      &RSProcDtlArc = &RSProcDtl.ActiveRowCount;
      &ProcessAction = &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.LAST_PROC_ACTION).Value;
      If &ProcessAction = "A" Then;
         If &ApprInsReq Then;
            &RSApprTmp.InsertRow(&ApprRow);
            &ApprRow = &ApprRow + 1;
         End-If;
         &RSEditRow.CopyTo(&RSApprTmp.GetRow(&ApprRow));
         &RSProcCmntsAppr = &RSApprTmp.GetRow(&ApprRow).GetRowset(Scroll.SS_PROC_CMNTS);
         &RSProcFolksAppr = &RSApprTmp.GetRow(&ApprRow).GetRowset(Scroll.SS_PROC_FOLKS);
         &RSProcCmnts.CopyTo(&RSProcCmntsAppr);
         &ApprInsReq = True;
         &ApprRowFound = True;
      End-If;
      If &ProcessAction = "D" Then;
         If &DenyInsReq Then;
            &RSDenyTmp.InsertRow(&DenyRow);
            &DenyRow = &DenyRow + 1;
         End-If;
         &RSEditRow.CopyTo(&RSDenyTmp.GetRow(&DenyRow));
         &RSProcCmntsDeny = &RSDenyTmp.GetRow(&DenyRow).GetRowset(Scroll.SS_PROC_CMNTS);
         &RSProcFolksDeny = &RSDenyTmp.GetRow(&DenyRow).GetRowset(Scroll.SS_PROC_FOLKS);
         &RSProcCmnts.CopyTo(&RSProcCmntsDeny);
         &DenyInsReq = True;
         &DenyRowFound = True;
      End-If;
   End-For;
   &RSEdit.Flush();
End-Function;

/************************************************************************************************
        Function: RunSavePostChange()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 02/27/2002
Output Arguments: <none>
      Processing: If Component Interface was called to update the database, transfer user to the
                  appropriate confirmation page.  
                - If CI encountered an error, transfer to EO_ERR_CONFIRM and present appropriate error
                  message to the user.
                - If CI encountered a warning, transfer to user to EO_SAVE_CONFIRM page.   
                  (standard methodology: do not present warning messages to user...save was technically
		    successful anyway.)
                - If CI encountered future rows, transfer to user to EO_SAVE_CONFIRM page.   
                - If CI does not encounter a warning, transfer to user to EO_SAVE_CONFIRM page.   
                - If CI is not called because it is not appropriate for the current step, 
                  transfer the user to EO_SUBMIT_CONFIRM page.
 ************************************************************************************************/

Function RunSavePostChange();
   TransSpecificProcess(&TransactionName, "SavePostChangeStart", &ComponentUse, &RunNextFrameworkCode);
   If &AdminPerfOverride = False Then;
      MoveEditValsToTemp();
   End-If;
   HideAdminsWithNoEmplid();
   &CurrentPage = %Page;
   
   &Pagename = "Page." | &CurrentPage;
   &ReturnPage = &Pagename;
   
   Evaluate &ComponentUse
   When "ORG"
      If &ApprProcError = False Then
         TransSpecificProcess(&TransactionName, "SavePostChangeEnd", &ComponentUse, &RunNextFrameworkCode);
         If &Call_CI = False Then;
            DisplaySubmitConfirm();
         Else;
            DisplaySaveConfirm();
         End-If;
      Else
         TransSpecificProcess(&TransactionName, "SavePostChangeEnd", &ComponentUse, &RunNextFrameworkCode);
         DisplayErrorConfirm();
      End-If;
   When "APR"
      ReDistributeRows();
   When "APR"
      TransSpecificProcess(&TransactionName, "SavePostChangeEnd", &ComponentUse, &RunNextFrameworkCode);
      SetSectionVisibleProp("P");
      If &CI_Called = False Then;
         DisplaySubmitConfirm();
      Else;
         DisplaySaveConfirm();
      End-If;
   When "ADM"
      SetSectionVisibleProp("P");
      If &CIStgDesign = True Then;
         SetAdminSBPFunctionality();
      End-If;
      TransSpecificProcess(&TransactionName, "SavePostChangeEnd", &ComponentUse, &RunNextFrameworkCode);
      DisplaySaveConfirm();
   End-Evaluate;
   
   /************************************************************************************************
   DisplayErrorConfirm();
                  note:  functions will be wrapped with the appropriate conditional logic to present
                  the appropriate page to the user.  The above logic is paired-down for demo purposes.
 ************************************************************************************************/
End-Function;

/************************************************************************************************
        Function: TransferToPage()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 02/27/2002
Output Arguments: <none>
      Processing: Prepare original page so that it display only before user transfers back.
                - Hide all save/submit related buttons to prevent user from saving transaction again.
                - Present appropriate message on page that reconfirms that the transaction was saved
                  or submitted.
                - if componenttype is administrator, show error and warning link.
                - Finally, offically transfer user to page stored in component ReturnPage string.
 ************************************************************************************************/
Function TransferToPage();
   &PageObj = GetPage(@&ReturnPage);
   &PageObj.DisplayOnly = True;
   
   GetPageText("P");
   SetSectionVisibleProp("P");
   
   TransferPage(@&ReturnPage);
End-Function;

/************************************************************************************************
        Function: ApproveDenyAll()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Set all rows in RSProcDtl for each key value occurence found in &RSEdit to whatever
                  process action (&requestedAction) is passed in as parameter.  Called from field 
                  change from buttons located on SS_PROC_BTNS_SBP.
************************************************************************************************/

Function ApproveDenyAll(&requestedAction);
   For &I = 1 To &RSEdit.ActiveRowCount;
      &RSProcDtl = &RSEdit.GetRow(&I).GetRowset(@&RSProcDtlScroll);
      &RSProcDtl.GetRow(1).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_ACTION).Value = &requestedAction;
   End-For;
End-Function;

/************************************************************************************************
        Function: GetEmailBinds()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Provides values to binds for message catalog etnries that construct self service 
                  emails.

                  This function expects appropriate page buffer references in SS_BIND_GRP.  
                  Page designs for framework transactions must have all the fields that are marked
                  "DEFAULT" in this control table available on the page... in the buffer references 
                  as described in control table.  Addtional transation-specific fields can be added 
                  to this table to control page behavior, beyond the default set.

                  This function will operate on message catalog entries which have <=5 binds.
************************************************************************************************/

Function GetEmailBinds(&Field, &MsgSetNbr, &MsgNbr);
   
   &RSEmailBinds = CreateRowset(Record.SS_BIND_GRP);
   &RSEmailBinds.Fill("WHERE MESSAGE_SET_NBR=:1 and MESSAGE_NBR=:2", &MsgSetNbr, &MsgNbr);
   
   &NumBinds = &RSEmailBinds.ActiveRowCount;
   
   &ValChk = &RSEmailBinds.GetRow(1).GetRecord(Record.SS_BIND_GRP).GetField(Field.MESSAGE_SET_NBR).Value;
   
   If All(&ValChk) Then;
      &NumBinds = &RSEmailBinds.ActiveRowCount;
   Else;
      &NumBinds = 0;
   End-If;
   
   If All(&ValChk) Then;
      For &I = 1 To &NumBinds;
         &Level = &RSEmailBinds.GetRow(&I).GetRecord(Record.SS_BIND_GRP).GetField(Field.LEVELNUM).Value;
         &RecName = &RSEmailBinds.GetRow(&I).GetRecord(Record.SS_BIND_GRP).GetField(Field.RECNAME).Value;
         &FieldName = &RSEmailBinds.GetRow(&I).GetRecord(Record.SS_BIND_GRP).GetField(Field.FIELDNAME).Value;
         &RecNameObj = "Record." | &RSEmailBinds.GetRow(&I).GetRecord(Record.SS_BIND_GRP).GetField(Field.RECNAME).Value;
         &FieldNameObj = "Field." | &RSEmailBinds.GetRow(&I).GetRecord(Record.SS_BIND_GRP).GetField(Field.FIELDNAME).Value;
         &IsRelated = &RSEmailBinds.GetRow(&I).GetRecord(Record.SS_BIND_GRP).GetField(Field.IS_RELATED_REC_FLG).Value;
         
         Evaluate &Level
         When 0;
            &RS = GetLevel0();
         When 1;
            &RS = &RSEdit;
         When 2;
            &RS = &RSProcDtl;
         End-Evaluate;
         If &IsRelated = "Y" Then;
            &RelatedRec = &RSEmailBinds.GetRow(&I).GetRecord(Record.SS_BIND_GRP).GetField(Field.RELATED_RECNAME).Value;
            &RelatedFld = &RSEmailBinds.GetRow(&I).GetRecord(Record.SS_BIND_GRP).GetField(Field.RELATED_FIELDNAME).Value;
            &RelRecFld = &RelatedRec | "." | &RelatedFld;
            &ControlFld = &RS.GetRow(1).GetRecord(@&RecNameObj).GetField(@&FieldNameObj);
            &Bind = &ControlFld.GetRelated(@&RelRecFld).Value;
         Else;
            &Bind = &RS.GetRow(1).GetRecord(@&RecNameObj).GetField(@&FieldNameObj).Value;
         End-If;
         Evaluate &I
         When 1;
            &Bind1 = &Bind;
         When 2;
            &Bind2 = &Bind;
         When 3;
            &Bind3 = &Bind;
         When 4;
            &Bind4 = &Bind;
         When 5;
            &Bind5 = &Bind;
         End-Evaluate;
      End-For;
   End-If;
   &CurFldName = &Field.Name;
   If &CurFldName = "HR_EMAIL_SUBJECT" Then
      Evaluate &NumBinds
      When 0;
         &Field.Value = MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr);
      When 1;
         &Field.Value = MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1) | " sent to " | DERIVED_SS.ROLEUSER_TO;
      When 2;
         &Field.Value = MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1, &Bind2) | " sent to " | DERIVED_SS.ROLEUSER_TO;
      When 3;
         &Field.Value = MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1, &Bind2, &Bind3) | " sent to " | DERIVED_SS.ROLEUSER_TO;
      When 4;
         &Field.Value = MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1, &Bind2, &Bind3, &Bind4) | " sent to " | DERIVED_SS.ROLEUSER_TO;
      When 5;
         &Field.Value = MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1, &Bind2, &Bind3, &Bind4, &Bind5) | " sent to " | DERIVED_SS.ROLEUSER_TO;
      End-Evaluate;
   End-If;
   If &CurFldName = "HR_EMAIL_TEXT" Then
      rem &DebugMsgSet = &MsgSetNbr;
      rem &DebugMsgNbr = &MsgNbr;
      Evaluate &NumBinds
      When 0;
         &Field.Value = &Field.Value | MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr);
      When 1;
         &Field.Value = &Field.Value | MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1);
      When 2;
         &Field.Value = &Field.Value | MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1, &Bind2);
      When 3;
         &Field.Value = &Field.Value | MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1, &Bind2, &Bind3);
      When 4;
         &Field.Value = &Field.Value | MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1, &Bind2, &Bind3, &Bind4);
      When 5;
         &Field.Value = &Field.Value | MsgGetExplainText(&MsgSetNbr, &MsgNbr, "Message Not Found: Message Set Number " | &MsgSetNbr | ", Message Number " | &MsgNbr, &Bind1, &Bind2, &Bind3, &Bind4, &Bind5);
      End-Evaluate;
   End-If;
End-Function;

/************************************************************************************************
        Function: GenerateEmailURL()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Builds URL used in eMail notifications based on control data obtained from 
                  SS_BP_COMPS.
************************************************************************************************/
Function GenerateEmailURL();
   &EmailComponentUse = DERIVED_SS.SS_COMP_USE;
   
   /*If &SSRoleType = "APR" And
         &TransactionName = "HR_TRAIN_ENROLL" And
         &NotifyCompUse = "STS" Then;
      &TransNameBind = "HR_TRAIN_ENROLL_MGR";
   Else;
      &TransNameBind = &TransactionName;
   End-If;*/
   
   &TransNameBind = &TransactionName;
   
   &RSCompForURL = CreateRowset(Record.SS_BP_COMPS);
   &RSCompForURL.Fill("WHERE TRANSACTION_NAME=:1 and SS_COMP_USE= :2", &TransNameBind, &EmailComponentUse);
   &MenuforURL = &RSCompForURL.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.MENUNAME).Value;
   &CompforURL = &RSCompForURL.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.PNLGRPNAME).Value;
   &MarketforURL = &RSCompForURL.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.MARKET).Value;
   &PageforURL = &RSCompForURL.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.PNLNAME).Value;
   &ModeforURL = &RSCompForURL.GetRow(1).GetRecord(Record.SS_BP_COMPS).GetField(Field.ACCESS_MODE).Value;
   
   Evaluate DERIVED_SS.SS_COMP_USE
   When "APR"
   When "STS"
      &TransferKeyRec = CreateRecord(@&RSHdrRec);
      &TransferKeyRec.TRANSACTION_NAME.Value = &TransactionName;
      &TransferKeyRec.SS_GRP_ID.Value = &SSGrpID;
   When "ADM"
      &TransferKeyRec = CreateRecord(@&RSEditRec);
      &TransferKeyRec.TRANSACTION_NAME.Value = &TransactionName;
      &TransferKeyRec.SS_GRP_ID.Value = &SSGrpID;
      &TransferKeyRec.SS_TRANS_ID.Value = &SSTransID;
   End-Evaluate;
   
   
   /* Generate Link 8.4 */
   &Menu = "MENUNAME." | &MenuforURL;
   &Component = "COMPONENT." | &CompforURL;
   &EmailURL = GenerateComponentPortalURL(%Portal, %Node, @&Menu, &MarketforURL, @&Component, &PageforURL, &ModeforURL, &TransferKeyRec);
   If &CompforURL = "TRN_REQUEST_ADM" Then
      &EmailURL = &EmailURL | "&EMPLID=" | &Emplid;
   End-If;
   DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
   GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &URLMsgSetNbr, &URLMsgNbr);
   DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
   DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF | &EmailURL | &CRLF | &CRLF;
   
   rem   &Rest_of_URL = &Rest_of_URL | "&NoCrumbs=Y";
   rem   ViewURL(&Rest_of_URL, True);
   
End-Function;



/************************************************************************************************
        Function: BuildEmailSections()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: This function builds the portion of an E-mail message that lists
                  each transaction field and its value. It loops through all key value occurences
                  in &RSEdit and then appends the row to either &MsgLineSubmitArray, &MsgLineDenyArray
                  or &MsgLineApprArray so that like-approved, denied or submitted rows 
                  are all "batched together" in the email body text.

                  A message line is of the form:
                            Field Name Label            : Field Value ************************************************************************************************/
Function BuildEmailSections(&SSRoleType, &RoleUser, &StepWereOn);
   &CRLF = Char(13) | Char(10); /* Carriage Return / Line Feed */
   &RSEditArc = &RSEdit.ActiveRowCount;
   &n = 1;
   
   &SortRec = &RSEditRecStr;
   &Sortfield1 = &SortRec | ".LAST_PROC_ACTION";
   &Sortfield2 = &SortRec | ".SS_STAT_INDICATOR";
   &RSEdit.Sort(@&Sortfield1, "A", @&Sortfield2, "A");
   
   &FirstSubmitEmailLoop = "Y";
   &FirstDenyEmailLoop = "Y";
   &FirstApprEmailLoop = "Y";
   &FirstFutureEmailLoop = "Y";
   &FirstSuccessEmailLoop = "Y";
   &FirstWarnEmailLoop = "Y";
   &FirstErrWarnEmailLoop = "Y";
   &FirstErrorEmailLoop = "Y";
   
   For &n = 1 To &RSEditArc;
      &SSGrpID = &RSEdit.GetRow(&n).GetRecord(@&RSEditRec).GetField(Field.SS_GRP_ID).Value;
      &SSTransID = &RSEdit.GetRow(&n).GetRecord(@&RSEditRec).GetField(Field.SS_TRANS_ID).Value;
      &LastProcAction = &RSEdit.GetRow(&n).GetRecord(@&RSEditRec).GetField(Field.LAST_PROC_ACTION).Value;
      &SSStatIndicator = &RSEdit.GetRow(&n).GetRecord(@&RSEditRec).GetField(Field.SS_STAT_INDICATOR).Value;
      &SSFutureFlag = &RSEdit.GetRow(&n).GetRecord(@&RSEditRec).GetField(Field.SS_FUTURE_FLG).Value;
      &SSWarningFlag = &RSEdit.GetRow(&n).GetRecord(@&RSEditRec).GetField(Field.SS_WARNING_FLG).Value;
      &RSEditRecord = &RSEdit.GetRow(&n).GetRecord(@&RSEditRec);
      &RSTransDtl = &RSEdit.GetRow(&n).GetRowset(@&RSTransDtlScroll);
      &RSTransDtlRecord = &RSTransDtl.GetRow(1).GetRecord(@&RSTransDtlRec);
      
      Evaluate &LastProcAction
      When "S"
         &MsgSetNbrBind = &SubmitMsgSetNbr;
         &MsgNbrBind = &SubmitMsgNbr;
         &EmailGroup = &LastProcAction;
      When "A"
         &MsgSetNbrBind = &ApprMsgSetNbr;
         &MsgNbrBind = &ApprMsgNbr;
         &EmailGroup = &LastProcAction;
      When "D"
         &MsgSetNbrBind = &DenyMsgSetNbr;
         &MsgNbrBind = &DenyMsgNbr;
         &EmailGroup = &LastProcAction;
      End-Evaluate;
      
      Evaluate &SSRoleType
      When "ADM"
         Evaluate &SSStatIndicator
         When "S"
            &MsgSetNbrBind = &SuccessMsgSetNbr;
            &MsgNbrBind = &SuccessMsgNbr;
            &EmailGroup = "U";
         When "E"
            &MsgSetNbrBind = &ErrorMsgSetNbr;
            &MsgNbrBind = &ErrorMsgNbr;
            &EmailGroup = "E";
         When "B"
            &MsgSetNbrBind = &ErrWrnMsgSetNbr;
            &MsgNbrBind = &ErrWrnMsgNbr;
            &EmailGroup = "B";
         When "W"
            &MsgSetNbrBind = &WarningMsgSetNbr;
            &MsgNbrBind = &WarningMsgNbr;
            &EmailGroup = "W";
         End-Evaluate;
         
         If &SSFutureFlag = "Y" Then;
            &MsgSetNbrBind = &FutureMsgSetNbr;
            &MsgNbrBind = &FutureMsgNbr;
            &EmailGroup = "F";
         End-If;
      End-Evaluate;
      
      
      Evaluate &EmailGroup
      When "S"
         If &FirstSubmitEmailLoop = "Y" Then;
            GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &MsgSetNbrBind, &MsgNbrBind);
            &FirstSubmitEmailLoop = "N";
         End-If;
         &MsgLineSubmitArray = BuildEmailBody(&TransactionName, &RSEditRecord, &RSTransDtlRecord, &EmailGroup);
      When "A"
         If &FirstApprEmailLoop = "Y" Then;
            GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &MsgSetNbrBind, &MsgNbrBind);
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            &FirstApprEmailLoop = "N";
         End-If;
         &MsgLineApprArray = BuildEmailBody(&TransactionName, &RSEditRecord, &RSTransDtlRecord, &EmailGroup);
      When "D"
         If &FirstDenyEmailLoop = "Y" Then;
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &MsgSetNbrBind, &MsgNbrBind);
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            &FirstDenyEmailLoop = "N";
         End-If;
         &MsgLineDenyArray = BuildEmailBody(&TransactionName, &RSEditRecord, &RSTransDtlRecord, &EmailGroup);
      When "F"
         If &FirstFutureEmailLoop = "Y" Then;
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &MsgSetNbrBind, &MsgNbrBind);
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            &FirstFutureEmailLoop = "N";
         End-If;
         &MsgLineFutureArray = BuildEmailBody(&TransactionName, &RSEditRecord, &RSTransDtlRecord, &EmailGroup);
      When "U"
         If &FirstSuccessEmailLoop = "Y" Then;
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &MsgSetNbrBind, &MsgNbrBind);
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            &FirstSuccessEmailLoop = "N";
         End-If;
         &MsgLineSuccessArray = BuildEmailBody(&TransactionName, &RSEditRecord, &RSTransDtlRecord, &EmailGroup);
      When "W"
         If &FirstWarnEmailLoop = "Y" Then;
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &MsgSetNbrBind, &MsgNbrBind);
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            &FirstWarnEmailLoop = "N";
         End-If;
         &MsgLineWarnArray = BuildEmailBody(&TransactionName, &RSEditRecord, &RSTransDtlRecord, &EmailGroup);
      When "B"
         If &FirstErrWarnEmailLoop = "Y" Then;
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &MsgSetNbrBind, &MsgNbrBind);
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            &FirstErrWarnEmailLoop = "N";
         End-If;
         &MsgLineErrWarnArray = BuildEmailBody(&TransactionName, &RSEditRecord, &RSTransDtlRecord, &EmailGroup);
      When "E"
         If &FirstErrorEmailLoop = "Y" Then;
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &MsgSetNbrBind, &MsgNbrBind);
            DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
            &FirstErrorEmailLoop = "N";
         End-If;
         &MsgLineErrorArray = BuildEmailBody(&TransactionName, &RSEditRecord, &RSTransDtlRecord, &EmailGroup);
      End-Evaluate;
      
      If All(&MsgLineSubmitArray) Then;
         AppendMsgDetail(&MsgLineSubmitArray, DERIVED_SS.HR_EMAIL_TEXT);
         DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
         If &SSRoleType = "ADM" Then;
            GenerateEmailURL();
         End-If;
      End-If;
      
      If All(&MsgLineApprArray) Then;
         AppendMsgDetail(&MsgLineApprArray, DERIVED_SS.HR_EMAIL_TEXT);
         DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
         If &SSRoleType = "ADM" Then;
            GenerateEmailURL();
         End-If;
      End-If;
      
      If All(&MsgLineDenyArray) Then;
         AppendMsgDetail(&MsgLineDenyArray, DERIVED_SS.HR_EMAIL_TEXT);
         DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
         If &SSRoleType = "ADM" Then;
            GenerateEmailURL();
         End-If;
      End-If;
      
      If All(&MsgLineFutureArray) Then;
         AppendMsgDetail(&MsgLineFutureArray, DERIVED_SS.HR_EMAIL_TEXT);
         DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
         If &SSRoleType = "ADM" Then;
            GenerateEmailURL();
         End-If;
      End-If;
      
      If All(&MsgLineSuccessArray) Then;
         AppendMsgDetail(&MsgLineSuccessArray, DERIVED_SS.HR_EMAIL_TEXT);
         DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
         If &SSRoleType = "ADM" Then;
            GenerateEmailURL();
         End-If;
      End-If;
      
      If All(&MsgLineWarnArray) Then;
         AppendMsgDetail(&MsgLineWarnArray, DERIVED_SS.HR_EMAIL_TEXT);
         DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
         If &SSRoleType = "ADM" Then;
            GenerateEmailURL();
         End-If;
      End-If;
      
      If All(&MsgLineErrWarnArray) Then;
         AppendMsgDetail(&MsgLineErrWarnArray, DERIVED_SS.HR_EMAIL_TEXT);
         DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
         If &SSRoleType = "ADM" Then;
            GenerateEmailURL();
         End-If;
      End-If;
      
      If All(&MsgLineErrorArray) Then;
         AppendMsgDetail(&MsgLineErrorArray, DERIVED_SS.HR_EMAIL_TEXT);
         DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF;
         If &SSRoleType = "ADM" Then;
            GenerateEmailURL();
         End-If;
      End-If;
      
      &MsgLineSubmitArray = Null;
      &MsgLineApprArray = Null;
      &MsgLineDenyArray = Null;
      &MsgLineFutureArray = Null;
      &MsgLineSuccessArray = Null;
      &MsgLineWarnArray = Null;
      &MsgLineErrWarnArray = Null;
      &MsgLineErrorArray = Null;
   End-For;
   
   If &SSRoleType <> "ADM" Then;
      GenerateEmailURL();
   End-If;
   
End-Function;

/************************************************************************************************
        Function: GetFolksToNotify()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Function that filters out the rows that contain roleusers who should be notified as a 
                  result of a process action save (submitted, denied or approved) to a self service 
                  request.

                  Folks who should be notified of status include anyone who has been involved up to 
                  the current step.  They will receive notifications that point them to a view status
                  page. 

                  Other person(s) who should be notified include the next person (if any) associated 
                  with the next process step.  These individuals receive notifications that suggest
                  they need to approve, deny or (in the case of administrators), process this self 
                  service request.
************************************************************************************************/
Function GetFolksToNotify();
   
   &InsertRow = 1;
   &ProcFolksInsRow = 1;
   &NextStep = (&StepWereOn + 1);
   &Loop1 = "Y";
   
   &RSNotifyProcFolks = CreateRowset(Record.SS_PROCESS_WRK);
   
   If &ComponentUse = "ORG" Then;
      &ProcessScroll = &RSProcDtlScroll;
      &ProcessRec = &RSProcDtlRec;
   End-If;
   
   If &ComponentUse = "APR" Or
         &ComponentUse = "ADM" Then;
      &ProcessScroll = "Scroll.SS_PROC_FOLKS";
      &ProcessRec = "Record.SS_PROC_FOLKS";
   End-If;
   
   For &I = 1 To &RSEdit.ActiveRowCount;
      &RSProcFolks = &RSEdit.GetRow(&I).GetRowset(@&ProcessScroll);
      &SSGrpID = &RSProcFolks.GetRow(1).GetRecord(@&ProcessRec).GetField(Field.SS_GRP_ID).Value;
      &SSTransID = &RSProcFolks.GetRow(1).GetRecord(@&ProcessRec).GetField(Field.SS_TRANS_ID).Value;
      
      Evaluate &ComponentUse
      When "ORG"
      When "APR"
      When "ADM";
         &RSProcFolksARC = &RSProcFolks.ActiveRowCount;
         For &m = 1 To &RSProcFolksARC;
            &StepCheck = &RSProcFolks.GetRow(&m).GetRecord(@&ProcessRec).GetField(Field.PROCESS_STEP).Value;
            &ThisRoleUser = &RSProcFolks.GetRow(&m).GetRecord(@&ProcessRec).GetField(Field.ROLEUSER).Value;
            If &StepCheck <= &NextStep Then;
               If &Loop1 <> "Y" Then;
                  &RSNotifyProcFolks.InsertRow(&InsertRow);
                  &InsertRow = &InsertRow + 1;
               End-If;
               &RSProcFolksRecOBj = &RSProcFolks.GetRow(&m).GetRecord(@&ProcessRec);
               &RSNotifyProcFolksRecOBj = &RSNotifyProcFolks.GetRow(&InsertRow).GetRecord(Record.SS_PROCESS_WRK);
               &RSProcFolksRecOBj.CopyFieldsTo(&RSNotifyProcFolksRecOBj);
               &RSNotifyProcFolksRecOBj.KEYS_ROW.Value = &I;
               &RSNotifyProcFolksRecOBj.PROCESS_ACTION.Value = &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.LAST_PROC_ACTION).Value;
               &RSNotifyProcFolksRecOBj.EMPLID.Value = &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.EMPLID).Value;
               &RSNotifyProcFolksRecOBj.EMPLNAME.Value = &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.EMPLID).GetRelated(PERSON_NAME.NAME).Value;
            Else;
               Break;
            End-If;
            &Loop1 = "N";
         End-For;
      End-Evaluate;
   End-For;
   
   &SortRec = "SS_PROCESS_WRK";
   &Sortfield1 = &SortRec | ".PROCESS_STEP";
   &Sortfield2 = &SortRec | ".ROLEUSER";
   &RSNotifyProcFolks.Sort(@&Sortfield1, "A", @&Sortfield2, "A");
   
End-Function;

/************************************************************************************************
        Function: GetEmailConfig()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Basic function that reads the message catalog entries that should be used to 
                  construct email messages used in a self service business process.
************************************************************************************************/
Function GetEmailConfig();
   TransSpecificProcess(&TransactionName, "GetEmailConfigStart", &ComponentUse, &RunNextFrameworkCode);
   If &RunNextFrameworkCode = True Then;
      
      &SSIndicator = &RSEdit.GetRow(1).GetRecord(@&RSEditRec).GetField(Field.SS_STAT_INDICATOR).Value;
      
      &num_email_loops = 8;
      &RSEmailText = CreateRowset(Record.SS_EMAIL_TEXT);
      
      For &l = 1 To &num_email_loops;
         
         If &l = 1 Then;
            &EmailTextFound = &RSEmailText.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION =:2 and CURRENT_COMP_USE=:3 and NOTIFY_COMP_USE=:4 and SS_STAT_INDICATOR=' '", "DEFAULT", "1", "DFL", "DFL");
         End-If;
         
         If &l = 2 Then;
            &EmailTextFound = &RSEmailText.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION =:2 and CURRENT_COMP_USE=:3 and NOTIFY_COMP_USE=:4 and SS_STAT_INDICATOR=' '", "DEFAULT", "1", &ComponentUse, &NotifyCompUse);
         End-If;
         
         If &l = 3 Then;
            &EmailTextFound = &RSEmailText.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION =:2 and CURRENT_COMP_USE=:3 and NOTIFY_COMP_USE=:4 and SS_STAT_INDICATOR=' '", "DEFAULT", &ConfigOption, &ComponentUse, &NotifyCompUse);
         End-If;
         
         If &l = 4 Then;
            &EmailTextFound = &RSEmailText.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION =:2 and CURRENT_COMP_USE=:3 and NOTIFY_COMP_USE=:4 and SS_STAT_INDICATOR=:5", "DEFAULT", &ConfigOption, &ComponentUse, &NotifyCompUse, &SSIndicator);
         End-If;
         
         
         If &l = 5 Then;
            &EmailTextFound = &RSEmailText.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION =:2 and CURRENT_COMP_USE=:3 and NOTIFY_COMP_USE=:4 and SS_STAT_INDICATOR=' '", &TransactionName, "1", "DFL", "DFL");
         End-If;
         
         If &l = 6 Then;
            &EmailTextFound = &RSEmailText.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION =:2 and CURRENT_COMP_USE=:3 and NOTIFY_COMP_USE=:4 and SS_STAT_INDICATOR=' '", &TransactionName, "1", &ComponentUse, &NotifyCompUse);
         End-If;
         
         If &l = 7 Then;
            &EmailTextFound = &RSEmailText.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION =:2 and CURRENT_COMP_USE=:3 and NOTIFY_COMP_USE=:4 and SS_STAT_INDICATOR=' '", &TransactionName, &ConfigOption, &ComponentUse, &NotifyCompUse);
         End-If;
         
         If &l = 8 Then;
            &EmailTextFound = &RSEmailText.Fill("WHERE TRANSACTION_NAME=:1 and SS_CONFIG_OPTION =:2 and CURRENT_COMP_USE=:3 and NOTIFY_COMP_USE=:4 and SS_STAT_INDICATOR=:5", &TransactionName, &ConfigOption, &ComponentUse, &NotifyCompUse, &SSIndicator);
         End-If;
         
         If All(&EmailTextFound) Then;
            For &I = 1 To &RSEmailText.ActiveRowCount
               &EmailPart = &RSEmailText.GetRow(&I).GetRecord(Record.SS_EMAIL_TEXT).GetField(Field.EMAIL_PART).Value;
               &MsgSetNbr = &RSEmailText.GetRow(&I).GetRecord(Record.SS_EMAIL_TEXT).GetField(Field.MESSAGE_SET_NBR).Value;
               &MsgNbr = &RSEmailText.GetRow(&I).GetRecord(Record.SS_EMAIL_TEXT).GetField(Field.MESSAGE_NBR).Value;
               Evaluate &EmailPart
               When "M"
                  &SubmitMsgSetNbr = &MsgSetNbr;
                  &SubmitMsgNbr = &MsgNbr;
               When "A"
                  &ApprMsgSetNbr = &MsgSetNbr;
                  &ApprMsgNbr = &MsgNbr;
               When "D"
                  &DenyMsgSetNbr = &MsgSetNbr;
                  &DenyMsgNbr = &MsgNbr;
               When "C"
                  &BodyCloseMsgSetNbr = &MsgSetNbr;
                  &BodyCloseMsgNbr = &MsgNbr;
               When "I"
                  &BodyIntroMsgSetNbr = &MsgSetNbr;
                  &BodyIntroMsgNbr = &MsgNbr;
               When "S"
                  &SubjMsgSetNbr = &MsgSetNbr;
                  &SubjMsgNbr = &MsgNbr;
               When "W"
                  &WarningMsgSetNbr = &MsgSetNbr;
                  &WarningMsgNbr = &MsgNbr;
               When "E"
                  &ErrorMsgSetNbr = &MsgSetNbr;
                  &ErrorMsgNbr = &MsgNbr;
               When "B"
                  &ErrWrnMsgSetNbr = &MsgSetNbr;
                  &ErrWrnMsgNbr = &MsgNbr;
               When "F"
                  &FutureMsgSetNbr = &MsgSetNbr;
                  &FutureMsgNbr = &MsgNbr;
               When "U"
                  &SuccessMsgSetNbr = &MsgSetNbr;
                  &SuccessMsgNbr = &MsgNbr;
               When "L"
                  &URLMsgSetNbr = &MsgSetNbr;
                  &URLMsgNbr = &MsgNbr;
               End-Evaluate;
            End-For;
         End-If;
      End-For;
      
   End-If;
   TransSpecificProcess(&TransactionName, "GetEmailConfigEnd", &ComponentUse, &RunNextFrameworkCode);
End-Function;

/************************************************************************************************
        Function: BatchRequestsPerFolk()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Function looks at the detailed process-related information in RSProcDTL for every 
                  key occurence in RSEdit.  Loops through each ProcessDTL row and batches up all 
                  requests that should be delivered to the same person (instead of one notification 
                  per/request)
************************************************************************************************/
Function BatchRequestsPerFolk();
   
   /* Declare local variables */
   Local boolean &first_time_sts, &first_time_apr, &first_time_trn_adm, &first_time_trn_ciadm, &first_time_adm, &first_time_ciadm;
   Local string &NotifyWorklist_sts, &NotifyWorklist_apr, &NotifyWorklist_trn_adm, &NotifyWorklist_trn_ciadm, &NotifyWorklist_adm, &NotifyWorklist_ciadm;
   Local string &WorklistRec_sts, &WorklistRec_apr, &WorklistRec_trn_adm, &WorklistRec_trn_ciadm, &WorklistRec_adm, &WorklistRec_ciadm;
   Local number &instmax_start_sts, &instmax_start_apr, &instmax_start_trn_adm, &instmax_start_trn_ciadm, &instmax_start_adm, &instmax_start_ciadm;
   Local number &instmax_end_sts, &instmax_end_apr, &instmax_end_trn_adm, &instmax_end_trn_ciadm, &instmax_end_adm, &instmax_end_ciadm;
   Local boolean &trigger_sts, &trigger_apr, &trigger_trn_adm, &trigger_trn_ciadm, &trigger_adm, &trigger_ciadm;
   Local string &UpdateWL;
   Local string &SelectSSTranID;
   Local SQL &sqlSSTranID;
   Local boolean &first_time;
   Local number &SSTranID, &InstanceID, &LastSSTranID;
   
   /* Initialize local variables */
   &first_time_sts = True;
   &instmax_start_sts = 0;
   &instmax_end_sts = 0;
   &trigger_sts = False;
   
   &first_time_apr = True;
   &instmax_start_apr = 0;
   &instmax_end_apr = 0;
   &trigger_apr = False;
   
   &first_time_trn_adm = True;
   &instmax_start_trn_adm = 0;
   &instmax_end_trn_adm = 0;
   &trigger_trn_adm = False;
   
   &first_time_trn_ciadm = True;
   &instmax_start_trn_ciadm = 0;
   &instmax_end_trn_ciadm = 0;
   &trigger_trn_ciadm = False;
   
   &first_time_adm = True;
   &instmax_start_adm = 0;
   &instmax_end_adm = 0;
   &trigger_adm = False;
   
   &first_time_ciadm = True;
   &instmax_start_ciadm = 0;
   &instmax_end_ciadm = 0;
   &trigger_ciadm = False;
   
   /* Set Worklist Definition and Worklist Record for each Workflow Activity that can be triggered by this function. */
   SQLExec("SELECT ROUTENAME, WLRECNAME FROM PSEVENTROUTE WHERE ACTIVITYNAME = :1 AND EVENTNAME = :2 AND WLRECNAME <> ' '", "SS_TRIGGER_STS_ACTIVITY", "WL For Request", &NotifyWorklist_sts, &WorklistRec_sts);
   SQLExec("SELECT ROUTENAME, WLRECNAME FROM PSEVENTROUTE WHERE ACTIVITYNAME = :1 AND EVENTNAME = :2 AND WLRECNAME <> ' '", "SS_TRIGGER_APR_ACTIVITY", "WL For Request", &NotifyWorklist_apr, &WorklistRec_apr);
   SQLExec("SELECT ROUTENAME, WLRECNAME FROM PSEVENTROUTE WHERE ACTIVITYNAME = :1 AND EVENTNAME = :2 AND WLRECNAME <> ' '", "SS_TRIGGER_TRN_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_trn_adm, &WorklistRec_trn_adm);
   SQLExec("SELECT ROUTENAME, WLRECNAME FROM PSEVENTROUTE WHERE ACTIVITYNAME = :1 AND EVENTNAME = :2 AND WLRECNAME <> ' '", "SS_TRIGGER_CI_TRN_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_trn_ciadm, &WorklistRec_trn_ciadm);
   SQLExec("SELECT ROUTENAME, WLRECNAME FROM PSEVENTROUTE WHERE ACTIVITYNAME = :1 AND EVENTNAME = :2 AND WLRECNAME <> ' '", "SS_TRIGGER_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_adm, &WorklistRec_adm);
   SQLExec("SELECT ROUTENAME, WLRECNAME FROM PSEVENTROUTE WHERE ACTIVITYNAME = :1 AND EVENTNAME = :2 AND WLRECNAME <> ' '", "SS_TRIGGER_CI_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_ciadm, &WorklistRec_ciadm);
   
   &StartWLRow = 1;
   For &p = 1 To &RSNotifyProcFolks.ActiveRowCount;
      &ThisRoleUser = &RSNotifyProcFolks.GetRow(&p).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.ROLEUSER).Value;
      &SSRoleType = &RSNotifyProcFolks.GetRow(&p).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.SS_ROLETYPE).Value;
      &IsAlternate = &RSNotifyProcFolks.GetRow(&p).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.IS_ALTERNATE).Value;
      &StepCheck = &RSNotifyProcFolks.GetRow(&p).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.PROCESS_STEP).Value;
      &RoleuserEmplid = &RSNotifyProcFolks.GetRow(&p).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.ROLEUSER_EMPLID).Value;
      &TriggerWLTilRow = &p;
      If &IsAlternate = False Then;
         If &p < &RSNotifyProcFolks.ActiveRowCount Then;
            &NextRoleUser = &RSNotifyProcFolks.GetRow(&p + 1).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.ROLEUSER).Value;
            If &ThisRoleUser = &NextRoleUser Then;
               &SamePerson = "Yes";
            Else;
               &SamePerson = "No";
            End-If;
         Else;
            &SamePerson = "No";
         End-If;
         If &SamePerson = "No" Then;
            DERIVED_SS.HR_EMAIL_TEXT = "";
            DERIVED_SS.ROLEUSER_TO = &ThisRoleUser;
            If &StepCheck < &NextStep Then;
               If &SSRoleType = "ADM" Then;
                  &NotifyCompUse = "ADM"
               Else;
                  &NotifyCompUse = "STS"
               End-If;
            Else;
               &NotifyCompUse = &RSNotifyProcFolks.GetRow(&p).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.SS_ROLETYPE).Value;
            End-If;
            
            &RunNotifyLogic = True;
            
            If &StepCheck > &StepWereOn And
                  &ProcessAction = "D" And
                  &RSEdit.ActiveRowCount = 1 Then;
               &RunNotifyLogic = False;
            End-If;
            
            If &RunNotifyLogic = True Then;
               DERIVED_SS.SS_COMP_USE = &NotifyCompUse;
               
               GetEmailConfig();
               
               &CRLF = Char(13) | Char(10); /* Carriage Return / Line Feed */
               GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_SUBJECT), &SubjMsgSetNbr, &SubjMsgNbr);
               GetEmailBinds(GetLevel0().GetRow(1).GetRecord(Record.DERIVED_SS).GetField(Field.HR_EMAIL_TEXT), &BodyIntroMsgSetNbr, &BodyIntroMsgNbr);
               DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | &CRLF | &CRLF;
               
               BuildEmailSections(&SSRoleType, &ThisRoleUser, &StepWereOn);
               
               DERIVED_SS.HR_EMAIL_TEXT = DERIVED_SS.HR_EMAIL_TEXT | MsgGetExplainText(&BodyCloseMsgSetNbr, &BodyCloseMsgNbr, "Message Not Found: Message Set Number " | &BodyCloseMsgSetNbr | ", Message Number " | &BodyCloseMsgNbr);
               
               &TriggerWLEvent = False;
               &TriggerEmailEvent = False;
               
               If &SSRoleType = "ORG" Then
                  SQLExec("SELECT A.SETID_JOBCODE FROM PS_JOB A WHERE A.EMPLID = :1 AND A.EFFDT = (SELECT MAX(A_ED.EFFDT) FROM PS_JOB A_ED WHERE A.EMPLID = A_ED.EMPLID AND A.EMPL_RCD = A_ED.EMPL_RCD AND A_ED.EFFDT <= %currentdatein AND A.EFFSEQ = (SELECT MAX(A_ES.EFFSEQ) FROM PS_JOB A_ES WHERE A.EMPLID = A_ES.EMPLID AND A.EMPL_RCD = A_ES.EMPL_RCD AND A.EFFDT = A_ES.EFFDT) )", &RoleuserEmplid, &RoleUserSetid);
                  &RecEmailOriginator = EmailOriginator(&RoleUserSetid, &TransactionName);
                  &SendWF = False;
                  If &RecEmailOriginator.EMAIL_ORIG_ENTRY.Value = "Y" And
                        &RecEmailOriginator.EMAIL_ORIG_ALL.Value = "Y" And
                        &RecEmailOriginator.EMAIL_ORIG_FINAL.Value = "Y" Then
                     &SendWF = True;
                  Else;
                     If (&RecEmailOriginator.EMAIL_ORIG_ENTRY.Value = "Y" And
                           &StepWereOn = 1) Or
                           (&RecEmailOriginator.EMAIL_ORIG_ALL.Value = "Y" And
                              &StepWereOn <> 1) Or
                           (&RecEmailOriginator.EMAIL_ORIG_FINAL.Value = "Y" And
                              &MoreProcFolksFound = False) Then;
                        &SendWF = True;
                     End-If;
                  End-If;
               End-If;
               
               If &SSRoleType <> "ORG" Then;
                  &SendWF = True;
               End-If;
               
               If (&IsAlternate = False And
                     &SSRoleType <> "ORG") Then;
                  &SendWF = True;
               End-If;
               
               If &SendWF = True Then;
                  &Profile = GetWFProfile(&ThisRoleUser, &RoleUserSetid, &TransactionName);
                  
                  If None(&Profile) Then;
                     &TriggerWLEvent = True;
                     &TriggerEmailEvent = True;
                  End-If;
                  
                  If &Profile = "ALL" Then;
                     &TriggerWLEvent = True;
                     &TriggerEmailEvent = True;
                  End-If;
                  
                  If &Profile = "EML" Then;
                     &TriggerWLEvent = False;
                     &TriggerEmailEvent = True;
                  End-If;
                  
                  If &Profile = "NON" Then;
                     &TriggerWLEvent = False;
                     &TriggerEmailEvent = False;
                  End-If;
                  
                  If &Profile = "WL" Then;
                     &TriggerWLEvent = True;
                     &TriggerEmailEvent = False;
                  End-If;
               End-If;
               
               If &SendWF = True Then;
                  Evaluate DERIVED_SS.SS_COMP_USE
                  When "STS"
                     &BusProc = "BUSPROCESS." | "SS_DEFAULT_BP";
                     &EmailEvent = "BUSEVENT." | "Email For Request";
                     &WLEvent = "BUSEVENT." | "WL For Request";
                     Evaluate &TransactionType
                     When "Manager"
                        &Activity = "BUSACTIVITY." | "SS_TRIGGER_STS_ACTIVITY";
                     When "Employee"
                        Evaluate &SSRoleType
                        When "APR"
                           &Activity = "BUSACTIVITY." | "SS_TRIGGER_STS_ACTIVITY";
                        When "ADM"
                           Break;
                        When-Other;
                           &Activity = "BUSACTIVITY." | "SS_TRIGGER_EMP_STS_ACTIVITY";
                        End-Evaluate;
                     End-Evaluate;
                  When "APR"
                     &BusProc = "BUSPROCESS." | "SS_DEFAULT_BP";
                     &Activity = "BUSACTIVITY." | "SS_TRIGGER_APR_ACTIVITY";
                     &EmailEvent = "BUSEVENT." | "Email For Request";
                     &WLEvent = "BUSEVENT." | "WL For Request";
                  When "ADM"
                     Evaluate &TransactionName
                     When "HR_TRAIN_ENROLL"
                     When "HR_TRAIN_ENROLL_MGR"
                        Evaluate &Call_CI
                        When False
                           &BusProc = "BUSPROCESS." | "SS_DEFAULT_BP";
                           &Activity = "BUSACTIVITY." | "SS_TRIGGER_TRN_ADM_ACTIVITY";
                           &EmailEvent = "BUSEVENT." | "Email For Request";
                           &WLEvent = "BUSEVENT." | "WL For Request";
                        When True
                           &BusProc = "BUSPROCESS." | "SS_DEFAULT_BP";
                           &Activity = "BUSACTIVITY." | "SS_TRIGGER_CI_TRN_ADM_ACTIVITY";
                           &EmailEvent = "BUSEVENT." | "Email For Request";
                           &WLEvent = "BUSEVENT." | "WL For Request";
                        End-Evaluate;
                     When-Other
                        Evaluate &Call_CI
                        When False
                           &BusProc = "BUSPROCESS." | "SS_DEFAULT_BP";
                           &Activity = "BUSACTIVITY." | "SS_TRIGGER_ADM_ACTIVITY";
                           &EmailEvent = "BUSEVENT." | "Email For Request";
                           &WLEvent = "BUSEVENT." | "WL For Request";
                        When True
                           &BusProc = "BUSPROCESS." | "SS_DEFAULT_BP";
                           &Activity = "BUSACTIVITY." | "SS_TRIGGER_CI_ADM_ACTIVITY";
                           &EmailEvent = "BUSEVENT." | "Email For Request";
                           &WLEvent = "BUSEVENT." | "WL For Request";
                        End-Evaluate;
                     End-Evaluate;
                  End-Evaluate;
                  
               End-If;
               
               TransSpecificProcess(&TransactionName, "WorkflowEnd", &ComponentUse, &RunNextFrameworkCode);
               
               If &SendWF = True Then;
                  
                  If &TriggerEmailEvent = True Then;
                     &Result = TriggerBusinessEvent(@&BusProc, @&Activity, @&EmailEvent);
                  End-If;
                  
                  If &TriggerWLEvent = True Then
                     
                     /* Check the Activity of the worklist event being triggered to retrieve the last instance number and to initialize the start and end instance number */
                     /* This information is stored to update the PSWORKLIST table and to manage pooled worklists */
                     Evaluate &Activity
                     When = "BUSACTIVITY.SS_TRIGGER_STS_ACTIVITY"
                        
                        If &first_time_sts Then
                           /* Get INSTMAX for poolist starting value */
                           SQLExec("SELECT INSTMAX FROM PSWLINSTMAX WHERE BUSPROCNAME = :1 AND ACTIVITYNAME = :2 AND EVENTNAME = :3 AND WORKLISTNAME = :4", "SS_DEFAULT_BP", "SS_TRIGGER_STS_ACTIVITY", "WL For Request", &NotifyWorklist_sts, &instmax_start_sts);
                           &instmax_start_sts = &instmax_start_sts + 1;
                           &instmax_end_sts = &instmax_start_sts;
                           &first_time_sts = False;
                        End-If;
                        
                     When = "BUSACTIVITY.SS_TRIGGER_APR_ACTIVITY"
                        
                        If &first_time_apr Then
                           /* Get INSTMAX for poolist starting value */
                           SQLExec("SELECT INSTMAX FROM PSWLINSTMAX WHERE BUSPROCNAME = :1 AND ACTIVITYNAME = :2 AND EVENTNAME = :3 AND WORKLISTNAME = :4", "SS_DEFAULT_BP", "SS_TRIGGER_APR_ACTIVITY", "WL For Request", &NotifyWorklist_apr, &instmax_start_apr);
                           &instmax_start_apr = &instmax_start_apr + 1;
                           &instmax_end_apr = &instmax_start_apr;
                           &first_time_apr = False;
                        End-If;
                        
                     When = "BUSACTIVITY.SS_TRIGGER_TRN_ADM_ACTIVITY"
                        
                        If &first_time_trn_adm Then
                           /* Get INSTMAX for poolist starting value */
                           SQLExec("SELECT INSTMAX FROM PSWLINSTMAX WHERE BUSPROCNAME = :1 AND ACTIVITYNAME = :2 AND EVENTNAME = :3 AND WORKLISTNAME = :4", "SS_DEFAULT_BP", "SS_TRIGGER_TRN_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_trn_adm, &instmax_start_trn_adm);
                           &instmax_start_trn_adm = &instmax_start_trn_adm + 1;
                           &instmax_end_trn_adm = &instmax_start_trn_adm;
                           &first_time_trn_adm = False;
                        End-If;
                        
                     When = "BUSACTIVITY.SS_TRIGGER_CI_TRN_ADM_ACTIVITY"
                        
                        If &first_time_trn_ciadm Then
                           /* Get INSTMAX for poolist starting value */
                           SQLExec("SELECT INSTMAX FROM PSWLINSTMAX WHERE BUSPROCNAME = :1 AND ACTIVITYNAME = :2 AND EVENTNAME = :3 AND WORKLISTNAME = :4", "SS_DEFAULT_BP", "SS_TRIGGER_CI_TRN_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_trn_ciadm, &instmax_start_trn_ciadm);
                           &instmax_start_trn_ciadm = &instmax_start_trn_ciadm + 1;
                           &instmax_end_trn_ciadm = &instmax_start_trn_ciadm;
                           &first_time_trn_ciadm = False;
                        End-If;
                        
                     When = "BUSACTIVITY.SS_TRIGGER_ADM_ACTIVITY"
                        
                        If &first_time_adm Then
                           /* Get INSTMAX for poolist starting value */
                           SQLExec("SELECT INSTMAX FROM PSWLINSTMAX WHERE BUSPROCNAME = :1 AND ACTIVITYNAME = :2 AND EVENTNAME = :3 AND WORKLISTNAME = :4", "SS_DEFAULT_BP", "SS_TRIGGER_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_adm, &instmax_start_adm);
                           &instmax_start_adm = &instmax_start_adm + 1;
                           &instmax_end_adm = &instmax_start_adm;
                           &first_time_adm = False;
                        End-If;
                        
                     When = "BUSACTIVITY.SS_TRIGGER_CI_ADM_ACTIVITY"
                        
                        If &first_time_ciadm Then
                           /* Get INSTMAX for poolist starting value */
                           SQLExec("SELECT INSTMAX FROM PSWLINSTMAX WHERE BUSPROCNAME = :1 AND ACTIVITYNAME = :2 AND EVENTNAME = :3 AND WORKLISTNAME = :4", "SS_DEFAULT_BP", "SS_TRIGGER_CI_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_ciadm, &instmax_start_ciadm);
                           &instmax_start_ciadm = &instmax_start_ciadm + 1;
                           &instmax_end_ciadm = &instmax_start_ciadm;
                           &first_time_ciadm = False;
                        End-If;
                        
                     End-Evaluate;
                     
                     If &SSRoleType = "ADM" Then;
                        For &I = &StartWLRow To &TriggerWLTilRow;
                           DERIVED_SS.SS_GRP_ID = &RSNotifyProcFolks.GetRow(&I).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.SS_GRP_ID).Value;
                           DERIVED_SS.SS_TRANS_ID = &RSNotifyProcFolks.GetRow(&I).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.SS_TRANS_ID).Value;
                           &KeysRow = &RSNotifyProcFolks.GetRow(&I).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.KEYS_ROW).Value;
                           &KeysAction = &RSNotifyProcFolks.GetRow(&I).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.PROCESS_ACTION).Value;
                           DERIVED_SS.EMPLID_TO9 = &RSNotifyProcFolks.GetRow(&I).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.EMPLID).Value;
                           DERIVED_SS.NAME = &RSNotifyProcFolks.GetRow(&I).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.EMPLNAME).Value;
                           If &KeysAction <> "D" Then;
                              
                              &Result = TriggerBusinessEvent(@&BusProc, @&Activity, @&WLEvent);
                              /* Check the Activity triggered to increment the end instance number */
                              Evaluate &Activity
                              When = "BUSACTIVITY.SS_TRIGGER_STS_ACTIVITY"
                                 &instmax_end_sts = &instmax_end_sts + 1;
                                 &trigger_sts = True;
                              When = "BUSACTIVITY.SS_TRIGGER_APR_ACTIVITY"
                                 &instmax_end_apr = &instmax_end_apr + 1;
                                 &trigger_apr = True;
                              When = "BUSACTIVITY.SS_TRIGGER_TRN_ADM_ACTIVITY"
                                 &instmax_end_trn_adm = &instmax_end_trn_adm + 1;
                                 &trigger_trn_adm = True;
                              When = "BUSACTIVITY.SS_TRIGGER_CI_TRN_ADM_ACTIVITY"
                                 &instmax_end_trn_ciadm = &instmax_end_trn_ciadm + 1;
                                 &trigger_trn_ciadm = True;
                              When = "BUSACTIVITY.SS_TRIGGER_ADM_ACTIVITY"
                                 &instmax_end_adm = &instmax_end_adm + 1;
                                 &trigger_adm = True;
                              When = "BUSACTIVITY.SS_TRIGGER_CI_ADM_ACTIVITY"
                                 &instmax_end_ciadm = &instmax_end_ciadm + 1;
                                 &trigger_ciadm = True;
                              End-Evaluate;
                              
                           End-If;
                        End-For;
                        
                     Else
                        DERIVED_SS.SS_GRP_ID = &RSNotifyProcFolks.GetRow(&p).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.SS_GRP_ID).Value;
                        DERIVED_SS.SS_TRANS_ID = &RSNotifyProcFolks.GetRow(&p).GetRecord(Record.SS_PROCESS_WRK).GetField(Field.SS_TRANS_ID).Value;
                        
                        &Result = TriggerBusinessEvent(@&BusProc, @&Activity, @&WLEvent);
                        /* Check the Activity triggered to increment the end instance number */
                        Evaluate &Activity
                        When = "BUSACTIVITY.SS_TRIGGER_STS_ACTIVITY"
                           &instmax_end_sts = &instmax_end_sts + 1;
                           &trigger_sts = True;
                        When = "BUSACTIVITY.SS_TRIGGER_APR_ACTIVITY"
                           &instmax_end_apr = &instmax_end_apr + 1;
                           &trigger_apr = True;
                        When = "BUSACTIVITY.SS_TRIGGER_TRN_ADM_ACTIVITY"
                           &instmax_end_trn_adm = &instmax_end_trn_adm + 1;
                           &trigger_trn_adm = True;
                        When = "BUSACTIVITY.SS_TRIGGER_CI_TRN_ADM_ACTIVITY"
                           &instmax_end_trn_ciadm = &instmax_end_trn_ciadm + 1;
                           &trigger_trn_ciadm = True;
                        When = "BUSACTIVITY.SS_TRIGGER_ADM_ACTIVITY"
                           &instmax_end_adm = &instmax_end_adm + 1;
                           &trigger_adm = True;
                        When = "BUSACTIVITY.SS_TRIGGER_CI_ADM_ACTIVITY"
                           &instmax_end_ciadm = &instmax_end_ciadm + 1;
                           &trigger_ciadm = True;
                        End-Evaluate;
                        
                     End-If;
                     
                  End-If;
               End-If;
               &StartWLRow = &TriggerWLTilRow + 1;
            End-If;
         End-If;
      End-If;
   End-For;
   
   /* Check if Activity Worklist was triggered */
   /*   - If true, perform updates to the Worklist table and respective Worklist Record to managed pooled worklists */
   
   /* Check SS_TRIGGER_STS_ACTIVITY triggered */
   If &trigger_sts Then
      SQLExec("UPDATE PSWORKLIST SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7", &instmax_start_sts, "SS_DEFAULT_BP", "SS_TRIGGER_STS_ACTIVITY", "WL For Request", &NotifyWorklist_sts, &instmax_start_sts, &instmax_end_sts);
      
      &UpdateWL = "UPDATE PS_" | &WorklistRec_sts | " SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7";
      SQLExec(&UpdateWL, &instmax_start_sts, "SS_DEFAULT_BP", "SS_TRIGGER_STS_ACTIVITY", "WL For Request", &NotifyWorklist_sts, &instmax_start_sts, &instmax_end_sts);
   End-If;
   
   /* Check SS_TRIGGER_APR_ACTIVITY triggered */
   If &trigger_apr Then
      SQLExec("UPDATE PSWORKLIST SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7", &instmax_start_apr, "SS_DEFAULT_BP", "SS_TRIGGER_APR_ACTIVITY", "WL For Request", &NotifyWorklist_apr, &instmax_start_apr, &instmax_end_apr);
      
      &UpdateWL = "UPDATE PS_" | &WorklistRec_apr | " SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7";
      SQLExec(&UpdateWL, &instmax_start_apr, "SS_DEFAULT_BP", "SS_TRIGGER_APR_ACTIVITY", "WL For Request", &NotifyWorklist_apr, &instmax_start_apr, &instmax_end_apr);
   End-If;
   
   /* Check SS_TRIGGER_TRN_ADM_ACTIVITY triggered */
   If &trigger_trn_adm Then
      SQLExec("UPDATE PSWORKLIST SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7", &instmax_start_trn_adm, "SS_DEFAULT_BP", "SS_TRIGGER_TRN_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_trn_adm, &instmax_start_trn_adm, &instmax_end_trn_adm);
      
      &UpdateWL = "UPDATE PS_" | &WorklistRec_trn_adm | " SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7";
      SQLExec(&UpdateWL, &instmax_start_trn_adm, "SS_DEFAULT_BP", "SS_TRIGGER_TRN_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_trn_adm, &instmax_start_trn_adm, &instmax_end_trn_adm);
   End-If;
   
   /* Check SS_TRIGGER_CI_TRN_ADM_ACTIVITY triggered */
   If &trigger_trn_ciadm Then
      SQLExec("UPDATE PSWORKLIST SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7", &instmax_start_trn_ciadm, "SS_DEFAULT_BP", "SS_TRIGGER_CI_TRN_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_trn_ciadm, &instmax_start_trn_ciadm, &instmax_end_trn_ciadm);
      
      &UpdateWL = "UPDATE PS_" | &WorklistRec_trn_ciadm | " SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7";
      SQLExec(&UpdateWL, &instmax_start_trn_ciadm, "SS_DEFAULT_BP", "SS_TRIGGER_CI_TRN_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_trn_ciadm, &instmax_start_trn_ciadm, &instmax_end_trn_ciadm);
   End-If;
   
   /* Check SS_TRIGGER_ADM_ACTIVITY triggered */
   If &trigger_adm Then
      /* Administer manages each self service transaction within the self service group individually, therefore each self service transaction within the group has to have the same transaction id for pooled worklist */
      
      &SelectSSTranID = "SELECT DISTINCT SS_TRANS_ID, INSTANCEID FROM PS_" | &WorklistRec_adm | " WHERE BUSPROCNAME = :1 AND ACTIVITYNAME = :2 AND EVENTNAME = :3 AND WORKLISTNAME = :4 AND SS_GRP_ID = :5 ORDER BY SS_TRANS_ID";
      &sqlSSTranID = CreateSQL(&SelectSSTranID, "SS_DEFAULT_BP", "SS_TRIGGER_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_adm, DERIVED_SS.SS_GRP_ID.Value);
      
      /* For each self service transaction ID in the self service group, set the workflow transaction id for pooled worklists */
      &first_time = True;
      While &sqlSSTranID.Fetch(&SSTranID, &InstanceID)
         
         If Not &first_time Then
            
            If &SSTranID <> &LastSSTranID Then
               &LastSSTranID = &SSTranID;
               &instmax_start_adm = &instmax_start_adm + 1;
            End-If;
         Else
            &LastSSTranID = &SSTranID;
            &first_time = False;
         End-If;
         
         SQLExec("UPDATE PSWORKLIST SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND INSTANCEID = :6", &instmax_start_adm, "SS_DEFAULT_BP", "SS_TRIGGER_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_adm, &InstanceID);
         
         &UpdateWL = "UPDATE PS_" | &WorklistRec_adm | " SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND INSTANCEID = :6";
         SQLExec(&UpdateWL, &instmax_start_adm, "SS_DEFAULT_BP", "SS_TRIGGER_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_adm, &InstanceID);
         
      End-While;
      
   End-If;
   
   /* Check SS_TRIGGER_CI_ADM_ACTIVITY triggered */
   If &trigger_ciadm Then
      SQLExec("UPDATE PSWORKLIST SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7", &instmax_start_ciadm, "SS_DEFAULT_BP", "SS_TRIGGER_CI_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_ciadm, &instmax_start_ciadm, &instmax_end_ciadm);
      
      &UpdateWL = "UPDATE PS_" | &WorklistRec_ciadm | " SET TRANSACTIONID = :1 WHERE BUSPROCNAME = :2 AND ACTIVITYNAME = :3 AND EVENTNAME = :4 AND WORKLISTNAME = :5 AND TRANSACTIONID >= :6 AND TRANSACTIONID <= :7";
      SQLExec(&UpdateWL, &instmax_start_ciadm, "SS_DEFAULT_BP", "SS_TRIGGER_CI_ADM_ACTIVITY", "WL For Request", &NotifyWorklist_ciadm, &instmax_start_ciadm, &instmax_end_ciadm);
   End-If;
   
End-Function;

/************************************************************************************************
        Function: GetApprErrorNotify()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: 
************************************************************************************************/
Function GetApprErrorNotify();
   
   &InsertRow = 1;
   &ProcFolksInsRow = 1;
   &NextStep = (&StepWereOn + 1);
   &Loop1 = "Y";
   
   &RSNotifyProcFolks = CreateRowset(Record.SS_PROCESS_WRK);
   
   For &I = 1 To &RSEdit.ActiveRowCount;
      &RSProcDtl = &RSEdit.GetRow(&I).GetRowset(@&RSProcDtlScroll);
      &SSGrpID = &RSProcDtl.GetRow(1).GetRecord(@&RSProcDtlRec).GetField(Field.SS_GRP_ID).Value;
      &SSTransID = &RSProcDtl.GetRow(1).GetRecord(@&RSProcDtlRec).GetField(Field.SS_TRANS_ID).Value;
      
      &RSProcDtlArc = &RSProcDtl.ActiveRowCount;
      
      For &m = 1 To &RSProcDtlArc;
         
         &StepCheck = &RSProcDtl.GetRow(&m).GetRecord(@&RSProcDtlRec).GetField(Field.PROCESS_STEP).Value;
         &ThisRoleUser = &RSProcDtl.GetRow(&m).GetRecord(@&RSProcDtlRec).GetField(Field.ROLEUSER).Value;
         
         If &Loop1 <> "Y" Then;
            &RSNotifyProcFolks.InsertRow(&InsertRow);
            &InsertRow = &InsertRow + 1;
         End-If;
         
         &RSProcDtlRecObj = &RSProcDtl.GetRow(&m).GetRecord(@&RSProcDtlRec);
         &RSNotifyProcFolksRecOBj = &RSNotifyProcFolks.GetRow(&InsertRow).GetRecord(Record.SS_PROCESS_WRK);
         &RSProcDtlRecObj.CopyFieldsTo(&RSNotifyProcFolksRecOBj);
         &RSNotifyProcFolksRecOBj.KEYS_ROW.Value = &I;
         &Loop1 = "N";
      End-For;
   End-For;
   
   &SortRec = "SS_PROCESS_WRK";
   &Sortfield1 = &SortRec | ".PROCESS_STEP";
   &Sortfield2 = &SortRec | ".ROLEUSER";
   &RSNotifyProcFolks.Sort(@&Sortfield1, "A", @&Sortfield2, "A");
   
End-Function;


/************************************************************************************************
        Function: ApprErrorExceptionProc()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: The following code creates the exception array and populates
                  the error table with the correct error message.
************************************************************************************************/
Function ApprErrorExceptionProc();
   
   For &K = 1 To &RSEdit.ActiveRowCount;
      
      &ExceptionTableName = "SS_ERR_WRN";
      
      /* Create the SS Application Exception Arrays */
      &SSExceptionArray = CreateSSExceptionArray(&ExceptionTableName);
      &SSExceptionArray.Len = 0;
      
      &RSEditRecObj = &RSEdit(&K).GetRecord(@&RSEditRec);
      
      &RecNameObject = "RECORD." | &ExceptionTableName;
      &SSExceptionRec = CreateRecord(@(&RecNameObject));
      &RSEditRecObj.CopyFieldsTo(&SSExceptionRec);
      
      /* Populate the additional keys. */
      For &J = 1 To &SSExceptionRec.FieldCount
         &FieldName = &SSExceptionRec.GetField(&J).Name;
         If Not FieldExists(&FieldName, &RSEditRecObj) Then
            /* This is an additional field - it doesn't exist in &ExceptionRec */
            &FieldValue = "";
            
            Evaluate &FieldName
            When = "MESSAGE_SET_NBR"
               &FieldValue = "6605";
               Break;
            When = "MESSAGE_NBR"
               &FieldValue = "617";
               Break;
            When = "MSG_SEVERITY"
               &FieldValue = "E";
               Break;
            When = "MESSAGE_TEXT"
               &MsgText = MsgGetExplainText(6605, 617, "Message not found");
               &FieldValue = &MsgText;
               Break;
            End-Evaluate;
            
            If All(&FieldValue) Then
               &SSExceptionRec.GetField(&J).Value = &FieldValue;
            End-If;
         End-If;
      End-For;
      
      &SSExceptionArray.Push(&SSExceptionRec);
      
      /* Delete existing rows in the exception table for this transaction's keys */
      DeleteExceptions(&ExceptionTableName, &SSExceptionArray);
      
      /* Insert exceptions into the exception table */
      InsertExceptions(&ExceptionTableName, &SSExceptionArray);
      
   End-For;
End-Function;

/************************************************************************************************
        Function: RunSSWorkflow()
         Returns: Void  
 Input Arguments: N/A
    Version Date: 03/17/2002
Output Arguments: <none>
      Processing: Main routine that intiates workflow for requests in SS Framework.  
                  Called from Workflow on HR_SS_ACTIVATE.
                  Each subroutine under Build Page is described at the function level.************************************************************************************************/

Function RunSSWorkflow();
   TransSpecificProcess(&TransactionName, "WorkflowStart", &ComponentUse, &RunNextFrameworkCode);
   If &RunNextFrameworkCode = True Then;
      DERIVED_SS.CURRENT_EMPLID = %EmployeeId;
      DERIVED_SS.CURRENT_NAME = get_person_name(%EmployeeId, "", "", "");
      
      If &ComponentUse = "ORG" And
            &ApprProcError = True Then
         
         &CI_Status = "E";
         
         /* set transactions to error status */
         For &I = 1 To &RSEdit.ActiveRowCount
            &RSEdit.GetRow(&I).GetRecord(@&RSEditRec).GetField(Field.SS_STAT_INDICATOR).Value = "E";
         End-For;
         
         GetApprErrorNotify();
         BatchRequestsPerFolk();
         ApprErrorExceptionProc();
      Else
         If &AdminPerfOverride = False Then;
            GetFolksToNotify();
            BatchRequestsPerFolk();
         End-If;
      End-If;
   End-If;
   
End-Function;

